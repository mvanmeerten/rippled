// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: org/xrpl/rpc/v1/get_account_info.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "org/xrpl/rpc/v1/ledger_objects.pb.h"
#include "org/xrpl/rpc/v1/amount.pb.h"
#include "org/xrpl/rpc/v1/account.pb.h"
#include "org/xrpl/rpc/v1/ledger.pb.h"
#include "org/xrpl/rpc/v1/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto;
namespace org {
namespace xrpl {
namespace rpc {
namespace v1 {
class GetAccountInfoRequest;
class GetAccountInfoRequestDefaultTypeInternal;
extern GetAccountInfoRequestDefaultTypeInternal _GetAccountInfoRequest_default_instance_;
class GetAccountInfoResponse;
class GetAccountInfoResponseDefaultTypeInternal;
extern GetAccountInfoResponseDefaultTypeInternal _GetAccountInfoResponse_default_instance_;
class QueueData;
class QueueDataDefaultTypeInternal;
extern QueueDataDefaultTypeInternal _QueueData_default_instance_;
class QueuedTransaction;
class QueuedTransactionDefaultTypeInternal;
extern QueuedTransactionDefaultTypeInternal _QueuedTransaction_default_instance_;
}  // namespace v1
}  // namespace rpc
}  // namespace xrpl
}  // namespace org
PROTOBUF_NAMESPACE_OPEN
template<> ::org::xrpl::rpc::v1::GetAccountInfoRequest* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::GetAccountInfoRequest>(Arena*);
template<> ::org::xrpl::rpc::v1::GetAccountInfoResponse* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::GetAccountInfoResponse>(Arena*);
template<> ::org::xrpl::rpc::v1::QueueData* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::QueueData>(Arena*);
template<> ::org::xrpl::rpc::v1::QueuedTransaction* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::QueuedTransaction>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace org {
namespace xrpl {
namespace rpc {
namespace v1 {

// ===================================================================

class GetAccountInfoRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.GetAccountInfoRequest) */ {
 public:
  GetAccountInfoRequest();
  virtual ~GetAccountInfoRequest();

  GetAccountInfoRequest(const GetAccountInfoRequest& from);
  GetAccountInfoRequest(GetAccountInfoRequest&& from) noexcept
    : GetAccountInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetAccountInfoRequest& operator=(const GetAccountInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountInfoRequest& operator=(GetAccountInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetAccountInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAccountInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetAccountInfoRequest*>(
               &_GetAccountInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(GetAccountInfoRequest* other);
  friend void swap(GetAccountInfoRequest& a, GetAccountInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAccountInfoRequest* New() const final {
    return CreateMaybeMessage<GetAccountInfoRequest>(nullptr);
  }

  GetAccountInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAccountInfoRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetAccountInfoRequest& from);
  void MergeFrom(const GetAccountInfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountInfoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.GetAccountInfoRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string client_ip = 6;
  void clear_client_ip();
  static const int kClientIpFieldNumber = 6;
  const std::string& client_ip() const;
  void set_client_ip(const std::string& value);
  void set_client_ip(std::string&& value);
  void set_client_ip(const char* value);
  void set_client_ip(const char* value, size_t size);
  std::string* mutable_client_ip();
  std::string* release_client_ip();
  void set_allocated_client_ip(std::string* client_ip);

  // .org.xrpl.rpc.v1.AccountAddress account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::org::xrpl::rpc::v1::AccountAddress& account() const;
  ::org::xrpl::rpc::v1::AccountAddress* release_account();
  ::org::xrpl::rpc::v1::AccountAddress* mutable_account();
  void set_allocated_account(::org::xrpl::rpc::v1::AccountAddress* account);

  // .org.xrpl.rpc.v1.LedgerSpecifier ledger = 3;
  bool has_ledger() const;
  void clear_ledger();
  static const int kLedgerFieldNumber = 3;
  const ::org::xrpl::rpc::v1::LedgerSpecifier& ledger() const;
  ::org::xrpl::rpc::v1::LedgerSpecifier* release_ledger();
  ::org::xrpl::rpc::v1::LedgerSpecifier* mutable_ledger();
  void set_allocated_ledger(::org::xrpl::rpc::v1::LedgerSpecifier* ledger);

  // bool strict = 2;
  void clear_strict();
  static const int kStrictFieldNumber = 2;
  bool strict() const;
  void set_strict(bool value);

  // bool queue = 4;
  void clear_queue();
  static const int kQueueFieldNumber = 4;
  bool queue() const;
  void set_queue(bool value);

  // bool signer_lists = 5;
  void clear_signer_lists();
  static const int kSignerListsFieldNumber = 5;
  bool signer_lists() const;
  void set_signer_lists(bool value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.GetAccountInfoRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_ip_;
  ::org::xrpl::rpc::v1::AccountAddress* account_;
  ::org::xrpl::rpc::v1::LedgerSpecifier* ledger_;
  bool strict_;
  bool queue_;
  bool signer_lists_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto;
};
// -------------------------------------------------------------------

class GetAccountInfoResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.GetAccountInfoResponse) */ {
 public:
  GetAccountInfoResponse();
  virtual ~GetAccountInfoResponse();

  GetAccountInfoResponse(const GetAccountInfoResponse& from);
  GetAccountInfoResponse(GetAccountInfoResponse&& from) noexcept
    : GetAccountInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetAccountInfoResponse& operator=(const GetAccountInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountInfoResponse& operator=(GetAccountInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetAccountInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAccountInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetAccountInfoResponse*>(
               &_GetAccountInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(GetAccountInfoResponse* other);
  friend void swap(GetAccountInfoResponse& a, GetAccountInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAccountInfoResponse* New() const final {
    return CreateMaybeMessage<GetAccountInfoResponse>(nullptr);
  }

  GetAccountInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAccountInfoResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetAccountInfoResponse& from);
  void MergeFrom(const GetAccountInfoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.GetAccountInfoResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.AccountRoot account_data = 1;
  bool has_account_data() const;
  void clear_account_data();
  static const int kAccountDataFieldNumber = 1;
  const ::org::xrpl::rpc::v1::AccountRoot& account_data() const;
  ::org::xrpl::rpc::v1::AccountRoot* release_account_data();
  ::org::xrpl::rpc::v1::AccountRoot* mutable_account_data();
  void set_allocated_account_data(::org::xrpl::rpc::v1::AccountRoot* account_data);

  // .org.xrpl.rpc.v1.SignerList signer_list = 2;
  bool has_signer_list() const;
  void clear_signer_list();
  static const int kSignerListFieldNumber = 2;
  const ::org::xrpl::rpc::v1::SignerList& signer_list() const;
  ::org::xrpl::rpc::v1::SignerList* release_signer_list();
  ::org::xrpl::rpc::v1::SignerList* mutable_signer_list();
  void set_allocated_signer_list(::org::xrpl::rpc::v1::SignerList* signer_list);

  // .org.xrpl.rpc.v1.QueueData queue_data = 4;
  bool has_queue_data() const;
  void clear_queue_data();
  static const int kQueueDataFieldNumber = 4;
  const ::org::xrpl::rpc::v1::QueueData& queue_data() const;
  ::org::xrpl::rpc::v1::QueueData* release_queue_data();
  ::org::xrpl::rpc::v1::QueueData* mutable_queue_data();
  void set_allocated_queue_data(::org::xrpl::rpc::v1::QueueData* queue_data);

  // uint32 ledger_index = 3;
  void clear_ledger_index();
  static const int kLedgerIndexFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint32 ledger_index() const;
  void set_ledger_index(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // bool validated = 5;
  void clear_validated();
  static const int kValidatedFieldNumber = 5;
  bool validated() const;
  void set_validated(bool value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.GetAccountInfoResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::AccountRoot* account_data_;
  ::org::xrpl::rpc::v1::SignerList* signer_list_;
  ::org::xrpl::rpc::v1::QueueData* queue_data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ledger_index_;
  bool validated_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto;
};
// -------------------------------------------------------------------

class QueueData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.QueueData) */ {
 public:
  QueueData();
  virtual ~QueueData();

  QueueData(const QueueData& from);
  QueueData(QueueData&& from) noexcept
    : QueueData() {
    *this = ::std::move(from);
  }

  inline QueueData& operator=(const QueueData& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueueData& operator=(QueueData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QueueData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueueData* internal_default_instance() {
    return reinterpret_cast<const QueueData*>(
               &_QueueData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(QueueData* other);
  friend void swap(QueueData& a, QueueData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueueData* New() const final {
    return CreateMaybeMessage<QueueData>(nullptr);
  }

  QueueData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueueData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QueueData& from);
  void MergeFrom(const QueueData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueueData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.QueueData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .org.xrpl.rpc.v1.QueuedTransaction transactions = 6;
  int transactions_size() const;
  void clear_transactions();
  static const int kTransactionsFieldNumber = 6;
  ::org::xrpl::rpc::v1::QueuedTransaction* mutable_transactions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::QueuedTransaction >*
      mutable_transactions();
  const ::org::xrpl::rpc::v1::QueuedTransaction& transactions(int index) const;
  ::org::xrpl::rpc::v1::QueuedTransaction* add_transactions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::QueuedTransaction >&
      transactions() const;

  // .org.xrpl.rpc.v1.XRPDropsAmount max_spend_drops_total = 5;
  bool has_max_spend_drops_total() const;
  void clear_max_spend_drops_total();
  static const int kMaxSpendDropsTotalFieldNumber = 5;
  const ::org::xrpl::rpc::v1::XRPDropsAmount& max_spend_drops_total() const;
  ::org::xrpl::rpc::v1::XRPDropsAmount* release_max_spend_drops_total();
  ::org::xrpl::rpc::v1::XRPDropsAmount* mutable_max_spend_drops_total();
  void set_allocated_max_spend_drops_total(::org::xrpl::rpc::v1::XRPDropsAmount* max_spend_drops_total);

  // uint32 txn_count = 1;
  void clear_txn_count();
  static const int kTxnCountFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 txn_count() const;
  void set_txn_count(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // bool auth_change_queued = 2;
  void clear_auth_change_queued();
  static const int kAuthChangeQueuedFieldNumber = 2;
  bool auth_change_queued() const;
  void set_auth_change_queued(bool value);

  // uint32 lowest_sequence = 3;
  void clear_lowest_sequence();
  static const int kLowestSequenceFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint32 lowest_sequence() const;
  void set_lowest_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 highest_sequence = 4;
  void clear_highest_sequence();
  static const int kHighestSequenceFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint32 highest_sequence() const;
  void set_highest_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 lowest_ticket = 7;
  void clear_lowest_ticket();
  static const int kLowestTicketFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::uint32 lowest_ticket() const;
  void set_lowest_ticket(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 highest_ticket = 8;
  void clear_highest_ticket();
  static const int kHighestTicketFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::uint32 highest_ticket() const;
  void set_highest_ticket(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 sequence_count = 9;
  void clear_sequence_count();
  static const int kSequenceCountFieldNumber = 9;
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence_count() const;
  void set_sequence_count(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 ticket_count = 10;
  void clear_ticket_count();
  static const int kTicketCountFieldNumber = 10;
  ::PROTOBUF_NAMESPACE_ID::uint32 ticket_count() const;
  void set_ticket_count(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.QueueData)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::QueuedTransaction > transactions_;
  ::org::xrpl::rpc::v1::XRPDropsAmount* max_spend_drops_total_;
  ::PROTOBUF_NAMESPACE_ID::uint32 txn_count_;
  bool auth_change_queued_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lowest_sequence_;
  ::PROTOBUF_NAMESPACE_ID::uint32 highest_sequence_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lowest_ticket_;
  ::PROTOBUF_NAMESPACE_ID::uint32 highest_ticket_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence_count_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ticket_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto;
};
// -------------------------------------------------------------------

class QueuedTransaction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.QueuedTransaction) */ {
 public:
  QueuedTransaction();
  virtual ~QueuedTransaction();

  QueuedTransaction(const QueuedTransaction& from);
  QueuedTransaction(QueuedTransaction&& from) noexcept
    : QueuedTransaction() {
    *this = ::std::move(from);
  }

  inline QueuedTransaction& operator=(const QueuedTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueuedTransaction& operator=(QueuedTransaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QueuedTransaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueuedTransaction* internal_default_instance() {
    return reinterpret_cast<const QueuedTransaction*>(
               &_QueuedTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(QueuedTransaction* other);
  friend void swap(QueuedTransaction& a, QueuedTransaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueuedTransaction* New() const final {
    return CreateMaybeMessage<QueuedTransaction>(nullptr);
  }

  QueuedTransaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueuedTransaction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QueuedTransaction& from);
  void MergeFrom(const QueuedTransaction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueuedTransaction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.QueuedTransaction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.XRPDropsAmount fee = 2;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 2;
  const ::org::xrpl::rpc::v1::XRPDropsAmount& fee() const;
  ::org::xrpl::rpc::v1::XRPDropsAmount* release_fee();
  ::org::xrpl::rpc::v1::XRPDropsAmount* mutable_fee();
  void set_allocated_fee(::org::xrpl::rpc::v1::XRPDropsAmount* fee);

  // .org.xrpl.rpc.v1.XRPDropsAmount max_spend_drops = 4;
  bool has_max_spend_drops() const;
  void clear_max_spend_drops();
  static const int kMaxSpendDropsFieldNumber = 4;
  const ::org::xrpl::rpc::v1::XRPDropsAmount& max_spend_drops() const;
  ::org::xrpl::rpc::v1::XRPDropsAmount* release_max_spend_drops();
  ::org::xrpl::rpc::v1::XRPDropsAmount* mutable_max_spend_drops();
  void set_allocated_max_spend_drops(::org::xrpl::rpc::v1::XRPDropsAmount* max_spend_drops);

  // .org.xrpl.rpc.v1.Sequence sequence = 5;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 5;
  const ::org::xrpl::rpc::v1::Sequence& sequence() const;
  ::org::xrpl::rpc::v1::Sequence* release_sequence();
  ::org::xrpl::rpc::v1::Sequence* mutable_sequence();
  void set_allocated_sequence(::org::xrpl::rpc::v1::Sequence* sequence);

  // .org.xrpl.rpc.v1.LastLedgerSequence last_ledger_sequence = 6;
  bool has_last_ledger_sequence() const;
  void clear_last_ledger_sequence();
  static const int kLastLedgerSequenceFieldNumber = 6;
  const ::org::xrpl::rpc::v1::LastLedgerSequence& last_ledger_sequence() const;
  ::org::xrpl::rpc::v1::LastLedgerSequence* release_last_ledger_sequence();
  ::org::xrpl::rpc::v1::LastLedgerSequence* mutable_last_ledger_sequence();
  void set_allocated_last_ledger_sequence(::org::xrpl::rpc::v1::LastLedgerSequence* last_ledger_sequence);

  // .org.xrpl.rpc.v1.Ticket ticket = 7;
  bool has_ticket() const;
  void clear_ticket();
  static const int kTicketFieldNumber = 7;
  const ::org::xrpl::rpc::v1::Ticket& ticket() const;
  ::org::xrpl::rpc::v1::Ticket* release_ticket();
  ::org::xrpl::rpc::v1::Ticket* mutable_ticket();
  void set_allocated_ticket(::org::xrpl::rpc::v1::Ticket* ticket);

  // uint64 fee_level = 3 [jstype = JS_STRING];
  void clear_fee_level();
  static const int kFeeLevelFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint64 fee_level() const;
  void set_fee_level(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // bool auth_change = 1;
  void clear_auth_change();
  static const int kAuthChangeFieldNumber = 1;
  bool auth_change() const;
  void set_auth_change(bool value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.QueuedTransaction)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::XRPDropsAmount* fee_;
  ::org::xrpl::rpc::v1::XRPDropsAmount* max_spend_drops_;
  ::org::xrpl::rpc::v1::Sequence* sequence_;
  ::org::xrpl::rpc::v1::LastLedgerSequence* last_ledger_sequence_;
  ::org::xrpl::rpc::v1::Ticket* ticket_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fee_level_;
  bool auth_change_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetAccountInfoRequest

// .org.xrpl.rpc.v1.AccountAddress account = 1;
inline bool GetAccountInfoRequest::has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::AccountAddress& GetAccountInfoRequest::account() const {
  const ::org::xrpl::rpc::v1::AccountAddress* p = account_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.GetAccountInfoRequest.account)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::AccountAddress*>(
      &::org::xrpl::rpc::v1::_AccountAddress_default_instance_);
}
inline ::org::xrpl::rpc::v1::AccountAddress* GetAccountInfoRequest::release_account() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.GetAccountInfoRequest.account)
  
  ::org::xrpl::rpc::v1::AccountAddress* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::AccountAddress* GetAccountInfoRequest::mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::AccountAddress>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.GetAccountInfoRequest.account)
  return account_;
}
inline void GetAccountInfoRequest::set_allocated_account(::org::xrpl::rpc::v1::AccountAddress* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.GetAccountInfoRequest.account)
}

// bool strict = 2;
inline void GetAccountInfoRequest::clear_strict() {
  strict_ = false;
}
inline bool GetAccountInfoRequest::strict() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.GetAccountInfoRequest.strict)
  return strict_;
}
inline void GetAccountInfoRequest::set_strict(bool value) {
  
  strict_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.GetAccountInfoRequest.strict)
}

// .org.xrpl.rpc.v1.LedgerSpecifier ledger = 3;
inline bool GetAccountInfoRequest::has_ledger() const {
  return this != internal_default_instance() && ledger_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::LedgerSpecifier& GetAccountInfoRequest::ledger() const {
  const ::org::xrpl::rpc::v1::LedgerSpecifier* p = ledger_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.GetAccountInfoRequest.ledger)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::LedgerSpecifier*>(
      &::org::xrpl::rpc::v1::_LedgerSpecifier_default_instance_);
}
inline ::org::xrpl::rpc::v1::LedgerSpecifier* GetAccountInfoRequest::release_ledger() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.GetAccountInfoRequest.ledger)
  
  ::org::xrpl::rpc::v1::LedgerSpecifier* temp = ledger_;
  ledger_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::LedgerSpecifier* GetAccountInfoRequest::mutable_ledger() {
  
  if (ledger_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::LedgerSpecifier>(GetArenaNoVirtual());
    ledger_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.GetAccountInfoRequest.ledger)
  return ledger_;
}
inline void GetAccountInfoRequest::set_allocated_ledger(::org::xrpl::rpc::v1::LedgerSpecifier* ledger) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ledger_);
  }
  if (ledger) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ledger = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ledger, submessage_arena);
    }
    
  } else {
    
  }
  ledger_ = ledger;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.GetAccountInfoRequest.ledger)
}

// bool queue = 4;
inline void GetAccountInfoRequest::clear_queue() {
  queue_ = false;
}
inline bool GetAccountInfoRequest::queue() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.GetAccountInfoRequest.queue)
  return queue_;
}
inline void GetAccountInfoRequest::set_queue(bool value) {
  
  queue_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.GetAccountInfoRequest.queue)
}

// bool signer_lists = 5;
inline void GetAccountInfoRequest::clear_signer_lists() {
  signer_lists_ = false;
}
inline bool GetAccountInfoRequest::signer_lists() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.GetAccountInfoRequest.signer_lists)
  return signer_lists_;
}
inline void GetAccountInfoRequest::set_signer_lists(bool value) {
  
  signer_lists_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.GetAccountInfoRequest.signer_lists)
}

// string client_ip = 6;
inline void GetAccountInfoRequest::clear_client_ip() {
  client_ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetAccountInfoRequest::client_ip() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.GetAccountInfoRequest.client_ip)
  return client_ip_.GetNoArena();
}
inline void GetAccountInfoRequest::set_client_ip(const std::string& value) {
  
  client_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.GetAccountInfoRequest.client_ip)
}
inline void GetAccountInfoRequest::set_client_ip(std::string&& value) {
  
  client_ip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.GetAccountInfoRequest.client_ip)
}
inline void GetAccountInfoRequest::set_client_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  client_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.GetAccountInfoRequest.client_ip)
}
inline void GetAccountInfoRequest::set_client_ip(const char* value, size_t size) {
  
  client_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.GetAccountInfoRequest.client_ip)
}
inline std::string* GetAccountInfoRequest::mutable_client_ip() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.GetAccountInfoRequest.client_ip)
  return client_ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetAccountInfoRequest::release_client_ip() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.GetAccountInfoRequest.client_ip)
  
  return client_ip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetAccountInfoRequest::set_allocated_client_ip(std::string* client_ip) {
  if (client_ip != nullptr) {
    
  } else {
    
  }
  client_ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_ip);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.GetAccountInfoRequest.client_ip)
}

// -------------------------------------------------------------------

// GetAccountInfoResponse

// .org.xrpl.rpc.v1.AccountRoot account_data = 1;
inline bool GetAccountInfoResponse::has_account_data() const {
  return this != internal_default_instance() && account_data_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::AccountRoot& GetAccountInfoResponse::account_data() const {
  const ::org::xrpl::rpc::v1::AccountRoot* p = account_data_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.GetAccountInfoResponse.account_data)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::AccountRoot*>(
      &::org::xrpl::rpc::v1::_AccountRoot_default_instance_);
}
inline ::org::xrpl::rpc::v1::AccountRoot* GetAccountInfoResponse::release_account_data() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.GetAccountInfoResponse.account_data)
  
  ::org::xrpl::rpc::v1::AccountRoot* temp = account_data_;
  account_data_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::AccountRoot* GetAccountInfoResponse::mutable_account_data() {
  
  if (account_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::AccountRoot>(GetArenaNoVirtual());
    account_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.GetAccountInfoResponse.account_data)
  return account_data_;
}
inline void GetAccountInfoResponse::set_allocated_account_data(::org::xrpl::rpc::v1::AccountRoot* account_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_data_);
  }
  if (account_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account_data, submessage_arena);
    }
    
  } else {
    
  }
  account_data_ = account_data;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.GetAccountInfoResponse.account_data)
}

// .org.xrpl.rpc.v1.SignerList signer_list = 2;
inline bool GetAccountInfoResponse::has_signer_list() const {
  return this != internal_default_instance() && signer_list_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::SignerList& GetAccountInfoResponse::signer_list() const {
  const ::org::xrpl::rpc::v1::SignerList* p = signer_list_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.GetAccountInfoResponse.signer_list)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::SignerList*>(
      &::org::xrpl::rpc::v1::_SignerList_default_instance_);
}
inline ::org::xrpl::rpc::v1::SignerList* GetAccountInfoResponse::release_signer_list() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.GetAccountInfoResponse.signer_list)
  
  ::org::xrpl::rpc::v1::SignerList* temp = signer_list_;
  signer_list_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::SignerList* GetAccountInfoResponse::mutable_signer_list() {
  
  if (signer_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::SignerList>(GetArenaNoVirtual());
    signer_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.GetAccountInfoResponse.signer_list)
  return signer_list_;
}
inline void GetAccountInfoResponse::set_allocated_signer_list(::org::xrpl::rpc::v1::SignerList* signer_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(signer_list_);
  }
  if (signer_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      signer_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signer_list, submessage_arena);
    }
    
  } else {
    
  }
  signer_list_ = signer_list;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.GetAccountInfoResponse.signer_list)
}

// uint32 ledger_index = 3;
inline void GetAccountInfoResponse::clear_ledger_index() {
  ledger_index_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GetAccountInfoResponse::ledger_index() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.GetAccountInfoResponse.ledger_index)
  return ledger_index_;
}
inline void GetAccountInfoResponse::set_ledger_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  ledger_index_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.GetAccountInfoResponse.ledger_index)
}

// .org.xrpl.rpc.v1.QueueData queue_data = 4;
inline bool GetAccountInfoResponse::has_queue_data() const {
  return this != internal_default_instance() && queue_data_ != nullptr;
}
inline void GetAccountInfoResponse::clear_queue_data() {
  if (GetArenaNoVirtual() == nullptr && queue_data_ != nullptr) {
    delete queue_data_;
  }
  queue_data_ = nullptr;
}
inline const ::org::xrpl::rpc::v1::QueueData& GetAccountInfoResponse::queue_data() const {
  const ::org::xrpl::rpc::v1::QueueData* p = queue_data_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.GetAccountInfoResponse.queue_data)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::QueueData*>(
      &::org::xrpl::rpc::v1::_QueueData_default_instance_);
}
inline ::org::xrpl::rpc::v1::QueueData* GetAccountInfoResponse::release_queue_data() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.GetAccountInfoResponse.queue_data)
  
  ::org::xrpl::rpc::v1::QueueData* temp = queue_data_;
  queue_data_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::QueueData* GetAccountInfoResponse::mutable_queue_data() {
  
  if (queue_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::QueueData>(GetArenaNoVirtual());
    queue_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.GetAccountInfoResponse.queue_data)
  return queue_data_;
}
inline void GetAccountInfoResponse::set_allocated_queue_data(::org::xrpl::rpc::v1::QueueData* queue_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete queue_data_;
  }
  if (queue_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      queue_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, queue_data, submessage_arena);
    }
    
  } else {
    
  }
  queue_data_ = queue_data;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.GetAccountInfoResponse.queue_data)
}

// bool validated = 5;
inline void GetAccountInfoResponse::clear_validated() {
  validated_ = false;
}
inline bool GetAccountInfoResponse::validated() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.GetAccountInfoResponse.validated)
  return validated_;
}
inline void GetAccountInfoResponse::set_validated(bool value) {
  
  validated_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.GetAccountInfoResponse.validated)
}

// -------------------------------------------------------------------

// QueueData

// uint32 txn_count = 1;
inline void QueueData::clear_txn_count() {
  txn_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 QueueData::txn_count() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueueData.txn_count)
  return txn_count_;
}
inline void QueueData::set_txn_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  txn_count_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.QueueData.txn_count)
}

// bool auth_change_queued = 2;
inline void QueueData::clear_auth_change_queued() {
  auth_change_queued_ = false;
}
inline bool QueueData::auth_change_queued() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueueData.auth_change_queued)
  return auth_change_queued_;
}
inline void QueueData::set_auth_change_queued(bool value) {
  
  auth_change_queued_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.QueueData.auth_change_queued)
}

// uint32 lowest_sequence = 3;
inline void QueueData::clear_lowest_sequence() {
  lowest_sequence_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 QueueData::lowest_sequence() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueueData.lowest_sequence)
  return lowest_sequence_;
}
inline void QueueData::set_lowest_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  lowest_sequence_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.QueueData.lowest_sequence)
}

// uint32 highest_sequence = 4;
inline void QueueData::clear_highest_sequence() {
  highest_sequence_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 QueueData::highest_sequence() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueueData.highest_sequence)
  return highest_sequence_;
}
inline void QueueData::set_highest_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  highest_sequence_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.QueueData.highest_sequence)
}

// .org.xrpl.rpc.v1.XRPDropsAmount max_spend_drops_total = 5;
inline bool QueueData::has_max_spend_drops_total() const {
  return this != internal_default_instance() && max_spend_drops_total_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::XRPDropsAmount& QueueData::max_spend_drops_total() const {
  const ::org::xrpl::rpc::v1::XRPDropsAmount* p = max_spend_drops_total_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueueData.max_spend_drops_total)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::XRPDropsAmount*>(
      &::org::xrpl::rpc::v1::_XRPDropsAmount_default_instance_);
}
inline ::org::xrpl::rpc::v1::XRPDropsAmount* QueueData::release_max_spend_drops_total() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.QueueData.max_spend_drops_total)
  
  ::org::xrpl::rpc::v1::XRPDropsAmount* temp = max_spend_drops_total_;
  max_spend_drops_total_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::XRPDropsAmount* QueueData::mutable_max_spend_drops_total() {
  
  if (max_spend_drops_total_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::XRPDropsAmount>(GetArenaNoVirtual());
    max_spend_drops_total_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.QueueData.max_spend_drops_total)
  return max_spend_drops_total_;
}
inline void QueueData::set_allocated_max_spend_drops_total(::org::xrpl::rpc::v1::XRPDropsAmount* max_spend_drops_total) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_spend_drops_total_);
  }
  if (max_spend_drops_total) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      max_spend_drops_total = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max_spend_drops_total, submessage_arena);
    }
    
  } else {
    
  }
  max_spend_drops_total_ = max_spend_drops_total;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.QueueData.max_spend_drops_total)
}

// repeated .org.xrpl.rpc.v1.QueuedTransaction transactions = 6;
inline int QueueData::transactions_size() const {
  return transactions_.size();
}
inline void QueueData::clear_transactions() {
  transactions_.Clear();
}
inline ::org::xrpl::rpc::v1::QueuedTransaction* QueueData::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.QueueData.transactions)
  return transactions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::QueuedTransaction >*
QueueData::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:org.xrpl.rpc.v1.QueueData.transactions)
  return &transactions_;
}
inline const ::org::xrpl::rpc::v1::QueuedTransaction& QueueData::transactions(int index) const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueueData.transactions)
  return transactions_.Get(index);
}
inline ::org::xrpl::rpc::v1::QueuedTransaction* QueueData::add_transactions() {
  // @@protoc_insertion_point(field_add:org.xrpl.rpc.v1.QueueData.transactions)
  return transactions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::QueuedTransaction >&
QueueData::transactions() const {
  // @@protoc_insertion_point(field_list:org.xrpl.rpc.v1.QueueData.transactions)
  return transactions_;
}

// uint32 lowest_ticket = 7;
inline void QueueData::clear_lowest_ticket() {
  lowest_ticket_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 QueueData::lowest_ticket() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueueData.lowest_ticket)
  return lowest_ticket_;
}
inline void QueueData::set_lowest_ticket(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  lowest_ticket_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.QueueData.lowest_ticket)
}

// uint32 highest_ticket = 8;
inline void QueueData::clear_highest_ticket() {
  highest_ticket_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 QueueData::highest_ticket() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueueData.highest_ticket)
  return highest_ticket_;
}
inline void QueueData::set_highest_ticket(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  highest_ticket_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.QueueData.highest_ticket)
}

// uint32 sequence_count = 9;
inline void QueueData::clear_sequence_count() {
  sequence_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 QueueData::sequence_count() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueueData.sequence_count)
  return sequence_count_;
}
inline void QueueData::set_sequence_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sequence_count_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.QueueData.sequence_count)
}

// uint32 ticket_count = 10;
inline void QueueData::clear_ticket_count() {
  ticket_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 QueueData::ticket_count() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueueData.ticket_count)
  return ticket_count_;
}
inline void QueueData::set_ticket_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  ticket_count_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.QueueData.ticket_count)
}

// -------------------------------------------------------------------

// QueuedTransaction

// bool auth_change = 1;
inline void QueuedTransaction::clear_auth_change() {
  auth_change_ = false;
}
inline bool QueuedTransaction::auth_change() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueuedTransaction.auth_change)
  return auth_change_;
}
inline void QueuedTransaction::set_auth_change(bool value) {
  
  auth_change_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.QueuedTransaction.auth_change)
}

// .org.xrpl.rpc.v1.XRPDropsAmount fee = 2;
inline bool QueuedTransaction::has_fee() const {
  return this != internal_default_instance() && fee_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::XRPDropsAmount& QueuedTransaction::fee() const {
  const ::org::xrpl::rpc::v1::XRPDropsAmount* p = fee_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueuedTransaction.fee)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::XRPDropsAmount*>(
      &::org::xrpl::rpc::v1::_XRPDropsAmount_default_instance_);
}
inline ::org::xrpl::rpc::v1::XRPDropsAmount* QueuedTransaction::release_fee() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.QueuedTransaction.fee)
  
  ::org::xrpl::rpc::v1::XRPDropsAmount* temp = fee_;
  fee_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::XRPDropsAmount* QueuedTransaction::mutable_fee() {
  
  if (fee_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::XRPDropsAmount>(GetArenaNoVirtual());
    fee_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.QueuedTransaction.fee)
  return fee_;
}
inline void QueuedTransaction::set_allocated_fee(::org::xrpl::rpc::v1::XRPDropsAmount* fee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fee_);
  }
  if (fee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fee, submessage_arena);
    }
    
  } else {
    
  }
  fee_ = fee;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.QueuedTransaction.fee)
}

// uint64 fee_level = 3 [jstype = JS_STRING];
inline void QueuedTransaction::clear_fee_level() {
  fee_level_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 QueuedTransaction::fee_level() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueuedTransaction.fee_level)
  return fee_level_;
}
inline void QueuedTransaction::set_fee_level(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fee_level_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.QueuedTransaction.fee_level)
}

// .org.xrpl.rpc.v1.XRPDropsAmount max_spend_drops = 4;
inline bool QueuedTransaction::has_max_spend_drops() const {
  return this != internal_default_instance() && max_spend_drops_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::XRPDropsAmount& QueuedTransaction::max_spend_drops() const {
  const ::org::xrpl::rpc::v1::XRPDropsAmount* p = max_spend_drops_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueuedTransaction.max_spend_drops)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::XRPDropsAmount*>(
      &::org::xrpl::rpc::v1::_XRPDropsAmount_default_instance_);
}
inline ::org::xrpl::rpc::v1::XRPDropsAmount* QueuedTransaction::release_max_spend_drops() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.QueuedTransaction.max_spend_drops)
  
  ::org::xrpl::rpc::v1::XRPDropsAmount* temp = max_spend_drops_;
  max_spend_drops_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::XRPDropsAmount* QueuedTransaction::mutable_max_spend_drops() {
  
  if (max_spend_drops_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::XRPDropsAmount>(GetArenaNoVirtual());
    max_spend_drops_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.QueuedTransaction.max_spend_drops)
  return max_spend_drops_;
}
inline void QueuedTransaction::set_allocated_max_spend_drops(::org::xrpl::rpc::v1::XRPDropsAmount* max_spend_drops) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_spend_drops_);
  }
  if (max_spend_drops) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      max_spend_drops = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max_spend_drops, submessage_arena);
    }
    
  } else {
    
  }
  max_spend_drops_ = max_spend_drops;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.QueuedTransaction.max_spend_drops)
}

// .org.xrpl.rpc.v1.Sequence sequence = 5;
inline bool QueuedTransaction::has_sequence() const {
  return this != internal_default_instance() && sequence_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Sequence& QueuedTransaction::sequence() const {
  const ::org::xrpl::rpc::v1::Sequence* p = sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueuedTransaction.sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Sequence*>(
      &::org::xrpl::rpc::v1::_Sequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::Sequence* QueuedTransaction::release_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.QueuedTransaction.sequence)
  
  ::org::xrpl::rpc::v1::Sequence* temp = sequence_;
  sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Sequence* QueuedTransaction::mutable_sequence() {
  
  if (sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Sequence>(GetArenaNoVirtual());
    sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.QueuedTransaction.sequence)
  return sequence_;
}
inline void QueuedTransaction::set_allocated_sequence(::org::xrpl::rpc::v1::Sequence* sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sequence_);
  }
  if (sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sequence, submessage_arena);
    }
    
  } else {
    
  }
  sequence_ = sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.QueuedTransaction.sequence)
}

// .org.xrpl.rpc.v1.LastLedgerSequence last_ledger_sequence = 6;
inline bool QueuedTransaction::has_last_ledger_sequence() const {
  return this != internal_default_instance() && last_ledger_sequence_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::LastLedgerSequence& QueuedTransaction::last_ledger_sequence() const {
  const ::org::xrpl::rpc::v1::LastLedgerSequence* p = last_ledger_sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueuedTransaction.last_ledger_sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::LastLedgerSequence*>(
      &::org::xrpl::rpc::v1::_LastLedgerSequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::LastLedgerSequence* QueuedTransaction::release_last_ledger_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.QueuedTransaction.last_ledger_sequence)
  
  ::org::xrpl::rpc::v1::LastLedgerSequence* temp = last_ledger_sequence_;
  last_ledger_sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::LastLedgerSequence* QueuedTransaction::mutable_last_ledger_sequence() {
  
  if (last_ledger_sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::LastLedgerSequence>(GetArenaNoVirtual());
    last_ledger_sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.QueuedTransaction.last_ledger_sequence)
  return last_ledger_sequence_;
}
inline void QueuedTransaction::set_allocated_last_ledger_sequence(::org::xrpl::rpc::v1::LastLedgerSequence* last_ledger_sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_ledger_sequence_);
  }
  if (last_ledger_sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      last_ledger_sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_ledger_sequence, submessage_arena);
    }
    
  } else {
    
  }
  last_ledger_sequence_ = last_ledger_sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.QueuedTransaction.last_ledger_sequence)
}

// .org.xrpl.rpc.v1.Ticket ticket = 7;
inline bool QueuedTransaction::has_ticket() const {
  return this != internal_default_instance() && ticket_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Ticket& QueuedTransaction::ticket() const {
  const ::org::xrpl::rpc::v1::Ticket* p = ticket_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QueuedTransaction.ticket)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Ticket*>(
      &::org::xrpl::rpc::v1::_Ticket_default_instance_);
}
inline ::org::xrpl::rpc::v1::Ticket* QueuedTransaction::release_ticket() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.QueuedTransaction.ticket)
  
  ::org::xrpl::rpc::v1::Ticket* temp = ticket_;
  ticket_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Ticket* QueuedTransaction::mutable_ticket() {
  
  if (ticket_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Ticket>(GetArenaNoVirtual());
    ticket_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.QueuedTransaction.ticket)
  return ticket_;
}
inline void QueuedTransaction::set_allocated_ticket(::org::xrpl::rpc::v1::Ticket* ticket) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ticket_);
  }
  if (ticket) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ticket = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ticket, submessage_arena);
    }
    
  } else {
    
  }
  ticket_ = ticket;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.QueuedTransaction.ticket)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace rpc
}  // namespace xrpl
}  // namespace org

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_org_2fxrpl_2frpc_2fv1_2fget_5faccount_5finfo_2eproto
