// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: org/xrpl/rpc/v1/common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "org/xrpl/rpc/v1/amount.pb.h"
#include "org/xrpl/rpc/v1/account.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[87]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
namespace org {
namespace xrpl {
namespace rpc {
namespace v1 {
class Account;
class AccountDefaultTypeInternal;
extern AccountDefaultTypeInternal _Account_default_instance_;
class AccountTransactionID;
class AccountTransactionIDDefaultTypeInternal;
extern AccountTransactionIDDefaultTypeInternal _AccountTransactionID_default_instance_;
class Amount;
class AmountDefaultTypeInternal;
extern AmountDefaultTypeInternal _Amount_default_instance_;
class Authorize;
class AuthorizeDefaultTypeInternal;
extern AuthorizeDefaultTypeInternal _Authorize_default_instance_;
class Balance;
class BalanceDefaultTypeInternal;
extern BalanceDefaultTypeInternal _Balance_default_instance_;
class BaseFee;
class BaseFeeDefaultTypeInternal;
extern BaseFeeDefaultTypeInternal _BaseFee_default_instance_;
class BookDirectory;
class BookDirectoryDefaultTypeInternal;
extern BookDirectoryDefaultTypeInternal _BookDirectory_default_instance_;
class BookNode;
class BookNodeDefaultTypeInternal;
extern BookNodeDefaultTypeInternal _BookNode_default_instance_;
class CancelAfter;
class CancelAfterDefaultTypeInternal;
extern CancelAfterDefaultTypeInternal _CancelAfter_default_instance_;
class Channel;
class ChannelDefaultTypeInternal;
extern ChannelDefaultTypeInternal _Channel_default_instance_;
class CheckID;
class CheckIDDefaultTypeInternal;
extern CheckIDDefaultTypeInternal _CheckID_default_instance_;
class ClearFlag;
class ClearFlagDefaultTypeInternal;
extern ClearFlagDefaultTypeInternal _ClearFlag_default_instance_;
class CloseTime;
class CloseTimeDefaultTypeInternal;
extern CloseTimeDefaultTypeInternal _CloseTime_default_instance_;
class Condition;
class ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class Date;
class DateDefaultTypeInternal;
extern DateDefaultTypeInternal _Date_default_instance_;
class DeliverMin;
class DeliverMinDefaultTypeInternal;
extern DeliverMinDefaultTypeInternal _DeliverMin_default_instance_;
class DeliveredAmount;
class DeliveredAmountDefaultTypeInternal;
extern DeliveredAmountDefaultTypeInternal _DeliveredAmount_default_instance_;
class Destination;
class DestinationDefaultTypeInternal;
extern DestinationDefaultTypeInternal _Destination_default_instance_;
class DestinationNode;
class DestinationNodeDefaultTypeInternal;
extern DestinationNodeDefaultTypeInternal _DestinationNode_default_instance_;
class DestinationTag;
class DestinationTagDefaultTypeInternal;
extern DestinationTagDefaultTypeInternal _DestinationTag_default_instance_;
class DisabledValidator;
class DisabledValidatorDefaultTypeInternal;
extern DisabledValidatorDefaultTypeInternal _DisabledValidator_default_instance_;
class Domain;
class DomainDefaultTypeInternal;
extern DomainDefaultTypeInternal _Domain_default_instance_;
class EmailHash;
class EmailHashDefaultTypeInternal;
extern EmailHashDefaultTypeInternal _EmailHash_default_instance_;
class Expiration;
class ExpirationDefaultTypeInternal;
extern ExpirationDefaultTypeInternal _Expiration_default_instance_;
class FinishAfter;
class FinishAfterDefaultTypeInternal;
extern FinishAfterDefaultTypeInternal _FinishAfter_default_instance_;
class FirstLedgerSequence;
class FirstLedgerSequenceDefaultTypeInternal;
extern FirstLedgerSequenceDefaultTypeInternal _FirstLedgerSequence_default_instance_;
class Flags;
class FlagsDefaultTypeInternal;
extern FlagsDefaultTypeInternal _Flags_default_instance_;
class Fulfillment;
class FulfillmentDefaultTypeInternal;
extern FulfillmentDefaultTypeInternal _Fulfillment_default_instance_;
class Hash;
class HashDefaultTypeInternal;
extern HashDefaultTypeInternal _Hash_default_instance_;
class HighLimit;
class HighLimitDefaultTypeInternal;
extern HighLimitDefaultTypeInternal _HighLimit_default_instance_;
class HighNode;
class HighNodeDefaultTypeInternal;
extern HighNodeDefaultTypeInternal _HighNode_default_instance_;
class HighQualityIn;
class HighQualityInDefaultTypeInternal;
extern HighQualityInDefaultTypeInternal _HighQualityIn_default_instance_;
class HighQualityOut;
class HighQualityOutDefaultTypeInternal;
extern HighQualityOutDefaultTypeInternal _HighQualityOut_default_instance_;
class Index;
class IndexDefaultTypeInternal;
extern IndexDefaultTypeInternal _Index_default_instance_;
class IndexNext;
class IndexNextDefaultTypeInternal;
extern IndexNextDefaultTypeInternal _IndexNext_default_instance_;
class IndexPrevious;
class IndexPreviousDefaultTypeInternal;
extern IndexPreviousDefaultTypeInternal _IndexPrevious_default_instance_;
class InvoiceID;
class InvoiceIDDefaultTypeInternal;
extern InvoiceIDDefaultTypeInternal _InvoiceID_default_instance_;
class LastLedgerSequence;
class LastLedgerSequenceDefaultTypeInternal;
extern LastLedgerSequenceDefaultTypeInternal _LastLedgerSequence_default_instance_;
class LimitAmount;
class LimitAmountDefaultTypeInternal;
extern LimitAmountDefaultTypeInternal _LimitAmount_default_instance_;
class LowLimit;
class LowLimitDefaultTypeInternal;
extern LowLimitDefaultTypeInternal _LowLimit_default_instance_;
class LowNode;
class LowNodeDefaultTypeInternal;
extern LowNodeDefaultTypeInternal _LowNode_default_instance_;
class LowQualityIn;
class LowQualityInDefaultTypeInternal;
extern LowQualityInDefaultTypeInternal _LowQualityIn_default_instance_;
class LowQualityOut;
class LowQualityOutDefaultTypeInternal;
extern LowQualityOutDefaultTypeInternal _LowQualityOut_default_instance_;
class MemoData;
class MemoDataDefaultTypeInternal;
extern MemoDataDefaultTypeInternal _MemoData_default_instance_;
class MemoFormat;
class MemoFormatDefaultTypeInternal;
extern MemoFormatDefaultTypeInternal _MemoFormat_default_instance_;
class MemoType;
class MemoTypeDefaultTypeInternal;
extern MemoTypeDefaultTypeInternal _MemoType_default_instance_;
class MessageKey;
class MessageKeyDefaultTypeInternal;
extern MessageKeyDefaultTypeInternal _MessageKey_default_instance_;
class OfferSequence;
class OfferSequenceDefaultTypeInternal;
extern OfferSequenceDefaultTypeInternal _OfferSequence_default_instance_;
class Owner;
class OwnerDefaultTypeInternal;
extern OwnerDefaultTypeInternal _Owner_default_instance_;
class OwnerCount;
class OwnerCountDefaultTypeInternal;
extern OwnerCountDefaultTypeInternal _OwnerCount_default_instance_;
class OwnerNode;
class OwnerNodeDefaultTypeInternal;
extern OwnerNodeDefaultTypeInternal _OwnerNode_default_instance_;
class PaymentChannelSignature;
class PaymentChannelSignatureDefaultTypeInternal;
extern PaymentChannelSignatureDefaultTypeInternal _PaymentChannelSignature_default_instance_;
class PreviousTransactionID;
class PreviousTransactionIDDefaultTypeInternal;
extern PreviousTransactionIDDefaultTypeInternal _PreviousTransactionID_default_instance_;
class PreviousTransactionLedgerSequence;
class PreviousTransactionLedgerSequenceDefaultTypeInternal;
extern PreviousTransactionLedgerSequenceDefaultTypeInternal _PreviousTransactionLedgerSequence_default_instance_;
class PublicKey;
class PublicKeyDefaultTypeInternal;
extern PublicKeyDefaultTypeInternal _PublicKey_default_instance_;
class QualityIn;
class QualityInDefaultTypeInternal;
extern QualityInDefaultTypeInternal _QualityIn_default_instance_;
class QualityOut;
class QualityOutDefaultTypeInternal;
extern QualityOutDefaultTypeInternal _QualityOut_default_instance_;
class ReferenceFeeUnits;
class ReferenceFeeUnitsDefaultTypeInternal;
extern ReferenceFeeUnitsDefaultTypeInternal _ReferenceFeeUnits_default_instance_;
class RegularKey;
class RegularKeyDefaultTypeInternal;
extern RegularKeyDefaultTypeInternal _RegularKey_default_instance_;
class ReserveBase;
class ReserveBaseDefaultTypeInternal;
extern ReserveBaseDefaultTypeInternal _ReserveBase_default_instance_;
class ReserveIncrement;
class ReserveIncrementDefaultTypeInternal;
extern ReserveIncrementDefaultTypeInternal _ReserveIncrement_default_instance_;
class RootIndex;
class RootIndexDefaultTypeInternal;
extern RootIndexDefaultTypeInternal _RootIndex_default_instance_;
class SendMax;
class SendMaxDefaultTypeInternal;
extern SendMaxDefaultTypeInternal _SendMax_default_instance_;
class Sequence;
class SequenceDefaultTypeInternal;
extern SequenceDefaultTypeInternal _Sequence_default_instance_;
class SetFlag;
class SetFlagDefaultTypeInternal;
extern SetFlagDefaultTypeInternal _SetFlag_default_instance_;
class SettleDelay;
class SettleDelayDefaultTypeInternal;
extern SettleDelayDefaultTypeInternal _SettleDelay_default_instance_;
class SignerEntry;
class SignerEntryDefaultTypeInternal;
extern SignerEntryDefaultTypeInternal _SignerEntry_default_instance_;
class SignerListID;
class SignerListIDDefaultTypeInternal;
extern SignerListIDDefaultTypeInternal _SignerListID_default_instance_;
class SignerQuorum;
class SignerQuorumDefaultTypeInternal;
extern SignerQuorumDefaultTypeInternal _SignerQuorum_default_instance_;
class SignerWeight;
class SignerWeightDefaultTypeInternal;
extern SignerWeightDefaultTypeInternal _SignerWeight_default_instance_;
class SigningPublicKey;
class SigningPublicKeyDefaultTypeInternal;
extern SigningPublicKeyDefaultTypeInternal _SigningPublicKey_default_instance_;
class SourceTag;
class SourceTagDefaultTypeInternal;
extern SourceTagDefaultTypeInternal _SourceTag_default_instance_;
class TakerGets;
class TakerGetsDefaultTypeInternal;
extern TakerGetsDefaultTypeInternal _TakerGets_default_instance_;
class TakerGetsCurreny;
class TakerGetsCurrenyDefaultTypeInternal;
extern TakerGetsCurrenyDefaultTypeInternal _TakerGetsCurreny_default_instance_;
class TakerGetsIssuer;
class TakerGetsIssuerDefaultTypeInternal;
extern TakerGetsIssuerDefaultTypeInternal _TakerGetsIssuer_default_instance_;
class TakerPays;
class TakerPaysDefaultTypeInternal;
extern TakerPaysDefaultTypeInternal _TakerPays_default_instance_;
class TakerPaysCurrency;
class TakerPaysCurrencyDefaultTypeInternal;
extern TakerPaysCurrencyDefaultTypeInternal _TakerPaysCurrency_default_instance_;
class TakerPaysIssuer;
class TakerPaysIssuerDefaultTypeInternal;
extern TakerPaysIssuerDefaultTypeInternal _TakerPaysIssuer_default_instance_;
class TickSize;
class TickSizeDefaultTypeInternal;
extern TickSizeDefaultTypeInternal _TickSize_default_instance_;
class Ticket;
class TicketDefaultTypeInternal;
extern TicketDefaultTypeInternal _Ticket_default_instance_;
class TicketCount;
class TicketCountDefaultTypeInternal;
extern TicketCountDefaultTypeInternal _TicketCount_default_instance_;
class TicketSequence;
class TicketSequenceDefaultTypeInternal;
extern TicketSequenceDefaultTypeInternal _TicketSequence_default_instance_;
class TransactionSignature;
class TransactionSignatureDefaultTypeInternal;
extern TransactionSignatureDefaultTypeInternal _TransactionSignature_default_instance_;
class TransferRate;
class TransferRateDefaultTypeInternal;
extern TransferRateDefaultTypeInternal _TransferRate_default_instance_;
class Unauthorize;
class UnauthorizeDefaultTypeInternal;
extern UnauthorizeDefaultTypeInternal _Unauthorize_default_instance_;
class ValidatorToDisable;
class ValidatorToDisableDefaultTypeInternal;
extern ValidatorToDisableDefaultTypeInternal _ValidatorToDisable_default_instance_;
class ValidatorToReEnable;
class ValidatorToReEnableDefaultTypeInternal;
extern ValidatorToReEnableDefaultTypeInternal _ValidatorToReEnable_default_instance_;
}  // namespace v1
}  // namespace rpc
}  // namespace xrpl
}  // namespace org
PROTOBUF_NAMESPACE_OPEN
template<> ::org::xrpl::rpc::v1::Account* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Account>(Arena*);
template<> ::org::xrpl::rpc::v1::AccountTransactionID* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::AccountTransactionID>(Arena*);
template<> ::org::xrpl::rpc::v1::Amount* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Amount>(Arena*);
template<> ::org::xrpl::rpc::v1::Authorize* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Authorize>(Arena*);
template<> ::org::xrpl::rpc::v1::Balance* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Balance>(Arena*);
template<> ::org::xrpl::rpc::v1::BaseFee* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::BaseFee>(Arena*);
template<> ::org::xrpl::rpc::v1::BookDirectory* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::BookDirectory>(Arena*);
template<> ::org::xrpl::rpc::v1::BookNode* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::BookNode>(Arena*);
template<> ::org::xrpl::rpc::v1::CancelAfter* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::CancelAfter>(Arena*);
template<> ::org::xrpl::rpc::v1::Channel* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Channel>(Arena*);
template<> ::org::xrpl::rpc::v1::CheckID* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::CheckID>(Arena*);
template<> ::org::xrpl::rpc::v1::ClearFlag* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::ClearFlag>(Arena*);
template<> ::org::xrpl::rpc::v1::CloseTime* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::CloseTime>(Arena*);
template<> ::org::xrpl::rpc::v1::Condition* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Condition>(Arena*);
template<> ::org::xrpl::rpc::v1::Date* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Date>(Arena*);
template<> ::org::xrpl::rpc::v1::DeliverMin* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::DeliverMin>(Arena*);
template<> ::org::xrpl::rpc::v1::DeliveredAmount* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::DeliveredAmount>(Arena*);
template<> ::org::xrpl::rpc::v1::Destination* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Destination>(Arena*);
template<> ::org::xrpl::rpc::v1::DestinationNode* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::DestinationNode>(Arena*);
template<> ::org::xrpl::rpc::v1::DestinationTag* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::DestinationTag>(Arena*);
template<> ::org::xrpl::rpc::v1::DisabledValidator* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::DisabledValidator>(Arena*);
template<> ::org::xrpl::rpc::v1::Domain* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Domain>(Arena*);
template<> ::org::xrpl::rpc::v1::EmailHash* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::EmailHash>(Arena*);
template<> ::org::xrpl::rpc::v1::Expiration* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Expiration>(Arena*);
template<> ::org::xrpl::rpc::v1::FinishAfter* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::FinishAfter>(Arena*);
template<> ::org::xrpl::rpc::v1::FirstLedgerSequence* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::FirstLedgerSequence>(Arena*);
template<> ::org::xrpl::rpc::v1::Flags* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Flags>(Arena*);
template<> ::org::xrpl::rpc::v1::Fulfillment* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Fulfillment>(Arena*);
template<> ::org::xrpl::rpc::v1::Hash* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Hash>(Arena*);
template<> ::org::xrpl::rpc::v1::HighLimit* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::HighLimit>(Arena*);
template<> ::org::xrpl::rpc::v1::HighNode* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::HighNode>(Arena*);
template<> ::org::xrpl::rpc::v1::HighQualityIn* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::HighQualityIn>(Arena*);
template<> ::org::xrpl::rpc::v1::HighQualityOut* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::HighQualityOut>(Arena*);
template<> ::org::xrpl::rpc::v1::Index* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Index>(Arena*);
template<> ::org::xrpl::rpc::v1::IndexNext* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::IndexNext>(Arena*);
template<> ::org::xrpl::rpc::v1::IndexPrevious* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::IndexPrevious>(Arena*);
template<> ::org::xrpl::rpc::v1::InvoiceID* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::InvoiceID>(Arena*);
template<> ::org::xrpl::rpc::v1::LastLedgerSequence* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::LastLedgerSequence>(Arena*);
template<> ::org::xrpl::rpc::v1::LimitAmount* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::LimitAmount>(Arena*);
template<> ::org::xrpl::rpc::v1::LowLimit* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::LowLimit>(Arena*);
template<> ::org::xrpl::rpc::v1::LowNode* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::LowNode>(Arena*);
template<> ::org::xrpl::rpc::v1::LowQualityIn* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::LowQualityIn>(Arena*);
template<> ::org::xrpl::rpc::v1::LowQualityOut* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::LowQualityOut>(Arena*);
template<> ::org::xrpl::rpc::v1::MemoData* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::MemoData>(Arena*);
template<> ::org::xrpl::rpc::v1::MemoFormat* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::MemoFormat>(Arena*);
template<> ::org::xrpl::rpc::v1::MemoType* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::MemoType>(Arena*);
template<> ::org::xrpl::rpc::v1::MessageKey* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::MessageKey>(Arena*);
template<> ::org::xrpl::rpc::v1::OfferSequence* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::OfferSequence>(Arena*);
template<> ::org::xrpl::rpc::v1::Owner* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Owner>(Arena*);
template<> ::org::xrpl::rpc::v1::OwnerCount* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::OwnerCount>(Arena*);
template<> ::org::xrpl::rpc::v1::OwnerNode* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::OwnerNode>(Arena*);
template<> ::org::xrpl::rpc::v1::PaymentChannelSignature* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::PaymentChannelSignature>(Arena*);
template<> ::org::xrpl::rpc::v1::PreviousTransactionID* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionID>(Arena*);
template<> ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence>(Arena*);
template<> ::org::xrpl::rpc::v1::PublicKey* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::PublicKey>(Arena*);
template<> ::org::xrpl::rpc::v1::QualityIn* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::QualityIn>(Arena*);
template<> ::org::xrpl::rpc::v1::QualityOut* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::QualityOut>(Arena*);
template<> ::org::xrpl::rpc::v1::ReferenceFeeUnits* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::ReferenceFeeUnits>(Arena*);
template<> ::org::xrpl::rpc::v1::RegularKey* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::RegularKey>(Arena*);
template<> ::org::xrpl::rpc::v1::ReserveBase* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::ReserveBase>(Arena*);
template<> ::org::xrpl::rpc::v1::ReserveIncrement* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::ReserveIncrement>(Arena*);
template<> ::org::xrpl::rpc::v1::RootIndex* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::RootIndex>(Arena*);
template<> ::org::xrpl::rpc::v1::SendMax* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::SendMax>(Arena*);
template<> ::org::xrpl::rpc::v1::Sequence* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Sequence>(Arena*);
template<> ::org::xrpl::rpc::v1::SetFlag* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::SetFlag>(Arena*);
template<> ::org::xrpl::rpc::v1::SettleDelay* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::SettleDelay>(Arena*);
template<> ::org::xrpl::rpc::v1::SignerEntry* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::SignerEntry>(Arena*);
template<> ::org::xrpl::rpc::v1::SignerListID* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::SignerListID>(Arena*);
template<> ::org::xrpl::rpc::v1::SignerQuorum* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::SignerQuorum>(Arena*);
template<> ::org::xrpl::rpc::v1::SignerWeight* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::SignerWeight>(Arena*);
template<> ::org::xrpl::rpc::v1::SigningPublicKey* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::SigningPublicKey>(Arena*);
template<> ::org::xrpl::rpc::v1::SourceTag* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::SourceTag>(Arena*);
template<> ::org::xrpl::rpc::v1::TakerGets* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::TakerGets>(Arena*);
template<> ::org::xrpl::rpc::v1::TakerGetsCurreny* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::TakerGetsCurreny>(Arena*);
template<> ::org::xrpl::rpc::v1::TakerGetsIssuer* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::TakerGetsIssuer>(Arena*);
template<> ::org::xrpl::rpc::v1::TakerPays* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::TakerPays>(Arena*);
template<> ::org::xrpl::rpc::v1::TakerPaysCurrency* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::TakerPaysCurrency>(Arena*);
template<> ::org::xrpl::rpc::v1::TakerPaysIssuer* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::TakerPaysIssuer>(Arena*);
template<> ::org::xrpl::rpc::v1::TickSize* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::TickSize>(Arena*);
template<> ::org::xrpl::rpc::v1::Ticket* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Ticket>(Arena*);
template<> ::org::xrpl::rpc::v1::TicketCount* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::TicketCount>(Arena*);
template<> ::org::xrpl::rpc::v1::TicketSequence* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::TicketSequence>(Arena*);
template<> ::org::xrpl::rpc::v1::TransactionSignature* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::TransactionSignature>(Arena*);
template<> ::org::xrpl::rpc::v1::TransferRate* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::TransferRate>(Arena*);
template<> ::org::xrpl::rpc::v1::Unauthorize* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Unauthorize>(Arena*);
template<> ::org::xrpl::rpc::v1::ValidatorToDisable* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::ValidatorToDisable>(Arena*);
template<> ::org::xrpl::rpc::v1::ValidatorToReEnable* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::ValidatorToReEnable>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace org {
namespace xrpl {
namespace rpc {
namespace v1 {

// ===================================================================

class CancelAfter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.CancelAfter) */ {
 public:
  CancelAfter();
  virtual ~CancelAfter();

  CancelAfter(const CancelAfter& from);
  CancelAfter(CancelAfter&& from) noexcept
    : CancelAfter() {
    *this = ::std::move(from);
  }

  inline CancelAfter& operator=(const CancelAfter& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelAfter& operator=(CancelAfter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CancelAfter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CancelAfter* internal_default_instance() {
    return reinterpret_cast<const CancelAfter*>(
               &_CancelAfter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CancelAfter* other);
  friend void swap(CancelAfter& a, CancelAfter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CancelAfter* New() const final {
    return CreateMaybeMessage<CancelAfter>(nullptr);
  }

  CancelAfter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelAfter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CancelAfter& from);
  void MergeFrom(const CancelAfter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelAfter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.CancelAfter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.CancelAfter)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ClearFlag :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.ClearFlag) */ {
 public:
  ClearFlag();
  virtual ~ClearFlag();

  ClearFlag(const ClearFlag& from);
  ClearFlag(ClearFlag&& from) noexcept
    : ClearFlag() {
    *this = ::std::move(from);
  }

  inline ClearFlag& operator=(const ClearFlag& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearFlag& operator=(ClearFlag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClearFlag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClearFlag* internal_default_instance() {
    return reinterpret_cast<const ClearFlag*>(
               &_ClearFlag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ClearFlag* other);
  friend void swap(ClearFlag& a, ClearFlag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClearFlag* New() const final {
    return CreateMaybeMessage<ClearFlag>(nullptr);
  }

  ClearFlag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClearFlag>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClearFlag& from);
  void MergeFrom(const ClearFlag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearFlag* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.ClearFlag";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.ClearFlag)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class CloseTime :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.CloseTime) */ {
 public:
  CloseTime();
  virtual ~CloseTime();

  CloseTime(const CloseTime& from);
  CloseTime(CloseTime&& from) noexcept
    : CloseTime() {
    *this = ::std::move(from);
  }

  inline CloseTime& operator=(const CloseTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseTime& operator=(CloseTime&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CloseTime& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloseTime* internal_default_instance() {
    return reinterpret_cast<const CloseTime*>(
               &_CloseTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CloseTime* other);
  friend void swap(CloseTime& a, CloseTime& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseTime* New() const final {
    return CreateMaybeMessage<CloseTime>(nullptr);
  }

  CloseTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CloseTime>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CloseTime& from);
  void MergeFrom(const CloseTime& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseTime* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.CloseTime";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.CloseTime)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Date :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Date) */ {
 public:
  Date();
  virtual ~Date();

  Date(const Date& from);
  Date(Date&& from) noexcept
    : Date() {
    *this = ::std::move(from);
  }

  inline Date& operator=(const Date& from) {
    CopyFrom(from);
    return *this;
  }
  inline Date& operator=(Date&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Date& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Date* internal_default_instance() {
    return reinterpret_cast<const Date*>(
               &_Date_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Date* other);
  friend void swap(Date& a, Date& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Date* New() const final {
    return CreateMaybeMessage<Date>(nullptr);
  }

  Date* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Date>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Date& from);
  void MergeFrom(const Date& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Date* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Date";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Date)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class DestinationTag :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.DestinationTag) */ {
 public:
  DestinationTag();
  virtual ~DestinationTag();

  DestinationTag(const DestinationTag& from);
  DestinationTag(DestinationTag&& from) noexcept
    : DestinationTag() {
    *this = ::std::move(from);
  }

  inline DestinationTag& operator=(const DestinationTag& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestinationTag& operator=(DestinationTag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DestinationTag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DestinationTag* internal_default_instance() {
    return reinterpret_cast<const DestinationTag*>(
               &_DestinationTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(DestinationTag* other);
  friend void swap(DestinationTag& a, DestinationTag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DestinationTag* New() const final {
    return CreateMaybeMessage<DestinationTag>(nullptr);
  }

  DestinationTag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DestinationTag>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DestinationTag& from);
  void MergeFrom(const DestinationTag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DestinationTag* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.DestinationTag";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.DestinationTag)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Expiration :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Expiration) */ {
 public:
  Expiration();
  virtual ~Expiration();

  Expiration(const Expiration& from);
  Expiration(Expiration&& from) noexcept
    : Expiration() {
    *this = ::std::move(from);
  }

  inline Expiration& operator=(const Expiration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expiration& operator=(Expiration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Expiration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expiration* internal_default_instance() {
    return reinterpret_cast<const Expiration*>(
               &_Expiration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Expiration* other);
  friend void swap(Expiration& a, Expiration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expiration* New() const final {
    return CreateMaybeMessage<Expiration>(nullptr);
  }

  Expiration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Expiration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Expiration& from);
  void MergeFrom(const Expiration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expiration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Expiration";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Expiration)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class FinishAfter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.FinishAfter) */ {
 public:
  FinishAfter();
  virtual ~FinishAfter();

  FinishAfter(const FinishAfter& from);
  FinishAfter(FinishAfter&& from) noexcept
    : FinishAfter() {
    *this = ::std::move(from);
  }

  inline FinishAfter& operator=(const FinishAfter& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinishAfter& operator=(FinishAfter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FinishAfter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FinishAfter* internal_default_instance() {
    return reinterpret_cast<const FinishAfter*>(
               &_FinishAfter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(FinishAfter* other);
  friend void swap(FinishAfter& a, FinishAfter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FinishAfter* New() const final {
    return CreateMaybeMessage<FinishAfter>(nullptr);
  }

  FinishAfter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FinishAfter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FinishAfter& from);
  void MergeFrom(const FinishAfter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinishAfter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.FinishAfter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.FinishAfter)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Flags :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Flags) */ {
 public:
  Flags();
  virtual ~Flags();

  Flags(const Flags& from);
  Flags(Flags&& from) noexcept
    : Flags() {
    *this = ::std::move(from);
  }

  inline Flags& operator=(const Flags& from) {
    CopyFrom(from);
    return *this;
  }
  inline Flags& operator=(Flags&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Flags& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Flags* internal_default_instance() {
    return reinterpret_cast<const Flags*>(
               &_Flags_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Flags* other);
  friend void swap(Flags& a, Flags& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Flags* New() const final {
    return CreateMaybeMessage<Flags>(nullptr);
  }

  Flags* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Flags>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Flags& from);
  void MergeFrom(const Flags& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Flags* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Flags";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Flags)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class HighQualityIn :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.HighQualityIn) */ {
 public:
  HighQualityIn();
  virtual ~HighQualityIn();

  HighQualityIn(const HighQualityIn& from);
  HighQualityIn(HighQualityIn&& from) noexcept
    : HighQualityIn() {
    *this = ::std::move(from);
  }

  inline HighQualityIn& operator=(const HighQualityIn& from) {
    CopyFrom(from);
    return *this;
  }
  inline HighQualityIn& operator=(HighQualityIn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HighQualityIn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HighQualityIn* internal_default_instance() {
    return reinterpret_cast<const HighQualityIn*>(
               &_HighQualityIn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(HighQualityIn* other);
  friend void swap(HighQualityIn& a, HighQualityIn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HighQualityIn* New() const final {
    return CreateMaybeMessage<HighQualityIn>(nullptr);
  }

  HighQualityIn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HighQualityIn>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HighQualityIn& from);
  void MergeFrom(const HighQualityIn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HighQualityIn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.HighQualityIn";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.HighQualityIn)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class HighQualityOut :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.HighQualityOut) */ {
 public:
  HighQualityOut();
  virtual ~HighQualityOut();

  HighQualityOut(const HighQualityOut& from);
  HighQualityOut(HighQualityOut&& from) noexcept
    : HighQualityOut() {
    *this = ::std::move(from);
  }

  inline HighQualityOut& operator=(const HighQualityOut& from) {
    CopyFrom(from);
    return *this;
  }
  inline HighQualityOut& operator=(HighQualityOut&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HighQualityOut& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HighQualityOut* internal_default_instance() {
    return reinterpret_cast<const HighQualityOut*>(
               &_HighQualityOut_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(HighQualityOut* other);
  friend void swap(HighQualityOut& a, HighQualityOut& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HighQualityOut* New() const final {
    return CreateMaybeMessage<HighQualityOut>(nullptr);
  }

  HighQualityOut* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HighQualityOut>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HighQualityOut& from);
  void MergeFrom(const HighQualityOut& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HighQualityOut* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.HighQualityOut";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.HighQualityOut)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class FirstLedgerSequence :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.FirstLedgerSequence) */ {
 public:
  FirstLedgerSequence();
  virtual ~FirstLedgerSequence();

  FirstLedgerSequence(const FirstLedgerSequence& from);
  FirstLedgerSequence(FirstLedgerSequence&& from) noexcept
    : FirstLedgerSequence() {
    *this = ::std::move(from);
  }

  inline FirstLedgerSequence& operator=(const FirstLedgerSequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirstLedgerSequence& operator=(FirstLedgerSequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FirstLedgerSequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FirstLedgerSequence* internal_default_instance() {
    return reinterpret_cast<const FirstLedgerSequence*>(
               &_FirstLedgerSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(FirstLedgerSequence* other);
  friend void swap(FirstLedgerSequence& a, FirstLedgerSequence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FirstLedgerSequence* New() const final {
    return CreateMaybeMessage<FirstLedgerSequence>(nullptr);
  }

  FirstLedgerSequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirstLedgerSequence>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FirstLedgerSequence& from);
  void MergeFrom(const FirstLedgerSequence& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirstLedgerSequence* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.FirstLedgerSequence";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.FirstLedgerSequence)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class LastLedgerSequence :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.LastLedgerSequence) */ {
 public:
  LastLedgerSequence();
  virtual ~LastLedgerSequence();

  LastLedgerSequence(const LastLedgerSequence& from);
  LastLedgerSequence(LastLedgerSequence&& from) noexcept
    : LastLedgerSequence() {
    *this = ::std::move(from);
  }

  inline LastLedgerSequence& operator=(const LastLedgerSequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline LastLedgerSequence& operator=(LastLedgerSequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LastLedgerSequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LastLedgerSequence* internal_default_instance() {
    return reinterpret_cast<const LastLedgerSequence*>(
               &_LastLedgerSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(LastLedgerSequence* other);
  friend void swap(LastLedgerSequence& a, LastLedgerSequence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LastLedgerSequence* New() const final {
    return CreateMaybeMessage<LastLedgerSequence>(nullptr);
  }

  LastLedgerSequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LastLedgerSequence>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LastLedgerSequence& from);
  void MergeFrom(const LastLedgerSequence& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LastLedgerSequence* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.LastLedgerSequence";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.LastLedgerSequence)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class LowQualityIn :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.LowQualityIn) */ {
 public:
  LowQualityIn();
  virtual ~LowQualityIn();

  LowQualityIn(const LowQualityIn& from);
  LowQualityIn(LowQualityIn&& from) noexcept
    : LowQualityIn() {
    *this = ::std::move(from);
  }

  inline LowQualityIn& operator=(const LowQualityIn& from) {
    CopyFrom(from);
    return *this;
  }
  inline LowQualityIn& operator=(LowQualityIn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LowQualityIn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LowQualityIn* internal_default_instance() {
    return reinterpret_cast<const LowQualityIn*>(
               &_LowQualityIn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(LowQualityIn* other);
  friend void swap(LowQualityIn& a, LowQualityIn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LowQualityIn* New() const final {
    return CreateMaybeMessage<LowQualityIn>(nullptr);
  }

  LowQualityIn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LowQualityIn>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LowQualityIn& from);
  void MergeFrom(const LowQualityIn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LowQualityIn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.LowQualityIn";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.LowQualityIn)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class LowQualityOut :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.LowQualityOut) */ {
 public:
  LowQualityOut();
  virtual ~LowQualityOut();

  LowQualityOut(const LowQualityOut& from);
  LowQualityOut(LowQualityOut&& from) noexcept
    : LowQualityOut() {
    *this = ::std::move(from);
  }

  inline LowQualityOut& operator=(const LowQualityOut& from) {
    CopyFrom(from);
    return *this;
  }
  inline LowQualityOut& operator=(LowQualityOut&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LowQualityOut& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LowQualityOut* internal_default_instance() {
    return reinterpret_cast<const LowQualityOut*>(
               &_LowQualityOut_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(LowQualityOut* other);
  friend void swap(LowQualityOut& a, LowQualityOut& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LowQualityOut* New() const final {
    return CreateMaybeMessage<LowQualityOut>(nullptr);
  }

  LowQualityOut* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LowQualityOut>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LowQualityOut& from);
  void MergeFrom(const LowQualityOut& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LowQualityOut* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.LowQualityOut";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.LowQualityOut)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class OfferSequence :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.OfferSequence) */ {
 public:
  OfferSequence();
  virtual ~OfferSequence();

  OfferSequence(const OfferSequence& from);
  OfferSequence(OfferSequence&& from) noexcept
    : OfferSequence() {
    *this = ::std::move(from);
  }

  inline OfferSequence& operator=(const OfferSequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline OfferSequence& operator=(OfferSequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OfferSequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OfferSequence* internal_default_instance() {
    return reinterpret_cast<const OfferSequence*>(
               &_OfferSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(OfferSequence* other);
  friend void swap(OfferSequence& a, OfferSequence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OfferSequence* New() const final {
    return CreateMaybeMessage<OfferSequence>(nullptr);
  }

  OfferSequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OfferSequence>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OfferSequence& from);
  void MergeFrom(const OfferSequence& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OfferSequence* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.OfferSequence";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.OfferSequence)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class OwnerCount :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.OwnerCount) */ {
 public:
  OwnerCount();
  virtual ~OwnerCount();

  OwnerCount(const OwnerCount& from);
  OwnerCount(OwnerCount&& from) noexcept
    : OwnerCount() {
    *this = ::std::move(from);
  }

  inline OwnerCount& operator=(const OwnerCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnerCount& operator=(OwnerCount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OwnerCount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OwnerCount* internal_default_instance() {
    return reinterpret_cast<const OwnerCount*>(
               &_OwnerCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(OwnerCount* other);
  friend void swap(OwnerCount& a, OwnerCount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OwnerCount* New() const final {
    return CreateMaybeMessage<OwnerCount>(nullptr);
  }

  OwnerCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OwnerCount>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OwnerCount& from);
  void MergeFrom(const OwnerCount& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnerCount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.OwnerCount";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.OwnerCount)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class PreviousTransactionLedgerSequence :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.PreviousTransactionLedgerSequence) */ {
 public:
  PreviousTransactionLedgerSequence();
  virtual ~PreviousTransactionLedgerSequence();

  PreviousTransactionLedgerSequence(const PreviousTransactionLedgerSequence& from);
  PreviousTransactionLedgerSequence(PreviousTransactionLedgerSequence&& from) noexcept
    : PreviousTransactionLedgerSequence() {
    *this = ::std::move(from);
  }

  inline PreviousTransactionLedgerSequence& operator=(const PreviousTransactionLedgerSequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline PreviousTransactionLedgerSequence& operator=(PreviousTransactionLedgerSequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PreviousTransactionLedgerSequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PreviousTransactionLedgerSequence* internal_default_instance() {
    return reinterpret_cast<const PreviousTransactionLedgerSequence*>(
               &_PreviousTransactionLedgerSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(PreviousTransactionLedgerSequence* other);
  friend void swap(PreviousTransactionLedgerSequence& a, PreviousTransactionLedgerSequence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PreviousTransactionLedgerSequence* New() const final {
    return CreateMaybeMessage<PreviousTransactionLedgerSequence>(nullptr);
  }

  PreviousTransactionLedgerSequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PreviousTransactionLedgerSequence>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PreviousTransactionLedgerSequence& from);
  void MergeFrom(const PreviousTransactionLedgerSequence& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PreviousTransactionLedgerSequence* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.PreviousTransactionLedgerSequence";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.PreviousTransactionLedgerSequence)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class QualityIn :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.QualityIn) */ {
 public:
  QualityIn();
  virtual ~QualityIn();

  QualityIn(const QualityIn& from);
  QualityIn(QualityIn&& from) noexcept
    : QualityIn() {
    *this = ::std::move(from);
  }

  inline QualityIn& operator=(const QualityIn& from) {
    CopyFrom(from);
    return *this;
  }
  inline QualityIn& operator=(QualityIn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QualityIn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QualityIn* internal_default_instance() {
    return reinterpret_cast<const QualityIn*>(
               &_QualityIn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(QualityIn* other);
  friend void swap(QualityIn& a, QualityIn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QualityIn* New() const final {
    return CreateMaybeMessage<QualityIn>(nullptr);
  }

  QualityIn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QualityIn>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QualityIn& from);
  void MergeFrom(const QualityIn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QualityIn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.QualityIn";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.QualityIn)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class QualityOut :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.QualityOut) */ {
 public:
  QualityOut();
  virtual ~QualityOut();

  QualityOut(const QualityOut& from);
  QualityOut(QualityOut&& from) noexcept
    : QualityOut() {
    *this = ::std::move(from);
  }

  inline QualityOut& operator=(const QualityOut& from) {
    CopyFrom(from);
    return *this;
  }
  inline QualityOut& operator=(QualityOut&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QualityOut& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QualityOut* internal_default_instance() {
    return reinterpret_cast<const QualityOut*>(
               &_QualityOut_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(QualityOut* other);
  friend void swap(QualityOut& a, QualityOut& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QualityOut* New() const final {
    return CreateMaybeMessage<QualityOut>(nullptr);
  }

  QualityOut* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QualityOut>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QualityOut& from);
  void MergeFrom(const QualityOut& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QualityOut* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.QualityOut";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.QualityOut)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ReferenceFeeUnits :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.ReferenceFeeUnits) */ {
 public:
  ReferenceFeeUnits();
  virtual ~ReferenceFeeUnits();

  ReferenceFeeUnits(const ReferenceFeeUnits& from);
  ReferenceFeeUnits(ReferenceFeeUnits&& from) noexcept
    : ReferenceFeeUnits() {
    *this = ::std::move(from);
  }

  inline ReferenceFeeUnits& operator=(const ReferenceFeeUnits& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceFeeUnits& operator=(ReferenceFeeUnits&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReferenceFeeUnits& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReferenceFeeUnits* internal_default_instance() {
    return reinterpret_cast<const ReferenceFeeUnits*>(
               &_ReferenceFeeUnits_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ReferenceFeeUnits* other);
  friend void swap(ReferenceFeeUnits& a, ReferenceFeeUnits& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReferenceFeeUnits* New() const final {
    return CreateMaybeMessage<ReferenceFeeUnits>(nullptr);
  }

  ReferenceFeeUnits* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReferenceFeeUnits>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReferenceFeeUnits& from);
  void MergeFrom(const ReferenceFeeUnits& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceFeeUnits* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.ReferenceFeeUnits";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.ReferenceFeeUnits)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ReserveBase :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.ReserveBase) */ {
 public:
  ReserveBase();
  virtual ~ReserveBase();

  ReserveBase(const ReserveBase& from);
  ReserveBase(ReserveBase&& from) noexcept
    : ReserveBase() {
    *this = ::std::move(from);
  }

  inline ReserveBase& operator=(const ReserveBase& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReserveBase& operator=(ReserveBase&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReserveBase& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReserveBase* internal_default_instance() {
    return reinterpret_cast<const ReserveBase*>(
               &_ReserveBase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(ReserveBase* other);
  friend void swap(ReserveBase& a, ReserveBase& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReserveBase* New() const final {
    return CreateMaybeMessage<ReserveBase>(nullptr);
  }

  ReserveBase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReserveBase>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReserveBase& from);
  void MergeFrom(const ReserveBase& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReserveBase* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.ReserveBase";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.ReserveBase)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ReserveIncrement :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.ReserveIncrement) */ {
 public:
  ReserveIncrement();
  virtual ~ReserveIncrement();

  ReserveIncrement(const ReserveIncrement& from);
  ReserveIncrement(ReserveIncrement&& from) noexcept
    : ReserveIncrement() {
    *this = ::std::move(from);
  }

  inline ReserveIncrement& operator=(const ReserveIncrement& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReserveIncrement& operator=(ReserveIncrement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReserveIncrement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReserveIncrement* internal_default_instance() {
    return reinterpret_cast<const ReserveIncrement*>(
               &_ReserveIncrement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ReserveIncrement* other);
  friend void swap(ReserveIncrement& a, ReserveIncrement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReserveIncrement* New() const final {
    return CreateMaybeMessage<ReserveIncrement>(nullptr);
  }

  ReserveIncrement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReserveIncrement>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReserveIncrement& from);
  void MergeFrom(const ReserveIncrement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReserveIncrement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.ReserveIncrement";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.ReserveIncrement)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Sequence :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Sequence) */ {
 public:
  Sequence();
  virtual ~Sequence();

  Sequence(const Sequence& from);
  Sequence(Sequence&& from) noexcept
    : Sequence() {
    *this = ::std::move(from);
  }

  inline Sequence& operator=(const Sequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sequence& operator=(Sequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Sequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sequence* internal_default_instance() {
    return reinterpret_cast<const Sequence*>(
               &_Sequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(Sequence* other);
  friend void swap(Sequence& a, Sequence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sequence* New() const final {
    return CreateMaybeMessage<Sequence>(nullptr);
  }

  Sequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Sequence>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Sequence& from);
  void MergeFrom(const Sequence& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sequence* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Sequence";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Sequence)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SetFlag :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.SetFlag) */ {
 public:
  SetFlag();
  virtual ~SetFlag();

  SetFlag(const SetFlag& from);
  SetFlag(SetFlag&& from) noexcept
    : SetFlag() {
    *this = ::std::move(from);
  }

  inline SetFlag& operator=(const SetFlag& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFlag& operator=(SetFlag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetFlag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetFlag* internal_default_instance() {
    return reinterpret_cast<const SetFlag*>(
               &_SetFlag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(SetFlag* other);
  friend void swap(SetFlag& a, SetFlag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetFlag* New() const final {
    return CreateMaybeMessage<SetFlag>(nullptr);
  }

  SetFlag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetFlag>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetFlag& from);
  void MergeFrom(const SetFlag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetFlag* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.SetFlag";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.SetFlag)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SettleDelay :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.SettleDelay) */ {
 public:
  SettleDelay();
  virtual ~SettleDelay();

  SettleDelay(const SettleDelay& from);
  SettleDelay(SettleDelay&& from) noexcept
    : SettleDelay() {
    *this = ::std::move(from);
  }

  inline SettleDelay& operator=(const SettleDelay& from) {
    CopyFrom(from);
    return *this;
  }
  inline SettleDelay& operator=(SettleDelay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SettleDelay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SettleDelay* internal_default_instance() {
    return reinterpret_cast<const SettleDelay*>(
               &_SettleDelay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(SettleDelay* other);
  friend void swap(SettleDelay& a, SettleDelay& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SettleDelay* New() const final {
    return CreateMaybeMessage<SettleDelay>(nullptr);
  }

  SettleDelay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SettleDelay>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SettleDelay& from);
  void MergeFrom(const SettleDelay& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SettleDelay* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.SettleDelay";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.SettleDelay)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SignerListID :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.SignerListID) */ {
 public:
  SignerListID();
  virtual ~SignerListID();

  SignerListID(const SignerListID& from);
  SignerListID(SignerListID&& from) noexcept
    : SignerListID() {
    *this = ::std::move(from);
  }

  inline SignerListID& operator=(const SignerListID& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignerListID& operator=(SignerListID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignerListID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignerListID* internal_default_instance() {
    return reinterpret_cast<const SignerListID*>(
               &_SignerListID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(SignerListID* other);
  friend void swap(SignerListID& a, SignerListID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignerListID* New() const final {
    return CreateMaybeMessage<SignerListID>(nullptr);
  }

  SignerListID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignerListID>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignerListID& from);
  void MergeFrom(const SignerListID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignerListID* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.SignerListID";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.SignerListID)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SignerQuorum :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.SignerQuorum) */ {
 public:
  SignerQuorum();
  virtual ~SignerQuorum();

  SignerQuorum(const SignerQuorum& from);
  SignerQuorum(SignerQuorum&& from) noexcept
    : SignerQuorum() {
    *this = ::std::move(from);
  }

  inline SignerQuorum& operator=(const SignerQuorum& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignerQuorum& operator=(SignerQuorum&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignerQuorum& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignerQuorum* internal_default_instance() {
    return reinterpret_cast<const SignerQuorum*>(
               &_SignerQuorum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(SignerQuorum* other);
  friend void swap(SignerQuorum& a, SignerQuorum& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignerQuorum* New() const final {
    return CreateMaybeMessage<SignerQuorum>(nullptr);
  }

  SignerQuorum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignerQuorum>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignerQuorum& from);
  void MergeFrom(const SignerQuorum& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignerQuorum* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.SignerQuorum";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.SignerQuorum)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SignerWeight :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.SignerWeight) */ {
 public:
  SignerWeight();
  virtual ~SignerWeight();

  SignerWeight(const SignerWeight& from);
  SignerWeight(SignerWeight&& from) noexcept
    : SignerWeight() {
    *this = ::std::move(from);
  }

  inline SignerWeight& operator=(const SignerWeight& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignerWeight& operator=(SignerWeight&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignerWeight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignerWeight* internal_default_instance() {
    return reinterpret_cast<const SignerWeight*>(
               &_SignerWeight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(SignerWeight* other);
  friend void swap(SignerWeight& a, SignerWeight& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignerWeight* New() const final {
    return CreateMaybeMessage<SignerWeight>(nullptr);
  }

  SignerWeight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignerWeight>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignerWeight& from);
  void MergeFrom(const SignerWeight& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignerWeight* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.SignerWeight";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.SignerWeight)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SourceTag :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.SourceTag) */ {
 public:
  SourceTag();
  virtual ~SourceTag();

  SourceTag(const SourceTag& from);
  SourceTag(SourceTag&& from) noexcept
    : SourceTag() {
    *this = ::std::move(from);
  }

  inline SourceTag& operator=(const SourceTag& from) {
    CopyFrom(from);
    return *this;
  }
  inline SourceTag& operator=(SourceTag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SourceTag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SourceTag* internal_default_instance() {
    return reinterpret_cast<const SourceTag*>(
               &_SourceTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(SourceTag* other);
  friend void swap(SourceTag& a, SourceTag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SourceTag* New() const final {
    return CreateMaybeMessage<SourceTag>(nullptr);
  }

  SourceTag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SourceTag>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SourceTag& from);
  void MergeFrom(const SourceTag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SourceTag* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.SourceTag";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.SourceTag)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TickSize :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.TickSize) */ {
 public:
  TickSize();
  virtual ~TickSize();

  TickSize(const TickSize& from);
  TickSize(TickSize&& from) noexcept
    : TickSize() {
    *this = ::std::move(from);
  }

  inline TickSize& operator=(const TickSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline TickSize& operator=(TickSize&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TickSize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TickSize* internal_default_instance() {
    return reinterpret_cast<const TickSize*>(
               &_TickSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(TickSize* other);
  friend void swap(TickSize& a, TickSize& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TickSize* New() const final {
    return CreateMaybeMessage<TickSize>(nullptr);
  }

  TickSize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TickSize>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TickSize& from);
  void MergeFrom(const TickSize& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TickSize* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.TickSize";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.TickSize)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Ticket :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Ticket) */ {
 public:
  Ticket();
  virtual ~Ticket();

  Ticket(const Ticket& from);
  Ticket(Ticket&& from) noexcept
    : Ticket() {
    *this = ::std::move(from);
  }

  inline Ticket& operator=(const Ticket& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ticket& operator=(Ticket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Ticket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ticket* internal_default_instance() {
    return reinterpret_cast<const Ticket*>(
               &_Ticket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(Ticket* other);
  friend void swap(Ticket& a, Ticket& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ticket* New() const final {
    return CreateMaybeMessage<Ticket>(nullptr);
  }

  Ticket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ticket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Ticket& from);
  void MergeFrom(const Ticket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ticket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Ticket";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Ticket)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TicketCount :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.TicketCount) */ {
 public:
  TicketCount();
  virtual ~TicketCount();

  TicketCount(const TicketCount& from);
  TicketCount(TicketCount&& from) noexcept
    : TicketCount() {
    *this = ::std::move(from);
  }

  inline TicketCount& operator=(const TicketCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline TicketCount& operator=(TicketCount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TicketCount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TicketCount* internal_default_instance() {
    return reinterpret_cast<const TicketCount*>(
               &_TicketCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(TicketCount* other);
  friend void swap(TicketCount& a, TicketCount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TicketCount* New() const final {
    return CreateMaybeMessage<TicketCount>(nullptr);
  }

  TicketCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TicketCount>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TicketCount& from);
  void MergeFrom(const TicketCount& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TicketCount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.TicketCount";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.TicketCount)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TicketSequence :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.TicketSequence) */ {
 public:
  TicketSequence();
  virtual ~TicketSequence();

  TicketSequence(const TicketSequence& from);
  TicketSequence(TicketSequence&& from) noexcept
    : TicketSequence() {
    *this = ::std::move(from);
  }

  inline TicketSequence& operator=(const TicketSequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline TicketSequence& operator=(TicketSequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TicketSequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TicketSequence* internal_default_instance() {
    return reinterpret_cast<const TicketSequence*>(
               &_TicketSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(TicketSequence* other);
  friend void swap(TicketSequence& a, TicketSequence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TicketSequence* New() const final {
    return CreateMaybeMessage<TicketSequence>(nullptr);
  }

  TicketSequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TicketSequence>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TicketSequence& from);
  void MergeFrom(const TicketSequence& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TicketSequence* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.TicketSequence";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.TicketSequence)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TransferRate :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.TransferRate) */ {
 public:
  TransferRate();
  virtual ~TransferRate();

  TransferRate(const TransferRate& from);
  TransferRate(TransferRate&& from) noexcept
    : TransferRate() {
    *this = ::std::move(from);
  }

  inline TransferRate& operator=(const TransferRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferRate& operator=(TransferRate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransferRate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferRate* internal_default_instance() {
    return reinterpret_cast<const TransferRate*>(
               &_TransferRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(TransferRate* other);
  friend void swap(TransferRate& a, TransferRate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferRate* New() const final {
    return CreateMaybeMessage<TransferRate>(nullptr);
  }

  TransferRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferRate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransferRate& from);
  void MergeFrom(const TransferRate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferRate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.TransferRate";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.TransferRate)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class BaseFee :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.BaseFee) */ {
 public:
  BaseFee();
  virtual ~BaseFee();

  BaseFee(const BaseFee& from);
  BaseFee(BaseFee&& from) noexcept
    : BaseFee() {
    *this = ::std::move(from);
  }

  inline BaseFee& operator=(const BaseFee& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseFee& operator=(BaseFee&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BaseFee& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BaseFee* internal_default_instance() {
    return reinterpret_cast<const BaseFee*>(
               &_BaseFee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(BaseFee* other);
  friend void swap(BaseFee& a, BaseFee& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BaseFee* New() const final {
    return CreateMaybeMessage<BaseFee>(nullptr);
  }

  BaseFee* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BaseFee>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BaseFee& from);
  void MergeFrom(const BaseFee& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseFee* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.BaseFee";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 value = 1 [jstype = JS_STRING];
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.BaseFee)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class BookNode :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.BookNode) */ {
 public:
  BookNode();
  virtual ~BookNode();

  BookNode(const BookNode& from);
  BookNode(BookNode&& from) noexcept
    : BookNode() {
    *this = ::std::move(from);
  }

  inline BookNode& operator=(const BookNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline BookNode& operator=(BookNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BookNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BookNode* internal_default_instance() {
    return reinterpret_cast<const BookNode*>(
               &_BookNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(BookNode* other);
  friend void swap(BookNode& a, BookNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BookNode* New() const final {
    return CreateMaybeMessage<BookNode>(nullptr);
  }

  BookNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BookNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BookNode& from);
  void MergeFrom(const BookNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BookNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.BookNode";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 value = 1 [jstype = JS_STRING];
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.BookNode)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class DestinationNode :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.DestinationNode) */ {
 public:
  DestinationNode();
  virtual ~DestinationNode();

  DestinationNode(const DestinationNode& from);
  DestinationNode(DestinationNode&& from) noexcept
    : DestinationNode() {
    *this = ::std::move(from);
  }

  inline DestinationNode& operator=(const DestinationNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestinationNode& operator=(DestinationNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DestinationNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DestinationNode* internal_default_instance() {
    return reinterpret_cast<const DestinationNode*>(
               &_DestinationNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(DestinationNode* other);
  friend void swap(DestinationNode& a, DestinationNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DestinationNode* New() const final {
    return CreateMaybeMessage<DestinationNode>(nullptr);
  }

  DestinationNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DestinationNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DestinationNode& from);
  void MergeFrom(const DestinationNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DestinationNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.DestinationNode";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 value = 1 [jstype = JS_STRING];
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.DestinationNode)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class HighNode :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.HighNode) */ {
 public:
  HighNode();
  virtual ~HighNode();

  HighNode(const HighNode& from);
  HighNode(HighNode&& from) noexcept
    : HighNode() {
    *this = ::std::move(from);
  }

  inline HighNode& operator=(const HighNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline HighNode& operator=(HighNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HighNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HighNode* internal_default_instance() {
    return reinterpret_cast<const HighNode*>(
               &_HighNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(HighNode* other);
  friend void swap(HighNode& a, HighNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HighNode* New() const final {
    return CreateMaybeMessage<HighNode>(nullptr);
  }

  HighNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HighNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HighNode& from);
  void MergeFrom(const HighNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HighNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.HighNode";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 value = 1 [jstype = JS_STRING];
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.HighNode)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class IndexNext :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.IndexNext) */ {
 public:
  IndexNext();
  virtual ~IndexNext();

  IndexNext(const IndexNext& from);
  IndexNext(IndexNext&& from) noexcept
    : IndexNext() {
    *this = ::std::move(from);
  }

  inline IndexNext& operator=(const IndexNext& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexNext& operator=(IndexNext&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IndexNext& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IndexNext* internal_default_instance() {
    return reinterpret_cast<const IndexNext*>(
               &_IndexNext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(IndexNext* other);
  friend void swap(IndexNext& a, IndexNext& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IndexNext* New() const final {
    return CreateMaybeMessage<IndexNext>(nullptr);
  }

  IndexNext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IndexNext>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IndexNext& from);
  void MergeFrom(const IndexNext& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexNext* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.IndexNext";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 value = 1 [jstype = JS_STRING];
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.IndexNext)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class IndexPrevious :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.IndexPrevious) */ {
 public:
  IndexPrevious();
  virtual ~IndexPrevious();

  IndexPrevious(const IndexPrevious& from);
  IndexPrevious(IndexPrevious&& from) noexcept
    : IndexPrevious() {
    *this = ::std::move(from);
  }

  inline IndexPrevious& operator=(const IndexPrevious& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexPrevious& operator=(IndexPrevious&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IndexPrevious& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IndexPrevious* internal_default_instance() {
    return reinterpret_cast<const IndexPrevious*>(
               &_IndexPrevious_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(IndexPrevious* other);
  friend void swap(IndexPrevious& a, IndexPrevious& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IndexPrevious* New() const final {
    return CreateMaybeMessage<IndexPrevious>(nullptr);
  }

  IndexPrevious* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IndexPrevious>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IndexPrevious& from);
  void MergeFrom(const IndexPrevious& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexPrevious* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.IndexPrevious";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 value = 1 [jstype = JS_STRING];
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.IndexPrevious)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class LowNode :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.LowNode) */ {
 public:
  LowNode();
  virtual ~LowNode();

  LowNode(const LowNode& from);
  LowNode(LowNode&& from) noexcept
    : LowNode() {
    *this = ::std::move(from);
  }

  inline LowNode& operator=(const LowNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline LowNode& operator=(LowNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LowNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LowNode* internal_default_instance() {
    return reinterpret_cast<const LowNode*>(
               &_LowNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(LowNode* other);
  friend void swap(LowNode& a, LowNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LowNode* New() const final {
    return CreateMaybeMessage<LowNode>(nullptr);
  }

  LowNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LowNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LowNode& from);
  void MergeFrom(const LowNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LowNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.LowNode";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 value = 1 [jstype = JS_STRING];
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.LowNode)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class OwnerNode :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.OwnerNode) */ {
 public:
  OwnerNode();
  virtual ~OwnerNode();

  OwnerNode(const OwnerNode& from);
  OwnerNode(OwnerNode&& from) noexcept
    : OwnerNode() {
    *this = ::std::move(from);
  }

  inline OwnerNode& operator=(const OwnerNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnerNode& operator=(OwnerNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OwnerNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OwnerNode* internal_default_instance() {
    return reinterpret_cast<const OwnerNode*>(
               &_OwnerNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(OwnerNode* other);
  friend void swap(OwnerNode& a, OwnerNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OwnerNode* New() const final {
    return CreateMaybeMessage<OwnerNode>(nullptr);
  }

  OwnerNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OwnerNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OwnerNode& from);
  void MergeFrom(const OwnerNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnerNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.OwnerNode";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 value = 1 [jstype = JS_STRING];
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.OwnerNode)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class EmailHash :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.EmailHash) */ {
 public:
  EmailHash();
  virtual ~EmailHash();

  EmailHash(const EmailHash& from);
  EmailHash(EmailHash&& from) noexcept
    : EmailHash() {
    *this = ::std::move(from);
  }

  inline EmailHash& operator=(const EmailHash& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmailHash& operator=(EmailHash&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EmailHash& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EmailHash* internal_default_instance() {
    return reinterpret_cast<const EmailHash*>(
               &_EmailHash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(EmailHash* other);
  friend void swap(EmailHash& a, EmailHash& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EmailHash* New() const final {
    return CreateMaybeMessage<EmailHash>(nullptr);
  }

  EmailHash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmailHash>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EmailHash& from);
  void MergeFrom(const EmailHash& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmailHash* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.EmailHash";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.EmailHash)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TakerGetsIssuer :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.TakerGetsIssuer) */ {
 public:
  TakerGetsIssuer();
  virtual ~TakerGetsIssuer();

  TakerGetsIssuer(const TakerGetsIssuer& from);
  TakerGetsIssuer(TakerGetsIssuer&& from) noexcept
    : TakerGetsIssuer() {
    *this = ::std::move(from);
  }

  inline TakerGetsIssuer& operator=(const TakerGetsIssuer& from) {
    CopyFrom(from);
    return *this;
  }
  inline TakerGetsIssuer& operator=(TakerGetsIssuer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TakerGetsIssuer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TakerGetsIssuer* internal_default_instance() {
    return reinterpret_cast<const TakerGetsIssuer*>(
               &_TakerGetsIssuer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(TakerGetsIssuer* other);
  friend void swap(TakerGetsIssuer& a, TakerGetsIssuer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TakerGetsIssuer* New() const final {
    return CreateMaybeMessage<TakerGetsIssuer>(nullptr);
  }

  TakerGetsIssuer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TakerGetsIssuer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TakerGetsIssuer& from);
  void MergeFrom(const TakerGetsIssuer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TakerGetsIssuer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.TakerGetsIssuer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.TakerGetsIssuer)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TakerPaysIssuer :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.TakerPaysIssuer) */ {
 public:
  TakerPaysIssuer();
  virtual ~TakerPaysIssuer();

  TakerPaysIssuer(const TakerPaysIssuer& from);
  TakerPaysIssuer(TakerPaysIssuer&& from) noexcept
    : TakerPaysIssuer() {
    *this = ::std::move(from);
  }

  inline TakerPaysIssuer& operator=(const TakerPaysIssuer& from) {
    CopyFrom(from);
    return *this;
  }
  inline TakerPaysIssuer& operator=(TakerPaysIssuer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TakerPaysIssuer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TakerPaysIssuer* internal_default_instance() {
    return reinterpret_cast<const TakerPaysIssuer*>(
               &_TakerPaysIssuer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(TakerPaysIssuer* other);
  friend void swap(TakerPaysIssuer& a, TakerPaysIssuer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TakerPaysIssuer* New() const final {
    return CreateMaybeMessage<TakerPaysIssuer>(nullptr);
  }

  TakerPaysIssuer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TakerPaysIssuer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TakerPaysIssuer& from);
  void MergeFrom(const TakerPaysIssuer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TakerPaysIssuer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.TakerPaysIssuer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.TakerPaysIssuer)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class AccountTransactionID :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.AccountTransactionID) */ {
 public:
  AccountTransactionID();
  virtual ~AccountTransactionID();

  AccountTransactionID(const AccountTransactionID& from);
  AccountTransactionID(AccountTransactionID&& from) noexcept
    : AccountTransactionID() {
    *this = ::std::move(from);
  }

  inline AccountTransactionID& operator=(const AccountTransactionID& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountTransactionID& operator=(AccountTransactionID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AccountTransactionID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountTransactionID* internal_default_instance() {
    return reinterpret_cast<const AccountTransactionID*>(
               &_AccountTransactionID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(AccountTransactionID* other);
  friend void swap(AccountTransactionID& a, AccountTransactionID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountTransactionID* New() const final {
    return CreateMaybeMessage<AccountTransactionID>(nullptr);
  }

  AccountTransactionID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountTransactionID>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AccountTransactionID& from);
  void MergeFrom(const AccountTransactionID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountTransactionID* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.AccountTransactionID";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.AccountTransactionID)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class BookDirectory :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.BookDirectory) */ {
 public:
  BookDirectory();
  virtual ~BookDirectory();

  BookDirectory(const BookDirectory& from);
  BookDirectory(BookDirectory&& from) noexcept
    : BookDirectory() {
    *this = ::std::move(from);
  }

  inline BookDirectory& operator=(const BookDirectory& from) {
    CopyFrom(from);
    return *this;
  }
  inline BookDirectory& operator=(BookDirectory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BookDirectory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BookDirectory* internal_default_instance() {
    return reinterpret_cast<const BookDirectory*>(
               &_BookDirectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(BookDirectory* other);
  friend void swap(BookDirectory& a, BookDirectory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BookDirectory* New() const final {
    return CreateMaybeMessage<BookDirectory>(nullptr);
  }

  BookDirectory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BookDirectory>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BookDirectory& from);
  void MergeFrom(const BookDirectory& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BookDirectory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.BookDirectory";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.BookDirectory)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Channel :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Channel) */ {
 public:
  Channel();
  virtual ~Channel();

  Channel(const Channel& from);
  Channel(Channel&& from) noexcept
    : Channel() {
    *this = ::std::move(from);
  }

  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Channel& operator=(Channel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Channel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Channel* internal_default_instance() {
    return reinterpret_cast<const Channel*>(
               &_Channel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(Channel* other);
  friend void swap(Channel& a, Channel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Channel* New() const final {
    return CreateMaybeMessage<Channel>(nullptr);
  }

  Channel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Channel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Channel& from);
  void MergeFrom(const Channel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Channel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Channel";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Channel)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class CheckID :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.CheckID) */ {
 public:
  CheckID();
  virtual ~CheckID();

  CheckID(const CheckID& from);
  CheckID(CheckID&& from) noexcept
    : CheckID() {
    *this = ::std::move(from);
  }

  inline CheckID& operator=(const CheckID& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckID& operator=(CheckID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CheckID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckID* internal_default_instance() {
    return reinterpret_cast<const CheckID*>(
               &_CheckID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(CheckID* other);
  friend void swap(CheckID& a, CheckID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckID* New() const final {
    return CreateMaybeMessage<CheckID>(nullptr);
  }

  CheckID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckID>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CheckID& from);
  void MergeFrom(const CheckID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckID* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.CheckID";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.CheckID)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Hash :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Hash) */ {
 public:
  Hash();
  virtual ~Hash();

  Hash(const Hash& from);
  Hash(Hash&& from) noexcept
    : Hash() {
    *this = ::std::move(from);
  }

  inline Hash& operator=(const Hash& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hash& operator=(Hash&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Hash& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Hash* internal_default_instance() {
    return reinterpret_cast<const Hash*>(
               &_Hash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(Hash* other);
  friend void swap(Hash& a, Hash& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Hash* New() const final {
    return CreateMaybeMessage<Hash>(nullptr);
  }

  Hash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Hash>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Hash& from);
  void MergeFrom(const Hash& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hash* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Hash";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Hash)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Index :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Index) */ {
 public:
  Index();
  virtual ~Index();

  Index(const Index& from);
  Index(Index&& from) noexcept
    : Index() {
    *this = ::std::move(from);
  }

  inline Index& operator=(const Index& from) {
    CopyFrom(from);
    return *this;
  }
  inline Index& operator=(Index&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Index& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Index* internal_default_instance() {
    return reinterpret_cast<const Index*>(
               &_Index_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(Index* other);
  friend void swap(Index& a, Index& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Index* New() const final {
    return CreateMaybeMessage<Index>(nullptr);
  }

  Index* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Index>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Index& from);
  void MergeFrom(const Index& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Index* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Index";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Index)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class InvoiceID :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.InvoiceID) */ {
 public:
  InvoiceID();
  virtual ~InvoiceID();

  InvoiceID(const InvoiceID& from);
  InvoiceID(InvoiceID&& from) noexcept
    : InvoiceID() {
    *this = ::std::move(from);
  }

  inline InvoiceID& operator=(const InvoiceID& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvoiceID& operator=(InvoiceID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InvoiceID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InvoiceID* internal_default_instance() {
    return reinterpret_cast<const InvoiceID*>(
               &_InvoiceID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(InvoiceID* other);
  friend void swap(InvoiceID& a, InvoiceID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InvoiceID* New() const final {
    return CreateMaybeMessage<InvoiceID>(nullptr);
  }

  InvoiceID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InvoiceID>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InvoiceID& from);
  void MergeFrom(const InvoiceID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvoiceID* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.InvoiceID";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.InvoiceID)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class PreviousTransactionID :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.PreviousTransactionID) */ {
 public:
  PreviousTransactionID();
  virtual ~PreviousTransactionID();

  PreviousTransactionID(const PreviousTransactionID& from);
  PreviousTransactionID(PreviousTransactionID&& from) noexcept
    : PreviousTransactionID() {
    *this = ::std::move(from);
  }

  inline PreviousTransactionID& operator=(const PreviousTransactionID& from) {
    CopyFrom(from);
    return *this;
  }
  inline PreviousTransactionID& operator=(PreviousTransactionID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PreviousTransactionID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PreviousTransactionID* internal_default_instance() {
    return reinterpret_cast<const PreviousTransactionID*>(
               &_PreviousTransactionID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(PreviousTransactionID* other);
  friend void swap(PreviousTransactionID& a, PreviousTransactionID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PreviousTransactionID* New() const final {
    return CreateMaybeMessage<PreviousTransactionID>(nullptr);
  }

  PreviousTransactionID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PreviousTransactionID>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PreviousTransactionID& from);
  void MergeFrom(const PreviousTransactionID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PreviousTransactionID* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.PreviousTransactionID";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.PreviousTransactionID)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class RootIndex :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.RootIndex) */ {
 public:
  RootIndex();
  virtual ~RootIndex();

  RootIndex(const RootIndex& from);
  RootIndex(RootIndex&& from) noexcept
    : RootIndex() {
    *this = ::std::move(from);
  }

  inline RootIndex& operator=(const RootIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline RootIndex& operator=(RootIndex&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RootIndex& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RootIndex* internal_default_instance() {
    return reinterpret_cast<const RootIndex*>(
               &_RootIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(RootIndex* other);
  friend void swap(RootIndex& a, RootIndex& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RootIndex* New() const final {
    return CreateMaybeMessage<RootIndex>(nullptr);
  }

  RootIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RootIndex>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RootIndex& from);
  void MergeFrom(const RootIndex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RootIndex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.RootIndex";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.RootIndex)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Condition :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Condition) */ {
 public:
  Condition();
  virtual ~Condition();

  Condition(const Condition& from);
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition& operator=(Condition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Condition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(Condition* other);
  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Condition* New() const final {
    return CreateMaybeMessage<Condition>(nullptr);
  }

  Condition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Condition";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Condition)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Fulfillment :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Fulfillment) */ {
 public:
  Fulfillment();
  virtual ~Fulfillment();

  Fulfillment(const Fulfillment& from);
  Fulfillment(Fulfillment&& from) noexcept
    : Fulfillment() {
    *this = ::std::move(from);
  }

  inline Fulfillment& operator=(const Fulfillment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fulfillment& operator=(Fulfillment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Fulfillment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fulfillment* internal_default_instance() {
    return reinterpret_cast<const Fulfillment*>(
               &_Fulfillment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(Fulfillment* other);
  friend void swap(Fulfillment& a, Fulfillment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fulfillment* New() const final {
    return CreateMaybeMessage<Fulfillment>(nullptr);
  }

  Fulfillment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fulfillment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Fulfillment& from);
  void MergeFrom(const Fulfillment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fulfillment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Fulfillment";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Fulfillment)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class MemoData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.MemoData) */ {
 public:
  MemoData();
  virtual ~MemoData();

  MemoData(const MemoData& from);
  MemoData(MemoData&& from) noexcept
    : MemoData() {
    *this = ::std::move(from);
  }

  inline MemoData& operator=(const MemoData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoData& operator=(MemoData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MemoData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemoData* internal_default_instance() {
    return reinterpret_cast<const MemoData*>(
               &_MemoData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(MemoData* other);
  friend void swap(MemoData& a, MemoData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemoData* New() const final {
    return CreateMaybeMessage<MemoData>(nullptr);
  }

  MemoData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MemoData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MemoData& from);
  void MergeFrom(const MemoData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemoData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.MemoData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.MemoData)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class MemoFormat :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.MemoFormat) */ {
 public:
  MemoFormat();
  virtual ~MemoFormat();

  MemoFormat(const MemoFormat& from);
  MemoFormat(MemoFormat&& from) noexcept
    : MemoFormat() {
    *this = ::std::move(from);
  }

  inline MemoFormat& operator=(const MemoFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoFormat& operator=(MemoFormat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MemoFormat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemoFormat* internal_default_instance() {
    return reinterpret_cast<const MemoFormat*>(
               &_MemoFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(MemoFormat* other);
  friend void swap(MemoFormat& a, MemoFormat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemoFormat* New() const final {
    return CreateMaybeMessage<MemoFormat>(nullptr);
  }

  MemoFormat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MemoFormat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MemoFormat& from);
  void MergeFrom(const MemoFormat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemoFormat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.MemoFormat";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.MemoFormat)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class MemoType :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.MemoType) */ {
 public:
  MemoType();
  virtual ~MemoType();

  MemoType(const MemoType& from);
  MemoType(MemoType&& from) noexcept
    : MemoType() {
    *this = ::std::move(from);
  }

  inline MemoType& operator=(const MemoType& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoType& operator=(MemoType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MemoType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemoType* internal_default_instance() {
    return reinterpret_cast<const MemoType*>(
               &_MemoType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(MemoType* other);
  friend void swap(MemoType& a, MemoType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemoType* New() const final {
    return CreateMaybeMessage<MemoType>(nullptr);
  }

  MemoType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MemoType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MemoType& from);
  void MergeFrom(const MemoType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemoType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.MemoType";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.MemoType)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class MessageKey :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.MessageKey) */ {
 public:
  MessageKey();
  virtual ~MessageKey();

  MessageKey(const MessageKey& from);
  MessageKey(MessageKey&& from) noexcept
    : MessageKey() {
    *this = ::std::move(from);
  }

  inline MessageKey& operator=(const MessageKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageKey& operator=(MessageKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MessageKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageKey* internal_default_instance() {
    return reinterpret_cast<const MessageKey*>(
               &_MessageKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(MessageKey* other);
  friend void swap(MessageKey& a, MessageKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageKey* New() const final {
    return CreateMaybeMessage<MessageKey>(nullptr);
  }

  MessageKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessageKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MessageKey& from);
  void MergeFrom(const MessageKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.MessageKey";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.MessageKey)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class PublicKey :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.PublicKey) */ {
 public:
  PublicKey();
  virtual ~PublicKey();

  PublicKey(const PublicKey& from);
  PublicKey(PublicKey&& from) noexcept
    : PublicKey() {
    *this = ::std::move(from);
  }

  inline PublicKey& operator=(const PublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicKey& operator=(PublicKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PublicKey* internal_default_instance() {
    return reinterpret_cast<const PublicKey*>(
               &_PublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(PublicKey* other);
  friend void swap(PublicKey& a, PublicKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PublicKey* New() const final {
    return CreateMaybeMessage<PublicKey>(nullptr);
  }

  PublicKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PublicKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PublicKey& from);
  void MergeFrom(const PublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublicKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.PublicKey";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.PublicKey)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class PaymentChannelSignature :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.PaymentChannelSignature) */ {
 public:
  PaymentChannelSignature();
  virtual ~PaymentChannelSignature();

  PaymentChannelSignature(const PaymentChannelSignature& from);
  PaymentChannelSignature(PaymentChannelSignature&& from) noexcept
    : PaymentChannelSignature() {
    *this = ::std::move(from);
  }

  inline PaymentChannelSignature& operator=(const PaymentChannelSignature& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentChannelSignature& operator=(PaymentChannelSignature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PaymentChannelSignature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PaymentChannelSignature* internal_default_instance() {
    return reinterpret_cast<const PaymentChannelSignature*>(
               &_PaymentChannelSignature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  void Swap(PaymentChannelSignature* other);
  friend void swap(PaymentChannelSignature& a, PaymentChannelSignature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PaymentChannelSignature* New() const final {
    return CreateMaybeMessage<PaymentChannelSignature>(nullptr);
  }

  PaymentChannelSignature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PaymentChannelSignature>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PaymentChannelSignature& from);
  void MergeFrom(const PaymentChannelSignature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentChannelSignature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.PaymentChannelSignature";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.PaymentChannelSignature)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SigningPublicKey :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.SigningPublicKey) */ {
 public:
  SigningPublicKey();
  virtual ~SigningPublicKey();

  SigningPublicKey(const SigningPublicKey& from);
  SigningPublicKey(SigningPublicKey&& from) noexcept
    : SigningPublicKey() {
    *this = ::std::move(from);
  }

  inline SigningPublicKey& operator=(const SigningPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigningPublicKey& operator=(SigningPublicKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SigningPublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SigningPublicKey* internal_default_instance() {
    return reinterpret_cast<const SigningPublicKey*>(
               &_SigningPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  void Swap(SigningPublicKey* other);
  friend void swap(SigningPublicKey& a, SigningPublicKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SigningPublicKey* New() const final {
    return CreateMaybeMessage<SigningPublicKey>(nullptr);
  }

  SigningPublicKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SigningPublicKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SigningPublicKey& from);
  void MergeFrom(const SigningPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigningPublicKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.SigningPublicKey";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.SigningPublicKey)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TransactionSignature :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.TransactionSignature) */ {
 public:
  TransactionSignature();
  virtual ~TransactionSignature();

  TransactionSignature(const TransactionSignature& from);
  TransactionSignature(TransactionSignature&& from) noexcept
    : TransactionSignature() {
    *this = ::std::move(from);
  }

  inline TransactionSignature& operator=(const TransactionSignature& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionSignature& operator=(TransactionSignature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransactionSignature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransactionSignature* internal_default_instance() {
    return reinterpret_cast<const TransactionSignature*>(
               &_TransactionSignature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  void Swap(TransactionSignature* other);
  friend void swap(TransactionSignature& a, TransactionSignature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransactionSignature* New() const final {
    return CreateMaybeMessage<TransactionSignature>(nullptr);
  }

  TransactionSignature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionSignature>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransactionSignature& from);
  void MergeFrom(const TransactionSignature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionSignature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.TransactionSignature";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.TransactionSignature)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ValidatorToDisable :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.ValidatorToDisable) */ {
 public:
  ValidatorToDisable();
  virtual ~ValidatorToDisable();

  ValidatorToDisable(const ValidatorToDisable& from);
  ValidatorToDisable(ValidatorToDisable&& from) noexcept
    : ValidatorToDisable() {
    *this = ::std::move(from);
  }

  inline ValidatorToDisable& operator=(const ValidatorToDisable& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorToDisable& operator=(ValidatorToDisable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ValidatorToDisable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidatorToDisable* internal_default_instance() {
    return reinterpret_cast<const ValidatorToDisable*>(
               &_ValidatorToDisable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  void Swap(ValidatorToDisable* other);
  friend void swap(ValidatorToDisable& a, ValidatorToDisable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ValidatorToDisable* New() const final {
    return CreateMaybeMessage<ValidatorToDisable>(nullptr);
  }

  ValidatorToDisable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidatorToDisable>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValidatorToDisable& from);
  void MergeFrom(const ValidatorToDisable& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorToDisable* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.ValidatorToDisable";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.ValidatorToDisable)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ValidatorToReEnable :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.ValidatorToReEnable) */ {
 public:
  ValidatorToReEnable();
  virtual ~ValidatorToReEnable();

  ValidatorToReEnable(const ValidatorToReEnable& from);
  ValidatorToReEnable(ValidatorToReEnable&& from) noexcept
    : ValidatorToReEnable() {
    *this = ::std::move(from);
  }

  inline ValidatorToReEnable& operator=(const ValidatorToReEnable& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorToReEnable& operator=(ValidatorToReEnable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ValidatorToReEnable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidatorToReEnable* internal_default_instance() {
    return reinterpret_cast<const ValidatorToReEnable*>(
               &_ValidatorToReEnable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  void Swap(ValidatorToReEnable* other);
  friend void swap(ValidatorToReEnable& a, ValidatorToReEnable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ValidatorToReEnable* New() const final {
    return CreateMaybeMessage<ValidatorToReEnable>(nullptr);
  }

  ValidatorToReEnable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidatorToReEnable>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValidatorToReEnable& from);
  void MergeFrom(const ValidatorToReEnable& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorToReEnable* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.ValidatorToReEnable";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.ValidatorToReEnable)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TakerGetsCurreny :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.TakerGetsCurreny) */ {
 public:
  TakerGetsCurreny();
  virtual ~TakerGetsCurreny();

  TakerGetsCurreny(const TakerGetsCurreny& from);
  TakerGetsCurreny(TakerGetsCurreny&& from) noexcept
    : TakerGetsCurreny() {
    *this = ::std::move(from);
  }

  inline TakerGetsCurreny& operator=(const TakerGetsCurreny& from) {
    CopyFrom(from);
    return *this;
  }
  inline TakerGetsCurreny& operator=(TakerGetsCurreny&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TakerGetsCurreny& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TakerGetsCurreny* internal_default_instance() {
    return reinterpret_cast<const TakerGetsCurreny*>(
               &_TakerGetsCurreny_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  void Swap(TakerGetsCurreny* other);
  friend void swap(TakerGetsCurreny& a, TakerGetsCurreny& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TakerGetsCurreny* New() const final {
    return CreateMaybeMessage<TakerGetsCurreny>(nullptr);
  }

  TakerGetsCurreny* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TakerGetsCurreny>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TakerGetsCurreny& from);
  void MergeFrom(const TakerGetsCurreny& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TakerGetsCurreny* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.TakerGetsCurreny";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.Currency value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::Currency& value() const;
  ::org::xrpl::rpc::v1::Currency* release_value();
  ::org::xrpl::rpc::v1::Currency* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::Currency* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.TakerGetsCurreny)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::Currency* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TakerPaysCurrency :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.TakerPaysCurrency) */ {
 public:
  TakerPaysCurrency();
  virtual ~TakerPaysCurrency();

  TakerPaysCurrency(const TakerPaysCurrency& from);
  TakerPaysCurrency(TakerPaysCurrency&& from) noexcept
    : TakerPaysCurrency() {
    *this = ::std::move(from);
  }

  inline TakerPaysCurrency& operator=(const TakerPaysCurrency& from) {
    CopyFrom(from);
    return *this;
  }
  inline TakerPaysCurrency& operator=(TakerPaysCurrency&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TakerPaysCurrency& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TakerPaysCurrency* internal_default_instance() {
    return reinterpret_cast<const TakerPaysCurrency*>(
               &_TakerPaysCurrency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  void Swap(TakerPaysCurrency* other);
  friend void swap(TakerPaysCurrency& a, TakerPaysCurrency& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TakerPaysCurrency* New() const final {
    return CreateMaybeMessage<TakerPaysCurrency>(nullptr);
  }

  TakerPaysCurrency* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TakerPaysCurrency>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TakerPaysCurrency& from);
  void MergeFrom(const TakerPaysCurrency& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TakerPaysCurrency* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.TakerPaysCurrency";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.Currency value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::Currency& value() const;
  ::org::xrpl::rpc::v1::Currency* release_value();
  ::org::xrpl::rpc::v1::Currency* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::Currency* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.TakerPaysCurrency)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::Currency* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Amount :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Amount) */ {
 public:
  Amount();
  virtual ~Amount();

  Amount(const Amount& from);
  Amount(Amount&& from) noexcept
    : Amount() {
    *this = ::std::move(from);
  }

  inline Amount& operator=(const Amount& from) {
    CopyFrom(from);
    return *this;
  }
  inline Amount& operator=(Amount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Amount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Amount* internal_default_instance() {
    return reinterpret_cast<const Amount*>(
               &_Amount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  void Swap(Amount* other);
  friend void swap(Amount& a, Amount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Amount* New() const final {
    return CreateMaybeMessage<Amount>(nullptr);
  }

  Amount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Amount>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Amount& from);
  void MergeFrom(const Amount& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Amount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Amount";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.CurrencyAmount value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::CurrencyAmount& value() const;
  ::org::xrpl::rpc::v1::CurrencyAmount* release_value();
  ::org::xrpl::rpc::v1::CurrencyAmount* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Amount)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::CurrencyAmount* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Balance :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Balance) */ {
 public:
  Balance();
  virtual ~Balance();

  Balance(const Balance& from);
  Balance(Balance&& from) noexcept
    : Balance() {
    *this = ::std::move(from);
  }

  inline Balance& operator=(const Balance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Balance& operator=(Balance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Balance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Balance* internal_default_instance() {
    return reinterpret_cast<const Balance*>(
               &_Balance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  void Swap(Balance* other);
  friend void swap(Balance& a, Balance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Balance* New() const final {
    return CreateMaybeMessage<Balance>(nullptr);
  }

  Balance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Balance>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Balance& from);
  void MergeFrom(const Balance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Balance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Balance";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.CurrencyAmount value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::CurrencyAmount& value() const;
  ::org::xrpl::rpc::v1::CurrencyAmount* release_value();
  ::org::xrpl::rpc::v1::CurrencyAmount* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Balance)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::CurrencyAmount* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class DeliverMin :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.DeliverMin) */ {
 public:
  DeliverMin();
  virtual ~DeliverMin();

  DeliverMin(const DeliverMin& from);
  DeliverMin(DeliverMin&& from) noexcept
    : DeliverMin() {
    *this = ::std::move(from);
  }

  inline DeliverMin& operator=(const DeliverMin& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeliverMin& operator=(DeliverMin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeliverMin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeliverMin* internal_default_instance() {
    return reinterpret_cast<const DeliverMin*>(
               &_DeliverMin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  void Swap(DeliverMin* other);
  friend void swap(DeliverMin& a, DeliverMin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeliverMin* New() const final {
    return CreateMaybeMessage<DeliverMin>(nullptr);
  }

  DeliverMin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeliverMin>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeliverMin& from);
  void MergeFrom(const DeliverMin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeliverMin* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.DeliverMin";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.CurrencyAmount value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::CurrencyAmount& value() const;
  ::org::xrpl::rpc::v1::CurrencyAmount* release_value();
  ::org::xrpl::rpc::v1::CurrencyAmount* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.DeliverMin)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::CurrencyAmount* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class DeliveredAmount :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.DeliveredAmount) */ {
 public:
  DeliveredAmount();
  virtual ~DeliveredAmount();

  DeliveredAmount(const DeliveredAmount& from);
  DeliveredAmount(DeliveredAmount&& from) noexcept
    : DeliveredAmount() {
    *this = ::std::move(from);
  }

  inline DeliveredAmount& operator=(const DeliveredAmount& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeliveredAmount& operator=(DeliveredAmount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeliveredAmount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeliveredAmount* internal_default_instance() {
    return reinterpret_cast<const DeliveredAmount*>(
               &_DeliveredAmount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  void Swap(DeliveredAmount* other);
  friend void swap(DeliveredAmount& a, DeliveredAmount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeliveredAmount* New() const final {
    return CreateMaybeMessage<DeliveredAmount>(nullptr);
  }

  DeliveredAmount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeliveredAmount>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeliveredAmount& from);
  void MergeFrom(const DeliveredAmount& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeliveredAmount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.DeliveredAmount";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.CurrencyAmount value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::CurrencyAmount& value() const;
  ::org::xrpl::rpc::v1::CurrencyAmount* release_value();
  ::org::xrpl::rpc::v1::CurrencyAmount* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.DeliveredAmount)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::CurrencyAmount* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class HighLimit :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.HighLimit) */ {
 public:
  HighLimit();
  virtual ~HighLimit();

  HighLimit(const HighLimit& from);
  HighLimit(HighLimit&& from) noexcept
    : HighLimit() {
    *this = ::std::move(from);
  }

  inline HighLimit& operator=(const HighLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline HighLimit& operator=(HighLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HighLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HighLimit* internal_default_instance() {
    return reinterpret_cast<const HighLimit*>(
               &_HighLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  void Swap(HighLimit* other);
  friend void swap(HighLimit& a, HighLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HighLimit* New() const final {
    return CreateMaybeMessage<HighLimit>(nullptr);
  }

  HighLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HighLimit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HighLimit& from);
  void MergeFrom(const HighLimit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HighLimit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.HighLimit";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.CurrencyAmount value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::CurrencyAmount& value() const;
  ::org::xrpl::rpc::v1::CurrencyAmount* release_value();
  ::org::xrpl::rpc::v1::CurrencyAmount* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.HighLimit)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::CurrencyAmount* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class LimitAmount :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.LimitAmount) */ {
 public:
  LimitAmount();
  virtual ~LimitAmount();

  LimitAmount(const LimitAmount& from);
  LimitAmount(LimitAmount&& from) noexcept
    : LimitAmount() {
    *this = ::std::move(from);
  }

  inline LimitAmount& operator=(const LimitAmount& from) {
    CopyFrom(from);
    return *this;
  }
  inline LimitAmount& operator=(LimitAmount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LimitAmount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LimitAmount* internal_default_instance() {
    return reinterpret_cast<const LimitAmount*>(
               &_LimitAmount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  void Swap(LimitAmount* other);
  friend void swap(LimitAmount& a, LimitAmount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LimitAmount* New() const final {
    return CreateMaybeMessage<LimitAmount>(nullptr);
  }

  LimitAmount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LimitAmount>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LimitAmount& from);
  void MergeFrom(const LimitAmount& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LimitAmount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.LimitAmount";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.CurrencyAmount value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::CurrencyAmount& value() const;
  ::org::xrpl::rpc::v1::CurrencyAmount* release_value();
  ::org::xrpl::rpc::v1::CurrencyAmount* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.LimitAmount)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::CurrencyAmount* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class LowLimit :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.LowLimit) */ {
 public:
  LowLimit();
  virtual ~LowLimit();

  LowLimit(const LowLimit& from);
  LowLimit(LowLimit&& from) noexcept
    : LowLimit() {
    *this = ::std::move(from);
  }

  inline LowLimit& operator=(const LowLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline LowLimit& operator=(LowLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LowLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LowLimit* internal_default_instance() {
    return reinterpret_cast<const LowLimit*>(
               &_LowLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  void Swap(LowLimit* other);
  friend void swap(LowLimit& a, LowLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LowLimit* New() const final {
    return CreateMaybeMessage<LowLimit>(nullptr);
  }

  LowLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LowLimit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LowLimit& from);
  void MergeFrom(const LowLimit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LowLimit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.LowLimit";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.CurrencyAmount value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::CurrencyAmount& value() const;
  ::org::xrpl::rpc::v1::CurrencyAmount* release_value();
  ::org::xrpl::rpc::v1::CurrencyAmount* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.LowLimit)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::CurrencyAmount* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SendMax :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.SendMax) */ {
 public:
  SendMax();
  virtual ~SendMax();

  SendMax(const SendMax& from);
  SendMax(SendMax&& from) noexcept
    : SendMax() {
    *this = ::std::move(from);
  }

  inline SendMax& operator=(const SendMax& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMax& operator=(SendMax&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SendMax& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SendMax* internal_default_instance() {
    return reinterpret_cast<const SendMax*>(
               &_SendMax_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  void Swap(SendMax* other);
  friend void swap(SendMax& a, SendMax& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SendMax* New() const final {
    return CreateMaybeMessage<SendMax>(nullptr);
  }

  SendMax* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SendMax>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SendMax& from);
  void MergeFrom(const SendMax& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMax* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.SendMax";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.CurrencyAmount value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::CurrencyAmount& value() const;
  ::org::xrpl::rpc::v1::CurrencyAmount* release_value();
  ::org::xrpl::rpc::v1::CurrencyAmount* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.SendMax)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::CurrencyAmount* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TakerGets :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.TakerGets) */ {
 public:
  TakerGets();
  virtual ~TakerGets();

  TakerGets(const TakerGets& from);
  TakerGets(TakerGets&& from) noexcept
    : TakerGets() {
    *this = ::std::move(from);
  }

  inline TakerGets& operator=(const TakerGets& from) {
    CopyFrom(from);
    return *this;
  }
  inline TakerGets& operator=(TakerGets&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TakerGets& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TakerGets* internal_default_instance() {
    return reinterpret_cast<const TakerGets*>(
               &_TakerGets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  void Swap(TakerGets* other);
  friend void swap(TakerGets& a, TakerGets& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TakerGets* New() const final {
    return CreateMaybeMessage<TakerGets>(nullptr);
  }

  TakerGets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TakerGets>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TakerGets& from);
  void MergeFrom(const TakerGets& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TakerGets* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.TakerGets";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.CurrencyAmount value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::CurrencyAmount& value() const;
  ::org::xrpl::rpc::v1::CurrencyAmount* release_value();
  ::org::xrpl::rpc::v1::CurrencyAmount* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.TakerGets)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::CurrencyAmount* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TakerPays :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.TakerPays) */ {
 public:
  TakerPays();
  virtual ~TakerPays();

  TakerPays(const TakerPays& from);
  TakerPays(TakerPays&& from) noexcept
    : TakerPays() {
    *this = ::std::move(from);
  }

  inline TakerPays& operator=(const TakerPays& from) {
    CopyFrom(from);
    return *this;
  }
  inline TakerPays& operator=(TakerPays&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TakerPays& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TakerPays* internal_default_instance() {
    return reinterpret_cast<const TakerPays*>(
               &_TakerPays_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  void Swap(TakerPays* other);
  friend void swap(TakerPays& a, TakerPays& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TakerPays* New() const final {
    return CreateMaybeMessage<TakerPays>(nullptr);
  }

  TakerPays* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TakerPays>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TakerPays& from);
  void MergeFrom(const TakerPays& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TakerPays* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.TakerPays";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.CurrencyAmount value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::CurrencyAmount& value() const;
  ::org::xrpl::rpc::v1::CurrencyAmount* release_value();
  ::org::xrpl::rpc::v1::CurrencyAmount* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.TakerPays)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::CurrencyAmount* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Account :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Account) */ {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);
  Account(Account&& from) noexcept
    : Account() {
    *this = ::std::move(from);
  }

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }
  inline Account& operator=(Account&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Account& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Account* internal_default_instance() {
    return reinterpret_cast<const Account*>(
               &_Account_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  void Swap(Account* other);
  friend void swap(Account& a, Account& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Account* New() const final {
    return CreateMaybeMessage<Account>(nullptr);
  }

  Account* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Account>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Account* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Account";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.AccountAddress value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::AccountAddress& value() const;
  ::org::xrpl::rpc::v1::AccountAddress* release_value();
  ::org::xrpl::rpc::v1::AccountAddress* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::AccountAddress* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Account)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::AccountAddress* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Authorize :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Authorize) */ {
 public:
  Authorize();
  virtual ~Authorize();

  Authorize(const Authorize& from);
  Authorize(Authorize&& from) noexcept
    : Authorize() {
    *this = ::std::move(from);
  }

  inline Authorize& operator=(const Authorize& from) {
    CopyFrom(from);
    return *this;
  }
  inline Authorize& operator=(Authorize&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Authorize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authorize* internal_default_instance() {
    return reinterpret_cast<const Authorize*>(
               &_Authorize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  void Swap(Authorize* other);
  friend void swap(Authorize& a, Authorize& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authorize* New() const final {
    return CreateMaybeMessage<Authorize>(nullptr);
  }

  Authorize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Authorize>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Authorize& from);
  void MergeFrom(const Authorize& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authorize* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Authorize";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.AccountAddress value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::AccountAddress& value() const;
  ::org::xrpl::rpc::v1::AccountAddress* release_value();
  ::org::xrpl::rpc::v1::AccountAddress* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::AccountAddress* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Authorize)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::AccountAddress* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Destination :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Destination) */ {
 public:
  Destination();
  virtual ~Destination();

  Destination(const Destination& from);
  Destination(Destination&& from) noexcept
    : Destination() {
    *this = ::std::move(from);
  }

  inline Destination& operator=(const Destination& from) {
    CopyFrom(from);
    return *this;
  }
  inline Destination& operator=(Destination&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Destination& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Destination* internal_default_instance() {
    return reinterpret_cast<const Destination*>(
               &_Destination_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  void Swap(Destination* other);
  friend void swap(Destination& a, Destination& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Destination* New() const final {
    return CreateMaybeMessage<Destination>(nullptr);
  }

  Destination* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Destination>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Destination& from);
  void MergeFrom(const Destination& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Destination* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Destination";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.AccountAddress value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::AccountAddress& value() const;
  ::org::xrpl::rpc::v1::AccountAddress* release_value();
  ::org::xrpl::rpc::v1::AccountAddress* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::AccountAddress* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Destination)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::AccountAddress* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Owner :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Owner) */ {
 public:
  Owner();
  virtual ~Owner();

  Owner(const Owner& from);
  Owner(Owner&& from) noexcept
    : Owner() {
    *this = ::std::move(from);
  }

  inline Owner& operator=(const Owner& from) {
    CopyFrom(from);
    return *this;
  }
  inline Owner& operator=(Owner&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Owner& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Owner* internal_default_instance() {
    return reinterpret_cast<const Owner*>(
               &_Owner_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  void Swap(Owner* other);
  friend void swap(Owner& a, Owner& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Owner* New() const final {
    return CreateMaybeMessage<Owner>(nullptr);
  }

  Owner* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Owner>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Owner& from);
  void MergeFrom(const Owner& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Owner* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Owner";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.AccountAddress value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::AccountAddress& value() const;
  ::org::xrpl::rpc::v1::AccountAddress* release_value();
  ::org::xrpl::rpc::v1::AccountAddress* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::AccountAddress* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Owner)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::AccountAddress* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class RegularKey :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.RegularKey) */ {
 public:
  RegularKey();
  virtual ~RegularKey();

  RegularKey(const RegularKey& from);
  RegularKey(RegularKey&& from) noexcept
    : RegularKey() {
    *this = ::std::move(from);
  }

  inline RegularKey& operator=(const RegularKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegularKey& operator=(RegularKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegularKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegularKey* internal_default_instance() {
    return reinterpret_cast<const RegularKey*>(
               &_RegularKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  void Swap(RegularKey* other);
  friend void swap(RegularKey& a, RegularKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegularKey* New() const final {
    return CreateMaybeMessage<RegularKey>(nullptr);
  }

  RegularKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegularKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegularKey& from);
  void MergeFrom(const RegularKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegularKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.RegularKey";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.AccountAddress value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::AccountAddress& value() const;
  ::org::xrpl::rpc::v1::AccountAddress* release_value();
  ::org::xrpl::rpc::v1::AccountAddress* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::AccountAddress* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.RegularKey)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::AccountAddress* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Unauthorize :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Unauthorize) */ {
 public:
  Unauthorize();
  virtual ~Unauthorize();

  Unauthorize(const Unauthorize& from);
  Unauthorize(Unauthorize&& from) noexcept
    : Unauthorize() {
    *this = ::std::move(from);
  }

  inline Unauthorize& operator=(const Unauthorize& from) {
    CopyFrom(from);
    return *this;
  }
  inline Unauthorize& operator=(Unauthorize&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Unauthorize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Unauthorize* internal_default_instance() {
    return reinterpret_cast<const Unauthorize*>(
               &_Unauthorize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  void Swap(Unauthorize* other);
  friend void swap(Unauthorize& a, Unauthorize& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Unauthorize* New() const final {
    return CreateMaybeMessage<Unauthorize>(nullptr);
  }

  Unauthorize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Unauthorize>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Unauthorize& from);
  void MergeFrom(const Unauthorize& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Unauthorize* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Unauthorize";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.AccountAddress value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::org::xrpl::rpc::v1::AccountAddress& value() const;
  ::org::xrpl::rpc::v1::AccountAddress* release_value();
  ::org::xrpl::rpc::v1::AccountAddress* mutable_value();
  void set_allocated_value(::org::xrpl::rpc::v1::AccountAddress* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Unauthorize)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::AccountAddress* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Domain :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Domain) */ {
 public:
  Domain();
  virtual ~Domain();

  Domain(const Domain& from);
  Domain(Domain&& from) noexcept
    : Domain() {
    *this = ::std::move(from);
  }

  inline Domain& operator=(const Domain& from) {
    CopyFrom(from);
    return *this;
  }
  inline Domain& operator=(Domain&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Domain& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Domain* internal_default_instance() {
    return reinterpret_cast<const Domain*>(
               &_Domain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  void Swap(Domain* other);
  friend void swap(Domain& a, Domain& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Domain* New() const final {
    return CreateMaybeMessage<Domain>(nullptr);
  }

  Domain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Domain>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Domain& from);
  void MergeFrom(const Domain& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Domain* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Domain";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Domain)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SignerEntry :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.SignerEntry) */ {
 public:
  SignerEntry();
  virtual ~SignerEntry();

  SignerEntry(const SignerEntry& from);
  SignerEntry(SignerEntry&& from) noexcept
    : SignerEntry() {
    *this = ::std::move(from);
  }

  inline SignerEntry& operator=(const SignerEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignerEntry& operator=(SignerEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignerEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignerEntry* internal_default_instance() {
    return reinterpret_cast<const SignerEntry*>(
               &_SignerEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  void Swap(SignerEntry* other);
  friend void swap(SignerEntry& a, SignerEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignerEntry* New() const final {
    return CreateMaybeMessage<SignerEntry>(nullptr);
  }

  SignerEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignerEntry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignerEntry& from);
  void MergeFrom(const SignerEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignerEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.SignerEntry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.Account account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::org::xrpl::rpc::v1::Account& account() const;
  ::org::xrpl::rpc::v1::Account* release_account();
  ::org::xrpl::rpc::v1::Account* mutable_account();
  void set_allocated_account(::org::xrpl::rpc::v1::Account* account);

  // .org.xrpl.rpc.v1.SignerWeight signer_weight = 2;
  bool has_signer_weight() const;
  void clear_signer_weight();
  static const int kSignerWeightFieldNumber = 2;
  const ::org::xrpl::rpc::v1::SignerWeight& signer_weight() const;
  ::org::xrpl::rpc::v1::SignerWeight* release_signer_weight();
  ::org::xrpl::rpc::v1::SignerWeight* mutable_signer_weight();
  void set_allocated_signer_weight(::org::xrpl::rpc::v1::SignerWeight* signer_weight);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.SignerEntry)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::Account* account_;
  ::org::xrpl::rpc::v1::SignerWeight* signer_weight_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class DisabledValidator :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.DisabledValidator) */ {
 public:
  DisabledValidator();
  virtual ~DisabledValidator();

  DisabledValidator(const DisabledValidator& from);
  DisabledValidator(DisabledValidator&& from) noexcept
    : DisabledValidator() {
    *this = ::std::move(from);
  }

  inline DisabledValidator& operator=(const DisabledValidator& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisabledValidator& operator=(DisabledValidator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DisabledValidator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DisabledValidator* internal_default_instance() {
    return reinterpret_cast<const DisabledValidator*>(
               &_DisabledValidator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  void Swap(DisabledValidator* other);
  friend void swap(DisabledValidator& a, DisabledValidator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DisabledValidator* New() const final {
    return CreateMaybeMessage<DisabledValidator>(nullptr);
  }

  DisabledValidator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DisabledValidator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DisabledValidator& from);
  void MergeFrom(const DisabledValidator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisabledValidator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.DisabledValidator";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.PublicKey public_key = 1;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  const ::org::xrpl::rpc::v1::PublicKey& public_key() const;
  ::org::xrpl::rpc::v1::PublicKey* release_public_key();
  ::org::xrpl::rpc::v1::PublicKey* mutable_public_key();
  void set_allocated_public_key(::org::xrpl::rpc::v1::PublicKey* public_key);

  // .org.xrpl.rpc.v1.FirstLedgerSequence ledger_sequence = 2;
  bool has_ledger_sequence() const;
  void clear_ledger_sequence();
  static const int kLedgerSequenceFieldNumber = 2;
  const ::org::xrpl::rpc::v1::FirstLedgerSequence& ledger_sequence() const;
  ::org::xrpl::rpc::v1::FirstLedgerSequence* release_ledger_sequence();
  ::org::xrpl::rpc::v1::FirstLedgerSequence* mutable_ledger_sequence();
  void set_allocated_ledger_sequence(::org::xrpl::rpc::v1::FirstLedgerSequence* ledger_sequence);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.DisabledValidator)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::PublicKey* public_key_;
  ::org::xrpl::rpc::v1::FirstLedgerSequence* ledger_sequence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CancelAfter

// uint32 value = 1;
inline void CancelAfter::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CancelAfter::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.CancelAfter.value)
  return value_;
}
inline void CancelAfter::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.CancelAfter.value)
}

// -------------------------------------------------------------------

// ClearFlag

// uint32 value = 1;
inline void ClearFlag::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClearFlag::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.ClearFlag.value)
  return value_;
}
inline void ClearFlag::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.ClearFlag.value)
}

// -------------------------------------------------------------------

// CloseTime

// uint32 value = 1;
inline void CloseTime::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CloseTime::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.CloseTime.value)
  return value_;
}
inline void CloseTime::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.CloseTime.value)
}

// -------------------------------------------------------------------

// Date

// uint32 value = 1;
inline void Date::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Date::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Date.value)
  return value_;
}
inline void Date::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.Date.value)
}

// -------------------------------------------------------------------

// DestinationTag

// uint32 value = 1;
inline void DestinationTag::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DestinationTag::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DestinationTag.value)
  return value_;
}
inline void DestinationTag::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.DestinationTag.value)
}

// -------------------------------------------------------------------

// Expiration

// uint32 value = 1;
inline void Expiration::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Expiration::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Expiration.value)
  return value_;
}
inline void Expiration::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.Expiration.value)
}

// -------------------------------------------------------------------

// FinishAfter

// uint32 value = 1;
inline void FinishAfter::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FinishAfter::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.FinishAfter.value)
  return value_;
}
inline void FinishAfter::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.FinishAfter.value)
}

// -------------------------------------------------------------------

// Flags

// uint32 value = 1;
inline void Flags::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Flags::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Flags.value)
  return value_;
}
inline void Flags::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.Flags.value)
}

// -------------------------------------------------------------------

// HighQualityIn

// uint32 value = 1;
inline void HighQualityIn::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HighQualityIn::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.HighQualityIn.value)
  return value_;
}
inline void HighQualityIn::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.HighQualityIn.value)
}

// -------------------------------------------------------------------

// HighQualityOut

// uint32 value = 1;
inline void HighQualityOut::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HighQualityOut::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.HighQualityOut.value)
  return value_;
}
inline void HighQualityOut::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.HighQualityOut.value)
}

// -------------------------------------------------------------------

// FirstLedgerSequence

// uint32 value = 1;
inline void FirstLedgerSequence::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FirstLedgerSequence::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.FirstLedgerSequence.value)
  return value_;
}
inline void FirstLedgerSequence::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.FirstLedgerSequence.value)
}

// -------------------------------------------------------------------

// LastLedgerSequence

// uint32 value = 1;
inline void LastLedgerSequence::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LastLedgerSequence::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LastLedgerSequence.value)
  return value_;
}
inline void LastLedgerSequence::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.LastLedgerSequence.value)
}

// -------------------------------------------------------------------

// LowQualityIn

// uint32 value = 1;
inline void LowQualityIn::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LowQualityIn::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LowQualityIn.value)
  return value_;
}
inline void LowQualityIn::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.LowQualityIn.value)
}

// -------------------------------------------------------------------

// LowQualityOut

// uint32 value = 1;
inline void LowQualityOut::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LowQualityOut::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LowQualityOut.value)
  return value_;
}
inline void LowQualityOut::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.LowQualityOut.value)
}

// -------------------------------------------------------------------

// OfferSequence

// uint32 value = 1;
inline void OfferSequence::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OfferSequence::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.OfferSequence.value)
  return value_;
}
inline void OfferSequence::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.OfferSequence.value)
}

// -------------------------------------------------------------------

// OwnerCount

// uint32 value = 1;
inline void OwnerCount::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OwnerCount::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.OwnerCount.value)
  return value_;
}
inline void OwnerCount::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.OwnerCount.value)
}

// -------------------------------------------------------------------

// PreviousTransactionLedgerSequence

// uint32 value = 1;
inline void PreviousTransactionLedgerSequence::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PreviousTransactionLedgerSequence::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PreviousTransactionLedgerSequence.value)
  return value_;
}
inline void PreviousTransactionLedgerSequence::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.PreviousTransactionLedgerSequence.value)
}

// -------------------------------------------------------------------

// QualityIn

// uint32 value = 1;
inline void QualityIn::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 QualityIn::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QualityIn.value)
  return value_;
}
inline void QualityIn::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.QualityIn.value)
}

// -------------------------------------------------------------------

// QualityOut

// uint32 value = 1;
inline void QualityOut::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 QualityOut::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.QualityOut.value)
  return value_;
}
inline void QualityOut::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.QualityOut.value)
}

// -------------------------------------------------------------------

// ReferenceFeeUnits

// uint32 value = 1;
inline void ReferenceFeeUnits::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ReferenceFeeUnits::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.ReferenceFeeUnits.value)
  return value_;
}
inline void ReferenceFeeUnits::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.ReferenceFeeUnits.value)
}

// -------------------------------------------------------------------

// ReserveBase

// uint32 value = 1;
inline void ReserveBase::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ReserveBase::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.ReserveBase.value)
  return value_;
}
inline void ReserveBase::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.ReserveBase.value)
}

// -------------------------------------------------------------------

// ReserveIncrement

// uint32 value = 1;
inline void ReserveIncrement::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ReserveIncrement::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.ReserveIncrement.value)
  return value_;
}
inline void ReserveIncrement::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.ReserveIncrement.value)
}

// -------------------------------------------------------------------

// Sequence

// uint32 value = 1;
inline void Sequence::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Sequence::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Sequence.value)
  return value_;
}
inline void Sequence::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.Sequence.value)
}

// -------------------------------------------------------------------

// SetFlag

// uint32 value = 1;
inline void SetFlag::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SetFlag::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SetFlag.value)
  return value_;
}
inline void SetFlag::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.SetFlag.value)
}

// -------------------------------------------------------------------

// SettleDelay

// uint32 value = 1;
inline void SettleDelay::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SettleDelay::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SettleDelay.value)
  return value_;
}
inline void SettleDelay::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.SettleDelay.value)
}

// -------------------------------------------------------------------

// SignerListID

// uint32 value = 1;
inline void SignerListID::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SignerListID::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SignerListID.value)
  return value_;
}
inline void SignerListID::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.SignerListID.value)
}

// -------------------------------------------------------------------

// SignerQuorum

// uint32 value = 1;
inline void SignerQuorum::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SignerQuorum::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SignerQuorum.value)
  return value_;
}
inline void SignerQuorum::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.SignerQuorum.value)
}

// -------------------------------------------------------------------

// SignerWeight

// uint32 value = 1;
inline void SignerWeight::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SignerWeight::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SignerWeight.value)
  return value_;
}
inline void SignerWeight::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.SignerWeight.value)
}

// -------------------------------------------------------------------

// SourceTag

// uint32 value = 1;
inline void SourceTag::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SourceTag::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SourceTag.value)
  return value_;
}
inline void SourceTag::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.SourceTag.value)
}

// -------------------------------------------------------------------

// TickSize

// uint32 value = 1;
inline void TickSize::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TickSize::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TickSize.value)
  return value_;
}
inline void TickSize::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.TickSize.value)
}

// -------------------------------------------------------------------

// Ticket

// uint32 value = 1;
inline void Ticket::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Ticket::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Ticket.value)
  return value_;
}
inline void Ticket::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.Ticket.value)
}

// -------------------------------------------------------------------

// TicketCount

// uint32 value = 1;
inline void TicketCount::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TicketCount::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TicketCount.value)
  return value_;
}
inline void TicketCount::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.TicketCount.value)
}

// -------------------------------------------------------------------

// TicketSequence

// uint32 value = 1;
inline void TicketSequence::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TicketSequence::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TicketSequence.value)
  return value_;
}
inline void TicketSequence::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.TicketSequence.value)
}

// -------------------------------------------------------------------

// TransferRate

// uint32 value = 1;
inline void TransferRate::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransferRate::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TransferRate.value)
  return value_;
}
inline void TransferRate::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.TransferRate.value)
}

// -------------------------------------------------------------------

// BaseFee

// uint64 value = 1 [jstype = JS_STRING];
inline void BaseFee::clear_value() {
  value_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BaseFee::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.BaseFee.value)
  return value_;
}
inline void BaseFee::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.BaseFee.value)
}

// -------------------------------------------------------------------

// BookNode

// uint64 value = 1 [jstype = JS_STRING];
inline void BookNode::clear_value() {
  value_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BookNode::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.BookNode.value)
  return value_;
}
inline void BookNode::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.BookNode.value)
}

// -------------------------------------------------------------------

// DestinationNode

// uint64 value = 1 [jstype = JS_STRING];
inline void DestinationNode::clear_value() {
  value_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DestinationNode::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DestinationNode.value)
  return value_;
}
inline void DestinationNode::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.DestinationNode.value)
}

// -------------------------------------------------------------------

// HighNode

// uint64 value = 1 [jstype = JS_STRING];
inline void HighNode::clear_value() {
  value_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HighNode::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.HighNode.value)
  return value_;
}
inline void HighNode::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.HighNode.value)
}

// -------------------------------------------------------------------

// IndexNext

// uint64 value = 1 [jstype = JS_STRING];
inline void IndexNext::clear_value() {
  value_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IndexNext::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.IndexNext.value)
  return value_;
}
inline void IndexNext::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.IndexNext.value)
}

// -------------------------------------------------------------------

// IndexPrevious

// uint64 value = 1 [jstype = JS_STRING];
inline void IndexPrevious::clear_value() {
  value_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 IndexPrevious::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.IndexPrevious.value)
  return value_;
}
inline void IndexPrevious::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.IndexPrevious.value)
}

// -------------------------------------------------------------------

// LowNode

// uint64 value = 1 [jstype = JS_STRING];
inline void LowNode::clear_value() {
  value_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LowNode::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LowNode.value)
  return value_;
}
inline void LowNode::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.LowNode.value)
}

// -------------------------------------------------------------------

// OwnerNode

// uint64 value = 1 [jstype = JS_STRING];
inline void OwnerNode::clear_value() {
  value_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OwnerNode::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.OwnerNode.value)
  return value_;
}
inline void OwnerNode::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.OwnerNode.value)
}

// -------------------------------------------------------------------

// EmailHash

// bytes value = 1;
inline void EmailHash::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& EmailHash::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.EmailHash.value)
  return value_.GetNoArena();
}
inline void EmailHash::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.EmailHash.value)
}
inline void EmailHash::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.EmailHash.value)
}
inline void EmailHash::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.EmailHash.value)
}
inline void EmailHash::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.EmailHash.value)
}
inline std::string* EmailHash::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.EmailHash.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EmailHash::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.EmailHash.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EmailHash::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.EmailHash.value)
}

// -------------------------------------------------------------------

// TakerGetsIssuer

// bytes value = 1;
inline void TakerGetsIssuer::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TakerGetsIssuer::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TakerGetsIssuer.value)
  return value_.GetNoArena();
}
inline void TakerGetsIssuer::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.TakerGetsIssuer.value)
}
inline void TakerGetsIssuer::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.TakerGetsIssuer.value)
}
inline void TakerGetsIssuer::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.TakerGetsIssuer.value)
}
inline void TakerGetsIssuer::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.TakerGetsIssuer.value)
}
inline std::string* TakerGetsIssuer::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.TakerGetsIssuer.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TakerGetsIssuer::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.TakerGetsIssuer.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TakerGetsIssuer::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.TakerGetsIssuer.value)
}

// -------------------------------------------------------------------

// TakerPaysIssuer

// bytes value = 1;
inline void TakerPaysIssuer::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TakerPaysIssuer::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TakerPaysIssuer.value)
  return value_.GetNoArena();
}
inline void TakerPaysIssuer::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.TakerPaysIssuer.value)
}
inline void TakerPaysIssuer::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.TakerPaysIssuer.value)
}
inline void TakerPaysIssuer::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.TakerPaysIssuer.value)
}
inline void TakerPaysIssuer::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.TakerPaysIssuer.value)
}
inline std::string* TakerPaysIssuer::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.TakerPaysIssuer.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TakerPaysIssuer::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.TakerPaysIssuer.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TakerPaysIssuer::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.TakerPaysIssuer.value)
}

// -------------------------------------------------------------------

// AccountTransactionID

// bytes value = 1;
inline void AccountTransactionID::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AccountTransactionID::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.AccountTransactionID.value)
  return value_.GetNoArena();
}
inline void AccountTransactionID::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.AccountTransactionID.value)
}
inline void AccountTransactionID::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.AccountTransactionID.value)
}
inline void AccountTransactionID::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.AccountTransactionID.value)
}
inline void AccountTransactionID::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.AccountTransactionID.value)
}
inline std::string* AccountTransactionID::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.AccountTransactionID.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AccountTransactionID::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.AccountTransactionID.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AccountTransactionID::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.AccountTransactionID.value)
}

// -------------------------------------------------------------------

// BookDirectory

// bytes value = 1;
inline void BookDirectory::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BookDirectory::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.BookDirectory.value)
  return value_.GetNoArena();
}
inline void BookDirectory::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.BookDirectory.value)
}
inline void BookDirectory::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.BookDirectory.value)
}
inline void BookDirectory::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.BookDirectory.value)
}
inline void BookDirectory::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.BookDirectory.value)
}
inline std::string* BookDirectory::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.BookDirectory.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BookDirectory::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.BookDirectory.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BookDirectory::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.BookDirectory.value)
}

// -------------------------------------------------------------------

// Channel

// bytes value = 1;
inline void Channel::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Channel::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Channel.value)
  return value_.GetNoArena();
}
inline void Channel::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.Channel.value)
}
inline void Channel::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.Channel.value)
}
inline void Channel::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.Channel.value)
}
inline void Channel::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.Channel.value)
}
inline std::string* Channel::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Channel.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Channel::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Channel.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Channel.value)
}

// -------------------------------------------------------------------

// CheckID

// bytes value = 1;
inline void CheckID::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CheckID::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.CheckID.value)
  return value_.GetNoArena();
}
inline void CheckID::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.CheckID.value)
}
inline void CheckID::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.CheckID.value)
}
inline void CheckID::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.CheckID.value)
}
inline void CheckID::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.CheckID.value)
}
inline std::string* CheckID::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.CheckID.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CheckID::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.CheckID.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CheckID::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.CheckID.value)
}

// -------------------------------------------------------------------

// Hash

// bytes value = 1;
inline void Hash::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Hash::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Hash.value)
  return value_.GetNoArena();
}
inline void Hash::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.Hash.value)
}
inline void Hash::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.Hash.value)
}
inline void Hash::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.Hash.value)
}
inline void Hash::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.Hash.value)
}
inline std::string* Hash::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Hash.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Hash::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Hash.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Hash::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Hash.value)
}

// -------------------------------------------------------------------

// Index

// bytes value = 1;
inline void Index::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Index::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Index.value)
  return value_.GetNoArena();
}
inline void Index::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.Index.value)
}
inline void Index::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.Index.value)
}
inline void Index::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.Index.value)
}
inline void Index::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.Index.value)
}
inline std::string* Index::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Index.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Index::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Index.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Index::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Index.value)
}

// -------------------------------------------------------------------

// InvoiceID

// bytes value = 1;
inline void InvoiceID::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& InvoiceID::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.InvoiceID.value)
  return value_.GetNoArena();
}
inline void InvoiceID::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.InvoiceID.value)
}
inline void InvoiceID::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.InvoiceID.value)
}
inline void InvoiceID::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.InvoiceID.value)
}
inline void InvoiceID::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.InvoiceID.value)
}
inline std::string* InvoiceID::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.InvoiceID.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InvoiceID::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.InvoiceID.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InvoiceID::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.InvoiceID.value)
}

// -------------------------------------------------------------------

// PreviousTransactionID

// bytes value = 1;
inline void PreviousTransactionID::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PreviousTransactionID::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PreviousTransactionID.value)
  return value_.GetNoArena();
}
inline void PreviousTransactionID::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.PreviousTransactionID.value)
}
inline void PreviousTransactionID::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.PreviousTransactionID.value)
}
inline void PreviousTransactionID::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.PreviousTransactionID.value)
}
inline void PreviousTransactionID::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.PreviousTransactionID.value)
}
inline std::string* PreviousTransactionID::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PreviousTransactionID.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PreviousTransactionID::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PreviousTransactionID.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PreviousTransactionID::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PreviousTransactionID.value)
}

// -------------------------------------------------------------------

// RootIndex

// bytes value = 1;
inline void RootIndex::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RootIndex::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.RootIndex.value)
  return value_.GetNoArena();
}
inline void RootIndex::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.RootIndex.value)
}
inline void RootIndex::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.RootIndex.value)
}
inline void RootIndex::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.RootIndex.value)
}
inline void RootIndex::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.RootIndex.value)
}
inline std::string* RootIndex::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.RootIndex.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RootIndex::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.RootIndex.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RootIndex::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.RootIndex.value)
}

// -------------------------------------------------------------------

// Condition

// bytes value = 1;
inline void Condition::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Condition::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Condition.value)
  return value_.GetNoArena();
}
inline void Condition::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.Condition.value)
}
inline void Condition::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.Condition.value)
}
inline void Condition::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.Condition.value)
}
inline void Condition::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.Condition.value)
}
inline std::string* Condition::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Condition.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Condition::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Condition.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Condition::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Condition.value)
}

// -------------------------------------------------------------------

// Fulfillment

// bytes value = 1;
inline void Fulfillment::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Fulfillment::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Fulfillment.value)
  return value_.GetNoArena();
}
inline void Fulfillment::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.Fulfillment.value)
}
inline void Fulfillment::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.Fulfillment.value)
}
inline void Fulfillment::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.Fulfillment.value)
}
inline void Fulfillment::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.Fulfillment.value)
}
inline std::string* Fulfillment::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Fulfillment.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Fulfillment::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Fulfillment.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Fulfillment::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Fulfillment.value)
}

// -------------------------------------------------------------------

// MemoData

// bytes value = 1;
inline void MemoData::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MemoData::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.MemoData.value)
  return value_.GetNoArena();
}
inline void MemoData::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.MemoData.value)
}
inline void MemoData::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.MemoData.value)
}
inline void MemoData::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.MemoData.value)
}
inline void MemoData::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.MemoData.value)
}
inline std::string* MemoData::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.MemoData.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MemoData::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.MemoData.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MemoData::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.MemoData.value)
}

// -------------------------------------------------------------------

// MemoFormat

// bytes value = 1;
inline void MemoFormat::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MemoFormat::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.MemoFormat.value)
  return value_.GetNoArena();
}
inline void MemoFormat::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.MemoFormat.value)
}
inline void MemoFormat::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.MemoFormat.value)
}
inline void MemoFormat::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.MemoFormat.value)
}
inline void MemoFormat::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.MemoFormat.value)
}
inline std::string* MemoFormat::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.MemoFormat.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MemoFormat::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.MemoFormat.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MemoFormat::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.MemoFormat.value)
}

// -------------------------------------------------------------------

// MemoType

// bytes value = 1;
inline void MemoType::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MemoType::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.MemoType.value)
  return value_.GetNoArena();
}
inline void MemoType::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.MemoType.value)
}
inline void MemoType::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.MemoType.value)
}
inline void MemoType::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.MemoType.value)
}
inline void MemoType::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.MemoType.value)
}
inline std::string* MemoType::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.MemoType.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MemoType::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.MemoType.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MemoType::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.MemoType.value)
}

// -------------------------------------------------------------------

// MessageKey

// bytes value = 1;
inline void MessageKey::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MessageKey::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.MessageKey.value)
  return value_.GetNoArena();
}
inline void MessageKey::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.MessageKey.value)
}
inline void MessageKey::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.MessageKey.value)
}
inline void MessageKey::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.MessageKey.value)
}
inline void MessageKey::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.MessageKey.value)
}
inline std::string* MessageKey::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.MessageKey.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MessageKey::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.MessageKey.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MessageKey::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.MessageKey.value)
}

// -------------------------------------------------------------------

// PublicKey

// bytes value = 1;
inline void PublicKey::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PublicKey::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PublicKey.value)
  return value_.GetNoArena();
}
inline void PublicKey::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.PublicKey.value)
}
inline void PublicKey::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.PublicKey.value)
}
inline void PublicKey::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.PublicKey.value)
}
inline void PublicKey::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.PublicKey.value)
}
inline std::string* PublicKey::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PublicKey.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PublicKey::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PublicKey.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKey::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PublicKey.value)
}

// -------------------------------------------------------------------

// PaymentChannelSignature

// bytes value = 1;
inline void PaymentChannelSignature::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PaymentChannelSignature::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PaymentChannelSignature.value)
  return value_.GetNoArena();
}
inline void PaymentChannelSignature::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.PaymentChannelSignature.value)
}
inline void PaymentChannelSignature::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.PaymentChannelSignature.value)
}
inline void PaymentChannelSignature::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.PaymentChannelSignature.value)
}
inline void PaymentChannelSignature::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.PaymentChannelSignature.value)
}
inline std::string* PaymentChannelSignature::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PaymentChannelSignature.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PaymentChannelSignature::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PaymentChannelSignature.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PaymentChannelSignature::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PaymentChannelSignature.value)
}

// -------------------------------------------------------------------

// SigningPublicKey

// bytes value = 1;
inline void SigningPublicKey::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SigningPublicKey::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SigningPublicKey.value)
  return value_.GetNoArena();
}
inline void SigningPublicKey::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.SigningPublicKey.value)
}
inline void SigningPublicKey::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.SigningPublicKey.value)
}
inline void SigningPublicKey::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.SigningPublicKey.value)
}
inline void SigningPublicKey::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.SigningPublicKey.value)
}
inline std::string* SigningPublicKey::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.SigningPublicKey.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SigningPublicKey::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.SigningPublicKey.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SigningPublicKey::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.SigningPublicKey.value)
}

// -------------------------------------------------------------------

// TransactionSignature

// bytes value = 1;
inline void TransactionSignature::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TransactionSignature::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TransactionSignature.value)
  return value_.GetNoArena();
}
inline void TransactionSignature::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.TransactionSignature.value)
}
inline void TransactionSignature::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.TransactionSignature.value)
}
inline void TransactionSignature::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.TransactionSignature.value)
}
inline void TransactionSignature::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.TransactionSignature.value)
}
inline std::string* TransactionSignature::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.TransactionSignature.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TransactionSignature::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.TransactionSignature.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionSignature::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.TransactionSignature.value)
}

// -------------------------------------------------------------------

// ValidatorToDisable

// bytes value = 1;
inline void ValidatorToDisable::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ValidatorToDisable::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.ValidatorToDisable.value)
  return value_.GetNoArena();
}
inline void ValidatorToDisable::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.ValidatorToDisable.value)
}
inline void ValidatorToDisable::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.ValidatorToDisable.value)
}
inline void ValidatorToDisable::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.ValidatorToDisable.value)
}
inline void ValidatorToDisable::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.ValidatorToDisable.value)
}
inline std::string* ValidatorToDisable::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.ValidatorToDisable.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ValidatorToDisable::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.ValidatorToDisable.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ValidatorToDisable::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.ValidatorToDisable.value)
}

// -------------------------------------------------------------------

// ValidatorToReEnable

// bytes value = 1;
inline void ValidatorToReEnable::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ValidatorToReEnable::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.ValidatorToReEnable.value)
  return value_.GetNoArena();
}
inline void ValidatorToReEnable::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.ValidatorToReEnable.value)
}
inline void ValidatorToReEnable::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.ValidatorToReEnable.value)
}
inline void ValidatorToReEnable::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.ValidatorToReEnable.value)
}
inline void ValidatorToReEnable::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.ValidatorToReEnable.value)
}
inline std::string* ValidatorToReEnable::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.ValidatorToReEnable.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ValidatorToReEnable::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.ValidatorToReEnable.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ValidatorToReEnable::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.ValidatorToReEnable.value)
}

// -------------------------------------------------------------------

// TakerGetsCurreny

// .org.xrpl.rpc.v1.Currency value = 1;
inline bool TakerGetsCurreny::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Currency& TakerGetsCurreny::value() const {
  const ::org::xrpl::rpc::v1::Currency* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TakerGetsCurreny.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Currency*>(
      &::org::xrpl::rpc::v1::_Currency_default_instance_);
}
inline ::org::xrpl::rpc::v1::Currency* TakerGetsCurreny::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.TakerGetsCurreny.value)
  
  ::org::xrpl::rpc::v1::Currency* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Currency* TakerGetsCurreny::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Currency>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.TakerGetsCurreny.value)
  return value_;
}
inline void TakerGetsCurreny::set_allocated_value(::org::xrpl::rpc::v1::Currency* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.TakerGetsCurreny.value)
}

// -------------------------------------------------------------------

// TakerPaysCurrency

// .org.xrpl.rpc.v1.Currency value = 1;
inline bool TakerPaysCurrency::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Currency& TakerPaysCurrency::value() const {
  const ::org::xrpl::rpc::v1::Currency* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TakerPaysCurrency.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Currency*>(
      &::org::xrpl::rpc::v1::_Currency_default_instance_);
}
inline ::org::xrpl::rpc::v1::Currency* TakerPaysCurrency::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.TakerPaysCurrency.value)
  
  ::org::xrpl::rpc::v1::Currency* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Currency* TakerPaysCurrency::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Currency>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.TakerPaysCurrency.value)
  return value_;
}
inline void TakerPaysCurrency::set_allocated_value(::org::xrpl::rpc::v1::Currency* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.TakerPaysCurrency.value)
}

// -------------------------------------------------------------------

// Amount

// .org.xrpl.rpc.v1.CurrencyAmount value = 1;
inline bool Amount::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::CurrencyAmount& Amount::value() const {
  const ::org::xrpl::rpc::v1::CurrencyAmount* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Amount.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::CurrencyAmount*>(
      &::org::xrpl::rpc::v1::_CurrencyAmount_default_instance_);
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* Amount::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Amount.value)
  
  ::org::xrpl::rpc::v1::CurrencyAmount* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* Amount::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::CurrencyAmount>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Amount.value)
  return value_;
}
inline void Amount::set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Amount.value)
}

// -------------------------------------------------------------------

// Balance

// .org.xrpl.rpc.v1.CurrencyAmount value = 1;
inline bool Balance::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::CurrencyAmount& Balance::value() const {
  const ::org::xrpl::rpc::v1::CurrencyAmount* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Balance.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::CurrencyAmount*>(
      &::org::xrpl::rpc::v1::_CurrencyAmount_default_instance_);
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* Balance::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Balance.value)
  
  ::org::xrpl::rpc::v1::CurrencyAmount* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* Balance::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::CurrencyAmount>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Balance.value)
  return value_;
}
inline void Balance::set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Balance.value)
}

// -------------------------------------------------------------------

// DeliverMin

// .org.xrpl.rpc.v1.CurrencyAmount value = 1;
inline bool DeliverMin::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::CurrencyAmount& DeliverMin::value() const {
  const ::org::xrpl::rpc::v1::CurrencyAmount* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DeliverMin.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::CurrencyAmount*>(
      &::org::xrpl::rpc::v1::_CurrencyAmount_default_instance_);
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* DeliverMin::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DeliverMin.value)
  
  ::org::xrpl::rpc::v1::CurrencyAmount* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* DeliverMin::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::CurrencyAmount>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DeliverMin.value)
  return value_;
}
inline void DeliverMin::set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DeliverMin.value)
}

// -------------------------------------------------------------------

// DeliveredAmount

// .org.xrpl.rpc.v1.CurrencyAmount value = 1;
inline bool DeliveredAmount::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::CurrencyAmount& DeliveredAmount::value() const {
  const ::org::xrpl::rpc::v1::CurrencyAmount* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DeliveredAmount.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::CurrencyAmount*>(
      &::org::xrpl::rpc::v1::_CurrencyAmount_default_instance_);
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* DeliveredAmount::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DeliveredAmount.value)
  
  ::org::xrpl::rpc::v1::CurrencyAmount* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* DeliveredAmount::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::CurrencyAmount>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DeliveredAmount.value)
  return value_;
}
inline void DeliveredAmount::set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DeliveredAmount.value)
}

// -------------------------------------------------------------------

// HighLimit

// .org.xrpl.rpc.v1.CurrencyAmount value = 1;
inline bool HighLimit::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::CurrencyAmount& HighLimit::value() const {
  const ::org::xrpl::rpc::v1::CurrencyAmount* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.HighLimit.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::CurrencyAmount*>(
      &::org::xrpl::rpc::v1::_CurrencyAmount_default_instance_);
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* HighLimit::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.HighLimit.value)
  
  ::org::xrpl::rpc::v1::CurrencyAmount* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* HighLimit::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::CurrencyAmount>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.HighLimit.value)
  return value_;
}
inline void HighLimit::set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.HighLimit.value)
}

// -------------------------------------------------------------------

// LimitAmount

// .org.xrpl.rpc.v1.CurrencyAmount value = 1;
inline bool LimitAmount::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::CurrencyAmount& LimitAmount::value() const {
  const ::org::xrpl::rpc::v1::CurrencyAmount* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LimitAmount.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::CurrencyAmount*>(
      &::org::xrpl::rpc::v1::_CurrencyAmount_default_instance_);
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* LimitAmount::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LimitAmount.value)
  
  ::org::xrpl::rpc::v1::CurrencyAmount* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* LimitAmount::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::CurrencyAmount>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LimitAmount.value)
  return value_;
}
inline void LimitAmount::set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.LimitAmount.value)
}

// -------------------------------------------------------------------

// LowLimit

// .org.xrpl.rpc.v1.CurrencyAmount value = 1;
inline bool LowLimit::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::CurrencyAmount& LowLimit::value() const {
  const ::org::xrpl::rpc::v1::CurrencyAmount* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LowLimit.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::CurrencyAmount*>(
      &::org::xrpl::rpc::v1::_CurrencyAmount_default_instance_);
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* LowLimit::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LowLimit.value)
  
  ::org::xrpl::rpc::v1::CurrencyAmount* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* LowLimit::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::CurrencyAmount>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LowLimit.value)
  return value_;
}
inline void LowLimit::set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.LowLimit.value)
}

// -------------------------------------------------------------------

// SendMax

// .org.xrpl.rpc.v1.CurrencyAmount value = 1;
inline bool SendMax::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::CurrencyAmount& SendMax::value() const {
  const ::org::xrpl::rpc::v1::CurrencyAmount* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SendMax.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::CurrencyAmount*>(
      &::org::xrpl::rpc::v1::_CurrencyAmount_default_instance_);
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* SendMax::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.SendMax.value)
  
  ::org::xrpl::rpc::v1::CurrencyAmount* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* SendMax::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::CurrencyAmount>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.SendMax.value)
  return value_;
}
inline void SendMax::set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.SendMax.value)
}

// -------------------------------------------------------------------

// TakerGets

// .org.xrpl.rpc.v1.CurrencyAmount value = 1;
inline bool TakerGets::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::CurrencyAmount& TakerGets::value() const {
  const ::org::xrpl::rpc::v1::CurrencyAmount* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TakerGets.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::CurrencyAmount*>(
      &::org::xrpl::rpc::v1::_CurrencyAmount_default_instance_);
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* TakerGets::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.TakerGets.value)
  
  ::org::xrpl::rpc::v1::CurrencyAmount* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* TakerGets::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::CurrencyAmount>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.TakerGets.value)
  return value_;
}
inline void TakerGets::set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.TakerGets.value)
}

// -------------------------------------------------------------------

// TakerPays

// .org.xrpl.rpc.v1.CurrencyAmount value = 1;
inline bool TakerPays::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::CurrencyAmount& TakerPays::value() const {
  const ::org::xrpl::rpc::v1::CurrencyAmount* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TakerPays.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::CurrencyAmount*>(
      &::org::xrpl::rpc::v1::_CurrencyAmount_default_instance_);
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* TakerPays::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.TakerPays.value)
  
  ::org::xrpl::rpc::v1::CurrencyAmount* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::CurrencyAmount* TakerPays::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::CurrencyAmount>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.TakerPays.value)
  return value_;
}
inline void TakerPays::set_allocated_value(::org::xrpl::rpc::v1::CurrencyAmount* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.TakerPays.value)
}

// -------------------------------------------------------------------

// Account

// .org.xrpl.rpc.v1.AccountAddress value = 1;
inline bool Account::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::AccountAddress& Account::value() const {
  const ::org::xrpl::rpc::v1::AccountAddress* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Account.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::AccountAddress*>(
      &::org::xrpl::rpc::v1::_AccountAddress_default_instance_);
}
inline ::org::xrpl::rpc::v1::AccountAddress* Account::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Account.value)
  
  ::org::xrpl::rpc::v1::AccountAddress* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::AccountAddress* Account::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::AccountAddress>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Account.value)
  return value_;
}
inline void Account::set_allocated_value(::org::xrpl::rpc::v1::AccountAddress* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Account.value)
}

// -------------------------------------------------------------------

// Authorize

// .org.xrpl.rpc.v1.AccountAddress value = 1;
inline bool Authorize::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::AccountAddress& Authorize::value() const {
  const ::org::xrpl::rpc::v1::AccountAddress* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Authorize.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::AccountAddress*>(
      &::org::xrpl::rpc::v1::_AccountAddress_default_instance_);
}
inline ::org::xrpl::rpc::v1::AccountAddress* Authorize::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Authorize.value)
  
  ::org::xrpl::rpc::v1::AccountAddress* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::AccountAddress* Authorize::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::AccountAddress>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Authorize.value)
  return value_;
}
inline void Authorize::set_allocated_value(::org::xrpl::rpc::v1::AccountAddress* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Authorize.value)
}

// -------------------------------------------------------------------

// Destination

// .org.xrpl.rpc.v1.AccountAddress value = 1;
inline bool Destination::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::AccountAddress& Destination::value() const {
  const ::org::xrpl::rpc::v1::AccountAddress* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Destination.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::AccountAddress*>(
      &::org::xrpl::rpc::v1::_AccountAddress_default_instance_);
}
inline ::org::xrpl::rpc::v1::AccountAddress* Destination::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Destination.value)
  
  ::org::xrpl::rpc::v1::AccountAddress* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::AccountAddress* Destination::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::AccountAddress>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Destination.value)
  return value_;
}
inline void Destination::set_allocated_value(::org::xrpl::rpc::v1::AccountAddress* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Destination.value)
}

// -------------------------------------------------------------------

// Owner

// .org.xrpl.rpc.v1.AccountAddress value = 1;
inline bool Owner::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::AccountAddress& Owner::value() const {
  const ::org::xrpl::rpc::v1::AccountAddress* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Owner.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::AccountAddress*>(
      &::org::xrpl::rpc::v1::_AccountAddress_default_instance_);
}
inline ::org::xrpl::rpc::v1::AccountAddress* Owner::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Owner.value)
  
  ::org::xrpl::rpc::v1::AccountAddress* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::AccountAddress* Owner::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::AccountAddress>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Owner.value)
  return value_;
}
inline void Owner::set_allocated_value(::org::xrpl::rpc::v1::AccountAddress* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Owner.value)
}

// -------------------------------------------------------------------

// RegularKey

// .org.xrpl.rpc.v1.AccountAddress value = 1;
inline bool RegularKey::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::AccountAddress& RegularKey::value() const {
  const ::org::xrpl::rpc::v1::AccountAddress* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.RegularKey.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::AccountAddress*>(
      &::org::xrpl::rpc::v1::_AccountAddress_default_instance_);
}
inline ::org::xrpl::rpc::v1::AccountAddress* RegularKey::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.RegularKey.value)
  
  ::org::xrpl::rpc::v1::AccountAddress* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::AccountAddress* RegularKey::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::AccountAddress>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.RegularKey.value)
  return value_;
}
inline void RegularKey::set_allocated_value(::org::xrpl::rpc::v1::AccountAddress* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.RegularKey.value)
}

// -------------------------------------------------------------------

// Unauthorize

// .org.xrpl.rpc.v1.AccountAddress value = 1;
inline bool Unauthorize::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::AccountAddress& Unauthorize::value() const {
  const ::org::xrpl::rpc::v1::AccountAddress* p = value_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Unauthorize.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::AccountAddress*>(
      &::org::xrpl::rpc::v1::_AccountAddress_default_instance_);
}
inline ::org::xrpl::rpc::v1::AccountAddress* Unauthorize::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Unauthorize.value)
  
  ::org::xrpl::rpc::v1::AccountAddress* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::AccountAddress* Unauthorize::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::AccountAddress>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Unauthorize.value)
  return value_;
}
inline void Unauthorize::set_allocated_value(::org::xrpl::rpc::v1::AccountAddress* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Unauthorize.value)
}

// -------------------------------------------------------------------

// Domain

// string value = 1;
inline void Domain::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Domain::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Domain.value)
  return value_.GetNoArena();
}
inline void Domain::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.Domain.value)
}
inline void Domain::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.Domain.value)
}
inline void Domain::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.Domain.value)
}
inline void Domain::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.Domain.value)
}
inline std::string* Domain::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Domain.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Domain::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Domain.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Domain.value)
}

// -------------------------------------------------------------------

// SignerEntry

// .org.xrpl.rpc.v1.Account account = 1;
inline bool SignerEntry::has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline void SignerEntry::clear_account() {
  if (GetArenaNoVirtual() == nullptr && account_ != nullptr) {
    delete account_;
  }
  account_ = nullptr;
}
inline const ::org::xrpl::rpc::v1::Account& SignerEntry::account() const {
  const ::org::xrpl::rpc::v1::Account* p = account_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SignerEntry.account)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Account*>(
      &::org::xrpl::rpc::v1::_Account_default_instance_);
}
inline ::org::xrpl::rpc::v1::Account* SignerEntry::release_account() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.SignerEntry.account)
  
  ::org::xrpl::rpc::v1::Account* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Account* SignerEntry::mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Account>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.SignerEntry.account)
  return account_;
}
inline void SignerEntry::set_allocated_account(::org::xrpl::rpc::v1::Account* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete account_;
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.SignerEntry.account)
}

// .org.xrpl.rpc.v1.SignerWeight signer_weight = 2;
inline bool SignerEntry::has_signer_weight() const {
  return this != internal_default_instance() && signer_weight_ != nullptr;
}
inline void SignerEntry::clear_signer_weight() {
  if (GetArenaNoVirtual() == nullptr && signer_weight_ != nullptr) {
    delete signer_weight_;
  }
  signer_weight_ = nullptr;
}
inline const ::org::xrpl::rpc::v1::SignerWeight& SignerEntry::signer_weight() const {
  const ::org::xrpl::rpc::v1::SignerWeight* p = signer_weight_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SignerEntry.signer_weight)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::SignerWeight*>(
      &::org::xrpl::rpc::v1::_SignerWeight_default_instance_);
}
inline ::org::xrpl::rpc::v1::SignerWeight* SignerEntry::release_signer_weight() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.SignerEntry.signer_weight)
  
  ::org::xrpl::rpc::v1::SignerWeight* temp = signer_weight_;
  signer_weight_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::SignerWeight* SignerEntry::mutable_signer_weight() {
  
  if (signer_weight_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::SignerWeight>(GetArenaNoVirtual());
    signer_weight_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.SignerEntry.signer_weight)
  return signer_weight_;
}
inline void SignerEntry::set_allocated_signer_weight(::org::xrpl::rpc::v1::SignerWeight* signer_weight) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete signer_weight_;
  }
  if (signer_weight) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      signer_weight = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signer_weight, submessage_arena);
    }
    
  } else {
    
  }
  signer_weight_ = signer_weight;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.SignerEntry.signer_weight)
}

// -------------------------------------------------------------------

// DisabledValidator

// .org.xrpl.rpc.v1.PublicKey public_key = 1;
inline bool DisabledValidator::has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline void DisabledValidator::clear_public_key() {
  if (GetArenaNoVirtual() == nullptr && public_key_ != nullptr) {
    delete public_key_;
  }
  public_key_ = nullptr;
}
inline const ::org::xrpl::rpc::v1::PublicKey& DisabledValidator::public_key() const {
  const ::org::xrpl::rpc::v1::PublicKey* p = public_key_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DisabledValidator.public_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PublicKey*>(
      &::org::xrpl::rpc::v1::_PublicKey_default_instance_);
}
inline ::org::xrpl::rpc::v1::PublicKey* DisabledValidator::release_public_key() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DisabledValidator.public_key)
  
  ::org::xrpl::rpc::v1::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PublicKey* DisabledValidator::mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PublicKey>(GetArenaNoVirtual());
    public_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DisabledValidator.public_key)
  return public_key_;
}
inline void DisabledValidator::set_allocated_public_key(::org::xrpl::rpc::v1::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete public_key_;
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DisabledValidator.public_key)
}

// .org.xrpl.rpc.v1.FirstLedgerSequence ledger_sequence = 2;
inline bool DisabledValidator::has_ledger_sequence() const {
  return this != internal_default_instance() && ledger_sequence_ != nullptr;
}
inline void DisabledValidator::clear_ledger_sequence() {
  if (GetArenaNoVirtual() == nullptr && ledger_sequence_ != nullptr) {
    delete ledger_sequence_;
  }
  ledger_sequence_ = nullptr;
}
inline const ::org::xrpl::rpc::v1::FirstLedgerSequence& DisabledValidator::ledger_sequence() const {
  const ::org::xrpl::rpc::v1::FirstLedgerSequence* p = ledger_sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DisabledValidator.ledger_sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::FirstLedgerSequence*>(
      &::org::xrpl::rpc::v1::_FirstLedgerSequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::FirstLedgerSequence* DisabledValidator::release_ledger_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DisabledValidator.ledger_sequence)
  
  ::org::xrpl::rpc::v1::FirstLedgerSequence* temp = ledger_sequence_;
  ledger_sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::FirstLedgerSequence* DisabledValidator::mutable_ledger_sequence() {
  
  if (ledger_sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::FirstLedgerSequence>(GetArenaNoVirtual());
    ledger_sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DisabledValidator.ledger_sequence)
  return ledger_sequence_;
}
inline void DisabledValidator::set_allocated_ledger_sequence(::org::xrpl::rpc::v1::FirstLedgerSequence* ledger_sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ledger_sequence_;
  }
  if (ledger_sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ledger_sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ledger_sequence, submessage_arena);
    }
    
  } else {
    
  }
  ledger_sequence_ = ledger_sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DisabledValidator.ledger_sequence)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace rpc
}  // namespace xrpl
}  // namespace org

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_org_2fxrpl_2frpc_2fv1_2fcommon_2eproto
