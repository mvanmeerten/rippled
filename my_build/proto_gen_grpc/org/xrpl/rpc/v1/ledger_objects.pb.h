// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: org/xrpl/rpc/v1/ledger_objects.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "org/xrpl/rpc/v1/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
namespace org {
namespace xrpl {
namespace rpc {
namespace v1 {
class AccountRoot;
class AccountRootDefaultTypeInternal;
extern AccountRootDefaultTypeInternal _AccountRoot_default_instance_;
class Amendments;
class AmendmentsDefaultTypeInternal;
extern AmendmentsDefaultTypeInternal _Amendments_default_instance_;
class Amendments_Amendment;
class Amendments_AmendmentDefaultTypeInternal;
extern Amendments_AmendmentDefaultTypeInternal _Amendments_Amendment_default_instance_;
class Amendments_Majority;
class Amendments_MajorityDefaultTypeInternal;
extern Amendments_MajorityDefaultTypeInternal _Amendments_Majority_default_instance_;
class Check;
class CheckDefaultTypeInternal;
extern CheckDefaultTypeInternal _Check_default_instance_;
class DepositPreauthObject;
class DepositPreauthObjectDefaultTypeInternal;
extern DepositPreauthObjectDefaultTypeInternal _DepositPreauthObject_default_instance_;
class DirectoryNode;
class DirectoryNodeDefaultTypeInternal;
extern DirectoryNodeDefaultTypeInternal _DirectoryNode_default_instance_;
class Escrow;
class EscrowDefaultTypeInternal;
extern EscrowDefaultTypeInternal _Escrow_default_instance_;
class FeeSettings;
class FeeSettingsDefaultTypeInternal;
extern FeeSettingsDefaultTypeInternal _FeeSettings_default_instance_;
class LedgerHashes;
class LedgerHashesDefaultTypeInternal;
extern LedgerHashesDefaultTypeInternal _LedgerHashes_default_instance_;
class LedgerObject;
class LedgerObjectDefaultTypeInternal;
extern LedgerObjectDefaultTypeInternal _LedgerObject_default_instance_;
class NegativeUNL;
class NegativeUNLDefaultTypeInternal;
extern NegativeUNLDefaultTypeInternal _NegativeUNL_default_instance_;
class Offer;
class OfferDefaultTypeInternal;
extern OfferDefaultTypeInternal _Offer_default_instance_;
class PayChannel;
class PayChannelDefaultTypeInternal;
extern PayChannelDefaultTypeInternal _PayChannel_default_instance_;
class RippleState;
class RippleStateDefaultTypeInternal;
extern RippleStateDefaultTypeInternal _RippleState_default_instance_;
class SignerList;
class SignerListDefaultTypeInternal;
extern SignerListDefaultTypeInternal _SignerList_default_instance_;
class TicketObject;
class TicketObjectDefaultTypeInternal;
extern TicketObjectDefaultTypeInternal _TicketObject_default_instance_;
}  // namespace v1
}  // namespace rpc
}  // namespace xrpl
}  // namespace org
PROTOBUF_NAMESPACE_OPEN
template<> ::org::xrpl::rpc::v1::AccountRoot* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::AccountRoot>(Arena*);
template<> ::org::xrpl::rpc::v1::Amendments* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Amendments>(Arena*);
template<> ::org::xrpl::rpc::v1::Amendments_Amendment* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Amendments_Amendment>(Arena*);
template<> ::org::xrpl::rpc::v1::Amendments_Majority* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Amendments_Majority>(Arena*);
template<> ::org::xrpl::rpc::v1::Check* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Check>(Arena*);
template<> ::org::xrpl::rpc::v1::DepositPreauthObject* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::DepositPreauthObject>(Arena*);
template<> ::org::xrpl::rpc::v1::DirectoryNode* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::DirectoryNode>(Arena*);
template<> ::org::xrpl::rpc::v1::Escrow* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Escrow>(Arena*);
template<> ::org::xrpl::rpc::v1::FeeSettings* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::FeeSettings>(Arena*);
template<> ::org::xrpl::rpc::v1::LedgerHashes* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::LedgerHashes>(Arena*);
template<> ::org::xrpl::rpc::v1::LedgerObject* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::LedgerObject>(Arena*);
template<> ::org::xrpl::rpc::v1::NegativeUNL* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::NegativeUNL>(Arena*);
template<> ::org::xrpl::rpc::v1::Offer* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::Offer>(Arena*);
template<> ::org::xrpl::rpc::v1::PayChannel* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::PayChannel>(Arena*);
template<> ::org::xrpl::rpc::v1::RippleState* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::RippleState>(Arena*);
template<> ::org::xrpl::rpc::v1::SignerList* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::SignerList>(Arena*);
template<> ::org::xrpl::rpc::v1::TicketObject* Arena::CreateMaybeMessage<::org::xrpl::rpc::v1::TicketObject>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace org {
namespace xrpl {
namespace rpc {
namespace v1 {

enum LedgerEntryType : int {
  LEDGER_ENTRY_TYPE_UNSPECIFIED = 0,
  LEDGER_ENTRY_TYPE_ACCOUNT_ROOT = 1,
  LEDGER_ENTRY_TYPE_AMENDMENTS = 2,
  LEDGER_ENTRY_TYPE_CHECK = 3,
  LEDGER_ENTRY_TYPE_DEPOSIT_PREAUTH = 4,
  LEDGER_ENTRY_TYPE_DIRECTORY_NODE = 5,
  LEDGER_ENTRY_TYPE_ESCROW = 6,
  LEDGER_ENTRY_TYPE_FEE_SETTINGS = 7,
  LEDGER_ENTRY_TYPE_LEDGER_HASHES = 8,
  LEDGER_ENTRY_TYPE_OFFER = 9,
  LEDGER_ENTRY_TYPE_PAY_CHANNEL = 10,
  LEDGER_ENTRY_TYPE_RIPPLE_STATE = 11,
  LEDGER_ENTRY_TYPE_SIGNER_LIST = 12,
  LEDGER_ENTRY_TYPE_NEGATIVE_UNL = 13,
  LEDGER_ENTRY_TYPE_TICKET = 14,
  LedgerEntryType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LedgerEntryType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LedgerEntryType_IsValid(int value);
constexpr LedgerEntryType LedgerEntryType_MIN = LEDGER_ENTRY_TYPE_UNSPECIFIED;
constexpr LedgerEntryType LedgerEntryType_MAX = LEDGER_ENTRY_TYPE_TICKET;
constexpr int LedgerEntryType_ARRAYSIZE = LedgerEntryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LedgerEntryType_descriptor();
template<typename T>
inline const std::string& LedgerEntryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LedgerEntryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LedgerEntryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LedgerEntryType_descriptor(), enum_t_value);
}
inline bool LedgerEntryType_Parse(
    const std::string& name, LedgerEntryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LedgerEntryType>(
    LedgerEntryType_descriptor(), name, value);
}
// ===================================================================

class LedgerObject :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.LedgerObject) */ {
 public:
  LedgerObject();
  virtual ~LedgerObject();

  LedgerObject(const LedgerObject& from);
  LedgerObject(LedgerObject&& from) noexcept
    : LedgerObject() {
    *this = ::std::move(from);
  }

  inline LedgerObject& operator=(const LedgerObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline LedgerObject& operator=(LedgerObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LedgerObject& default_instance();

  enum ObjectCase {
    kAccountRoot = 1,
    kAmendments = 2,
    kCheck = 3,
    kDepositPreauth = 4,
    kDirectoryNode = 5,
    kEscrow = 6,
    kFeeSettings = 7,
    kLedgerHashes = 8,
    kOffer = 9,
    kPayChannel = 10,
    kRippleState = 11,
    kSignerList = 12,
    kNegativeUnl = 13,
    kTicket = 14,
    OBJECT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LedgerObject* internal_default_instance() {
    return reinterpret_cast<const LedgerObject*>(
               &_LedgerObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LedgerObject* other);
  friend void swap(LedgerObject& a, LedgerObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LedgerObject* New() const final {
    return CreateMaybeMessage<LedgerObject>(nullptr);
  }

  LedgerObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LedgerObject>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LedgerObject& from);
  void MergeFrom(const LedgerObject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LedgerObject* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.LedgerObject";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.AccountRoot account_root = 1;
  bool has_account_root() const;
  void clear_account_root();
  static const int kAccountRootFieldNumber = 1;
  const ::org::xrpl::rpc::v1::AccountRoot& account_root() const;
  ::org::xrpl::rpc::v1::AccountRoot* release_account_root();
  ::org::xrpl::rpc::v1::AccountRoot* mutable_account_root();
  void set_allocated_account_root(::org::xrpl::rpc::v1::AccountRoot* account_root);

  // .org.xrpl.rpc.v1.Amendments amendments = 2;
  bool has_amendments() const;
  void clear_amendments();
  static const int kAmendmentsFieldNumber = 2;
  const ::org::xrpl::rpc::v1::Amendments& amendments() const;
  ::org::xrpl::rpc::v1::Amendments* release_amendments();
  ::org::xrpl::rpc::v1::Amendments* mutable_amendments();
  void set_allocated_amendments(::org::xrpl::rpc::v1::Amendments* amendments);

  // .org.xrpl.rpc.v1.Check check = 3;
  bool has_check() const;
  void clear_check();
  static const int kCheckFieldNumber = 3;
  const ::org::xrpl::rpc::v1::Check& check() const;
  ::org::xrpl::rpc::v1::Check* release_check();
  ::org::xrpl::rpc::v1::Check* mutable_check();
  void set_allocated_check(::org::xrpl::rpc::v1::Check* check);

  // .org.xrpl.rpc.v1.DepositPreauthObject deposit_preauth = 4;
  bool has_deposit_preauth() const;
  void clear_deposit_preauth();
  static const int kDepositPreauthFieldNumber = 4;
  const ::org::xrpl::rpc::v1::DepositPreauthObject& deposit_preauth() const;
  ::org::xrpl::rpc::v1::DepositPreauthObject* release_deposit_preauth();
  ::org::xrpl::rpc::v1::DepositPreauthObject* mutable_deposit_preauth();
  void set_allocated_deposit_preauth(::org::xrpl::rpc::v1::DepositPreauthObject* deposit_preauth);

  // .org.xrpl.rpc.v1.DirectoryNode directory_node = 5;
  bool has_directory_node() const;
  void clear_directory_node();
  static const int kDirectoryNodeFieldNumber = 5;
  const ::org::xrpl::rpc::v1::DirectoryNode& directory_node() const;
  ::org::xrpl::rpc::v1::DirectoryNode* release_directory_node();
  ::org::xrpl::rpc::v1::DirectoryNode* mutable_directory_node();
  void set_allocated_directory_node(::org::xrpl::rpc::v1::DirectoryNode* directory_node);

  // .org.xrpl.rpc.v1.Escrow escrow = 6;
  bool has_escrow() const;
  void clear_escrow();
  static const int kEscrowFieldNumber = 6;
  const ::org::xrpl::rpc::v1::Escrow& escrow() const;
  ::org::xrpl::rpc::v1::Escrow* release_escrow();
  ::org::xrpl::rpc::v1::Escrow* mutable_escrow();
  void set_allocated_escrow(::org::xrpl::rpc::v1::Escrow* escrow);

  // .org.xrpl.rpc.v1.FeeSettings fee_settings = 7;
  bool has_fee_settings() const;
  void clear_fee_settings();
  static const int kFeeSettingsFieldNumber = 7;
  const ::org::xrpl::rpc::v1::FeeSettings& fee_settings() const;
  ::org::xrpl::rpc::v1::FeeSettings* release_fee_settings();
  ::org::xrpl::rpc::v1::FeeSettings* mutable_fee_settings();
  void set_allocated_fee_settings(::org::xrpl::rpc::v1::FeeSettings* fee_settings);

  // .org.xrpl.rpc.v1.LedgerHashes ledger_hashes = 8;
  bool has_ledger_hashes() const;
  void clear_ledger_hashes();
  static const int kLedgerHashesFieldNumber = 8;
  const ::org::xrpl::rpc::v1::LedgerHashes& ledger_hashes() const;
  ::org::xrpl::rpc::v1::LedgerHashes* release_ledger_hashes();
  ::org::xrpl::rpc::v1::LedgerHashes* mutable_ledger_hashes();
  void set_allocated_ledger_hashes(::org::xrpl::rpc::v1::LedgerHashes* ledger_hashes);

  // .org.xrpl.rpc.v1.Offer offer = 9;
  bool has_offer() const;
  void clear_offer();
  static const int kOfferFieldNumber = 9;
  const ::org::xrpl::rpc::v1::Offer& offer() const;
  ::org::xrpl::rpc::v1::Offer* release_offer();
  ::org::xrpl::rpc::v1::Offer* mutable_offer();
  void set_allocated_offer(::org::xrpl::rpc::v1::Offer* offer);

  // .org.xrpl.rpc.v1.PayChannel pay_channel = 10;
  bool has_pay_channel() const;
  void clear_pay_channel();
  static const int kPayChannelFieldNumber = 10;
  const ::org::xrpl::rpc::v1::PayChannel& pay_channel() const;
  ::org::xrpl::rpc::v1::PayChannel* release_pay_channel();
  ::org::xrpl::rpc::v1::PayChannel* mutable_pay_channel();
  void set_allocated_pay_channel(::org::xrpl::rpc::v1::PayChannel* pay_channel);

  // .org.xrpl.rpc.v1.RippleState ripple_state = 11;
  bool has_ripple_state() const;
  void clear_ripple_state();
  static const int kRippleStateFieldNumber = 11;
  const ::org::xrpl::rpc::v1::RippleState& ripple_state() const;
  ::org::xrpl::rpc::v1::RippleState* release_ripple_state();
  ::org::xrpl::rpc::v1::RippleState* mutable_ripple_state();
  void set_allocated_ripple_state(::org::xrpl::rpc::v1::RippleState* ripple_state);

  // .org.xrpl.rpc.v1.SignerList signer_list = 12;
  bool has_signer_list() const;
  void clear_signer_list();
  static const int kSignerListFieldNumber = 12;
  const ::org::xrpl::rpc::v1::SignerList& signer_list() const;
  ::org::xrpl::rpc::v1::SignerList* release_signer_list();
  ::org::xrpl::rpc::v1::SignerList* mutable_signer_list();
  void set_allocated_signer_list(::org::xrpl::rpc::v1::SignerList* signer_list);

  // .org.xrpl.rpc.v1.NegativeUNL negative_unl = 13;
  bool has_negative_unl() const;
  void clear_negative_unl();
  static const int kNegativeUnlFieldNumber = 13;
  const ::org::xrpl::rpc::v1::NegativeUNL& negative_unl() const;
  ::org::xrpl::rpc::v1::NegativeUNL* release_negative_unl();
  ::org::xrpl::rpc::v1::NegativeUNL* mutable_negative_unl();
  void set_allocated_negative_unl(::org::xrpl::rpc::v1::NegativeUNL* negative_unl);

  // .org.xrpl.rpc.v1.TicketObject ticket = 14;
  bool has_ticket() const;
  void clear_ticket();
  static const int kTicketFieldNumber = 14;
  const ::org::xrpl::rpc::v1::TicketObject& ticket() const;
  ::org::xrpl::rpc::v1::TicketObject* release_ticket();
  ::org::xrpl::rpc::v1::TicketObject* mutable_ticket();
  void set_allocated_ticket(::org::xrpl::rpc::v1::TicketObject* ticket);

  void clear_object();
  ObjectCase object_case() const;
  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.LedgerObject)
 private:
  class HasBitSetters;
  void set_has_account_root();
  void set_has_amendments();
  void set_has_check();
  void set_has_deposit_preauth();
  void set_has_directory_node();
  void set_has_escrow();
  void set_has_fee_settings();
  void set_has_ledger_hashes();
  void set_has_offer();
  void set_has_pay_channel();
  void set_has_ripple_state();
  void set_has_signer_list();
  void set_has_negative_unl();
  void set_has_ticket();

  inline bool has_object() const;
  inline void clear_has_object();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union ObjectUnion {
    ObjectUnion() {}
    ::org::xrpl::rpc::v1::AccountRoot* account_root_;
    ::org::xrpl::rpc::v1::Amendments* amendments_;
    ::org::xrpl::rpc::v1::Check* check_;
    ::org::xrpl::rpc::v1::DepositPreauthObject* deposit_preauth_;
    ::org::xrpl::rpc::v1::DirectoryNode* directory_node_;
    ::org::xrpl::rpc::v1::Escrow* escrow_;
    ::org::xrpl::rpc::v1::FeeSettings* fee_settings_;
    ::org::xrpl::rpc::v1::LedgerHashes* ledger_hashes_;
    ::org::xrpl::rpc::v1::Offer* offer_;
    ::org::xrpl::rpc::v1::PayChannel* pay_channel_;
    ::org::xrpl::rpc::v1::RippleState* ripple_state_;
    ::org::xrpl::rpc::v1::SignerList* signer_list_;
    ::org::xrpl::rpc::v1::NegativeUNL* negative_unl_;
    ::org::xrpl::rpc::v1::TicketObject* ticket_;
  } object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// -------------------------------------------------------------------

class AccountRoot :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.AccountRoot) */ {
 public:
  AccountRoot();
  virtual ~AccountRoot();

  AccountRoot(const AccountRoot& from);
  AccountRoot(AccountRoot&& from) noexcept
    : AccountRoot() {
    *this = ::std::move(from);
  }

  inline AccountRoot& operator=(const AccountRoot& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountRoot& operator=(AccountRoot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AccountRoot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountRoot* internal_default_instance() {
    return reinterpret_cast<const AccountRoot*>(
               &_AccountRoot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(AccountRoot* other);
  friend void swap(AccountRoot& a, AccountRoot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountRoot* New() const final {
    return CreateMaybeMessage<AccountRoot>(nullptr);
  }

  AccountRoot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountRoot>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AccountRoot& from);
  void MergeFrom(const AccountRoot& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountRoot* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.AccountRoot";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.Account account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::org::xrpl::rpc::v1::Account& account() const;
  ::org::xrpl::rpc::v1::Account* release_account();
  ::org::xrpl::rpc::v1::Account* mutable_account();
  void set_allocated_account(::org::xrpl::rpc::v1::Account* account);

  // .org.xrpl.rpc.v1.Balance balance = 2;
  bool has_balance() const;
  void clear_balance();
  static const int kBalanceFieldNumber = 2;
  const ::org::xrpl::rpc::v1::Balance& balance() const;
  ::org::xrpl::rpc::v1::Balance* release_balance();
  ::org::xrpl::rpc::v1::Balance* mutable_balance();
  void set_allocated_balance(::org::xrpl::rpc::v1::Balance* balance);

  // .org.xrpl.rpc.v1.Sequence sequence = 3;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  const ::org::xrpl::rpc::v1::Sequence& sequence() const;
  ::org::xrpl::rpc::v1::Sequence* release_sequence();
  ::org::xrpl::rpc::v1::Sequence* mutable_sequence();
  void set_allocated_sequence(::org::xrpl::rpc::v1::Sequence* sequence);

  // .org.xrpl.rpc.v1.Flags flags = 4;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 4;
  const ::org::xrpl::rpc::v1::Flags& flags() const;
  ::org::xrpl::rpc::v1::Flags* release_flags();
  ::org::xrpl::rpc::v1::Flags* mutable_flags();
  void set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags);

  // .org.xrpl.rpc.v1.OwnerCount owner_count = 5;
  bool has_owner_count() const;
  void clear_owner_count();
  static const int kOwnerCountFieldNumber = 5;
  const ::org::xrpl::rpc::v1::OwnerCount& owner_count() const;
  ::org::xrpl::rpc::v1::OwnerCount* release_owner_count();
  ::org::xrpl::rpc::v1::OwnerCount* mutable_owner_count();
  void set_allocated_owner_count(::org::xrpl::rpc::v1::OwnerCount* owner_count);

  // .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 6;
  bool has_previous_transaction_id() const;
  void clear_previous_transaction_id();
  static const int kPreviousTransactionIdFieldNumber = 6;
  const ::org::xrpl::rpc::v1::PreviousTransactionID& previous_transaction_id() const;
  ::org::xrpl::rpc::v1::PreviousTransactionID* release_previous_transaction_id();
  ::org::xrpl::rpc::v1::PreviousTransactionID* mutable_previous_transaction_id();
  void set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id);

  // .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 7;
  bool has_previous_transaction_ledger_sequence() const;
  void clear_previous_transaction_ledger_sequence();
  static const int kPreviousTransactionLedgerSequenceFieldNumber = 7;
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& previous_transaction_ledger_sequence() const;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* release_previous_transaction_ledger_sequence();
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* mutable_previous_transaction_ledger_sequence();
  void set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence);

  // .org.xrpl.rpc.v1.AccountTransactionID account_transaction_id = 8;
  bool has_account_transaction_id() const;
  void clear_account_transaction_id();
  static const int kAccountTransactionIdFieldNumber = 8;
  const ::org::xrpl::rpc::v1::AccountTransactionID& account_transaction_id() const;
  ::org::xrpl::rpc::v1::AccountTransactionID* release_account_transaction_id();
  ::org::xrpl::rpc::v1::AccountTransactionID* mutable_account_transaction_id();
  void set_allocated_account_transaction_id(::org::xrpl::rpc::v1::AccountTransactionID* account_transaction_id);

  // .org.xrpl.rpc.v1.Domain domain = 9;
  bool has_domain() const;
  void clear_domain();
  static const int kDomainFieldNumber = 9;
  const ::org::xrpl::rpc::v1::Domain& domain() const;
  ::org::xrpl::rpc::v1::Domain* release_domain();
  ::org::xrpl::rpc::v1::Domain* mutable_domain();
  void set_allocated_domain(::org::xrpl::rpc::v1::Domain* domain);

  // .org.xrpl.rpc.v1.EmailHash email_hash = 10;
  bool has_email_hash() const;
  void clear_email_hash();
  static const int kEmailHashFieldNumber = 10;
  const ::org::xrpl::rpc::v1::EmailHash& email_hash() const;
  ::org::xrpl::rpc::v1::EmailHash* release_email_hash();
  ::org::xrpl::rpc::v1::EmailHash* mutable_email_hash();
  void set_allocated_email_hash(::org::xrpl::rpc::v1::EmailHash* email_hash);

  // .org.xrpl.rpc.v1.MessageKey message_key = 11;
  bool has_message_key() const;
  void clear_message_key();
  static const int kMessageKeyFieldNumber = 11;
  const ::org::xrpl::rpc::v1::MessageKey& message_key() const;
  ::org::xrpl::rpc::v1::MessageKey* release_message_key();
  ::org::xrpl::rpc::v1::MessageKey* mutable_message_key();
  void set_allocated_message_key(::org::xrpl::rpc::v1::MessageKey* message_key);

  // .org.xrpl.rpc.v1.RegularKey regular_key = 12;
  bool has_regular_key() const;
  void clear_regular_key();
  static const int kRegularKeyFieldNumber = 12;
  const ::org::xrpl::rpc::v1::RegularKey& regular_key() const;
  ::org::xrpl::rpc::v1::RegularKey* release_regular_key();
  ::org::xrpl::rpc::v1::RegularKey* mutable_regular_key();
  void set_allocated_regular_key(::org::xrpl::rpc::v1::RegularKey* regular_key);

  // .org.xrpl.rpc.v1.TickSize tick_size = 13;
  bool has_tick_size() const;
  void clear_tick_size();
  static const int kTickSizeFieldNumber = 13;
  const ::org::xrpl::rpc::v1::TickSize& tick_size() const;
  ::org::xrpl::rpc::v1::TickSize* release_tick_size();
  ::org::xrpl::rpc::v1::TickSize* mutable_tick_size();
  void set_allocated_tick_size(::org::xrpl::rpc::v1::TickSize* tick_size);

  // .org.xrpl.rpc.v1.TransferRate transfer_rate = 14;
  bool has_transfer_rate() const;
  void clear_transfer_rate();
  static const int kTransferRateFieldNumber = 14;
  const ::org::xrpl::rpc::v1::TransferRate& transfer_rate() const;
  ::org::xrpl::rpc::v1::TransferRate* release_transfer_rate();
  ::org::xrpl::rpc::v1::TransferRate* mutable_transfer_rate();
  void set_allocated_transfer_rate(::org::xrpl::rpc::v1::TransferRate* transfer_rate);

  // .org.xrpl.rpc.v1.TicketCount ticket_count = 15;
  bool has_ticket_count() const;
  void clear_ticket_count();
  static const int kTicketCountFieldNumber = 15;
  const ::org::xrpl::rpc::v1::TicketCount& ticket_count() const;
  ::org::xrpl::rpc::v1::TicketCount* release_ticket_count();
  ::org::xrpl::rpc::v1::TicketCount* mutable_ticket_count();
  void set_allocated_ticket_count(::org::xrpl::rpc::v1::TicketCount* ticket_count);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.AccountRoot)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::Account* account_;
  ::org::xrpl::rpc::v1::Balance* balance_;
  ::org::xrpl::rpc::v1::Sequence* sequence_;
  ::org::xrpl::rpc::v1::Flags* flags_;
  ::org::xrpl::rpc::v1::OwnerCount* owner_count_;
  ::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id_;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence_;
  ::org::xrpl::rpc::v1::AccountTransactionID* account_transaction_id_;
  ::org::xrpl::rpc::v1::Domain* domain_;
  ::org::xrpl::rpc::v1::EmailHash* email_hash_;
  ::org::xrpl::rpc::v1::MessageKey* message_key_;
  ::org::xrpl::rpc::v1::RegularKey* regular_key_;
  ::org::xrpl::rpc::v1::TickSize* tick_size_;
  ::org::xrpl::rpc::v1::TransferRate* transfer_rate_;
  ::org::xrpl::rpc::v1::TicketCount* ticket_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// -------------------------------------------------------------------

class Amendments_Amendment :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Amendments.Amendment) */ {
 public:
  Amendments_Amendment();
  virtual ~Amendments_Amendment();

  Amendments_Amendment(const Amendments_Amendment& from);
  Amendments_Amendment(Amendments_Amendment&& from) noexcept
    : Amendments_Amendment() {
    *this = ::std::move(from);
  }

  inline Amendments_Amendment& operator=(const Amendments_Amendment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Amendments_Amendment& operator=(Amendments_Amendment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Amendments_Amendment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Amendments_Amendment* internal_default_instance() {
    return reinterpret_cast<const Amendments_Amendment*>(
               &_Amendments_Amendment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Amendments_Amendment* other);
  friend void swap(Amendments_Amendment& a, Amendments_Amendment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Amendments_Amendment* New() const final {
    return CreateMaybeMessage<Amendments_Amendment>(nullptr);
  }

  Amendments_Amendment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Amendments_Amendment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Amendments_Amendment& from);
  void MergeFrom(const Amendments_Amendment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Amendments_Amendment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Amendments.Amendment";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Amendments.Amendment)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// -------------------------------------------------------------------

class Amendments_Majority :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Amendments.Majority) */ {
 public:
  Amendments_Majority();
  virtual ~Amendments_Majority();

  Amendments_Majority(const Amendments_Majority& from);
  Amendments_Majority(Amendments_Majority&& from) noexcept
    : Amendments_Majority() {
    *this = ::std::move(from);
  }

  inline Amendments_Majority& operator=(const Amendments_Majority& from) {
    CopyFrom(from);
    return *this;
  }
  inline Amendments_Majority& operator=(Amendments_Majority&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Amendments_Majority& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Amendments_Majority* internal_default_instance() {
    return reinterpret_cast<const Amendments_Majority*>(
               &_Amendments_Majority_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Amendments_Majority* other);
  friend void swap(Amendments_Majority& a, Amendments_Majority& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Amendments_Majority* New() const final {
    return CreateMaybeMessage<Amendments_Majority>(nullptr);
  }

  Amendments_Majority* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Amendments_Majority>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Amendments_Majority& from);
  void MergeFrom(const Amendments_Majority& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Amendments_Majority* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Amendments.Majority";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.Amendments.Amendment amendment = 1;
  bool has_amendment() const;
  void clear_amendment();
  static const int kAmendmentFieldNumber = 1;
  const ::org::xrpl::rpc::v1::Amendments_Amendment& amendment() const;
  ::org::xrpl::rpc::v1::Amendments_Amendment* release_amendment();
  ::org::xrpl::rpc::v1::Amendments_Amendment* mutable_amendment();
  void set_allocated_amendment(::org::xrpl::rpc::v1::Amendments_Amendment* amendment);

  // .org.xrpl.rpc.v1.CloseTime close_time = 2;
  bool has_close_time() const;
  void clear_close_time();
  static const int kCloseTimeFieldNumber = 2;
  const ::org::xrpl::rpc::v1::CloseTime& close_time() const;
  ::org::xrpl::rpc::v1::CloseTime* release_close_time();
  ::org::xrpl::rpc::v1::CloseTime* mutable_close_time();
  void set_allocated_close_time(::org::xrpl::rpc::v1::CloseTime* close_time);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Amendments.Majority)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::Amendments_Amendment* amendment_;
  ::org::xrpl::rpc::v1::CloseTime* close_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// -------------------------------------------------------------------

class Amendments :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Amendments) */ {
 public:
  Amendments();
  virtual ~Amendments();

  Amendments(const Amendments& from);
  Amendments(Amendments&& from) noexcept
    : Amendments() {
    *this = ::std::move(from);
  }

  inline Amendments& operator=(const Amendments& from) {
    CopyFrom(from);
    return *this;
  }
  inline Amendments& operator=(Amendments&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Amendments& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Amendments* internal_default_instance() {
    return reinterpret_cast<const Amendments*>(
               &_Amendments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Amendments* other);
  friend void swap(Amendments& a, Amendments& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Amendments* New() const final {
    return CreateMaybeMessage<Amendments>(nullptr);
  }

  Amendments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Amendments>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Amendments& from);
  void MergeFrom(const Amendments& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Amendments* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Amendments";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Amendments_Amendment Amendment;
  typedef Amendments_Majority Majority;

  // accessors -------------------------------------------------------

  // repeated .org.xrpl.rpc.v1.Amendments.Amendment amendments = 1;
  int amendments_size() const;
  void clear_amendments();
  static const int kAmendmentsFieldNumber = 1;
  ::org::xrpl::rpc::v1::Amendments_Amendment* mutable_amendments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Amendments_Amendment >*
      mutable_amendments();
  const ::org::xrpl::rpc::v1::Amendments_Amendment& amendments(int index) const;
  ::org::xrpl::rpc::v1::Amendments_Amendment* add_amendments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Amendments_Amendment >&
      amendments() const;

  // repeated .org.xrpl.rpc.v1.Amendments.Majority majorities = 2;
  int majorities_size() const;
  void clear_majorities();
  static const int kMajoritiesFieldNumber = 2;
  ::org::xrpl::rpc::v1::Amendments_Majority* mutable_majorities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Amendments_Majority >*
      mutable_majorities();
  const ::org::xrpl::rpc::v1::Amendments_Majority& majorities(int index) const;
  ::org::xrpl::rpc::v1::Amendments_Majority* add_majorities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Amendments_Majority >&
      majorities() const;

  // .org.xrpl.rpc.v1.Flags flags = 3;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 3;
  const ::org::xrpl::rpc::v1::Flags& flags() const;
  ::org::xrpl::rpc::v1::Flags* release_flags();
  ::org::xrpl::rpc::v1::Flags* mutable_flags();
  void set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Amendments)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Amendments_Amendment > amendments_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Amendments_Majority > majorities_;
  ::org::xrpl::rpc::v1::Flags* flags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// -------------------------------------------------------------------

class Check :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Check) */ {
 public:
  Check();
  virtual ~Check();

  Check(const Check& from);
  Check(Check&& from) noexcept
    : Check() {
    *this = ::std::move(from);
  }

  inline Check& operator=(const Check& from) {
    CopyFrom(from);
    return *this;
  }
  inline Check& operator=(Check&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Check& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Check* internal_default_instance() {
    return reinterpret_cast<const Check*>(
               &_Check_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Check* other);
  friend void swap(Check& a, Check& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Check* New() const final {
    return CreateMaybeMessage<Check>(nullptr);
  }

  Check* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Check>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Check& from);
  void MergeFrom(const Check& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Check* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Check";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.Account account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::org::xrpl::rpc::v1::Account& account() const;
  ::org::xrpl::rpc::v1::Account* release_account();
  ::org::xrpl::rpc::v1::Account* mutable_account();
  void set_allocated_account(::org::xrpl::rpc::v1::Account* account);

  // .org.xrpl.rpc.v1.Destination destination = 2;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  const ::org::xrpl::rpc::v1::Destination& destination() const;
  ::org::xrpl::rpc::v1::Destination* release_destination();
  ::org::xrpl::rpc::v1::Destination* mutable_destination();
  void set_allocated_destination(::org::xrpl::rpc::v1::Destination* destination);

  // .org.xrpl.rpc.v1.Flags flags = 3;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 3;
  const ::org::xrpl::rpc::v1::Flags& flags() const;
  ::org::xrpl::rpc::v1::Flags* release_flags();
  ::org::xrpl::rpc::v1::Flags* mutable_flags();
  void set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags);

  // .org.xrpl.rpc.v1.OwnerNode owner_node = 4;
  bool has_owner_node() const;
  void clear_owner_node();
  static const int kOwnerNodeFieldNumber = 4;
  const ::org::xrpl::rpc::v1::OwnerNode& owner_node() const;
  ::org::xrpl::rpc::v1::OwnerNode* release_owner_node();
  ::org::xrpl::rpc::v1::OwnerNode* mutable_owner_node();
  void set_allocated_owner_node(::org::xrpl::rpc::v1::OwnerNode* owner_node);

  // .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 5;
  bool has_previous_transaction_id() const;
  void clear_previous_transaction_id();
  static const int kPreviousTransactionIdFieldNumber = 5;
  const ::org::xrpl::rpc::v1::PreviousTransactionID& previous_transaction_id() const;
  ::org::xrpl::rpc::v1::PreviousTransactionID* release_previous_transaction_id();
  ::org::xrpl::rpc::v1::PreviousTransactionID* mutable_previous_transaction_id();
  void set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id);

  // .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 6;
  bool has_previous_transaction_ledger_sequence() const;
  void clear_previous_transaction_ledger_sequence();
  static const int kPreviousTransactionLedgerSequenceFieldNumber = 6;
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& previous_transaction_ledger_sequence() const;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* release_previous_transaction_ledger_sequence();
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* mutable_previous_transaction_ledger_sequence();
  void set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence);

  // .org.xrpl.rpc.v1.SendMax send_max = 7;
  bool has_send_max() const;
  void clear_send_max();
  static const int kSendMaxFieldNumber = 7;
  const ::org::xrpl::rpc::v1::SendMax& send_max() const;
  ::org::xrpl::rpc::v1::SendMax* release_send_max();
  ::org::xrpl::rpc::v1::SendMax* mutable_send_max();
  void set_allocated_send_max(::org::xrpl::rpc::v1::SendMax* send_max);

  // .org.xrpl.rpc.v1.Sequence sequence = 8;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 8;
  const ::org::xrpl::rpc::v1::Sequence& sequence() const;
  ::org::xrpl::rpc::v1::Sequence* release_sequence();
  ::org::xrpl::rpc::v1::Sequence* mutable_sequence();
  void set_allocated_sequence(::org::xrpl::rpc::v1::Sequence* sequence);

  // .org.xrpl.rpc.v1.DestinationNode destination_node = 9;
  bool has_destination_node() const;
  void clear_destination_node();
  static const int kDestinationNodeFieldNumber = 9;
  const ::org::xrpl::rpc::v1::DestinationNode& destination_node() const;
  ::org::xrpl::rpc::v1::DestinationNode* release_destination_node();
  ::org::xrpl::rpc::v1::DestinationNode* mutable_destination_node();
  void set_allocated_destination_node(::org::xrpl::rpc::v1::DestinationNode* destination_node);

  // .org.xrpl.rpc.v1.DestinationTag destination_tag = 10;
  bool has_destination_tag() const;
  void clear_destination_tag();
  static const int kDestinationTagFieldNumber = 10;
  const ::org::xrpl::rpc::v1::DestinationTag& destination_tag() const;
  ::org::xrpl::rpc::v1::DestinationTag* release_destination_tag();
  ::org::xrpl::rpc::v1::DestinationTag* mutable_destination_tag();
  void set_allocated_destination_tag(::org::xrpl::rpc::v1::DestinationTag* destination_tag);

  // .org.xrpl.rpc.v1.Expiration expiration = 11;
  bool has_expiration() const;
  void clear_expiration();
  static const int kExpirationFieldNumber = 11;
  const ::org::xrpl::rpc::v1::Expiration& expiration() const;
  ::org::xrpl::rpc::v1::Expiration* release_expiration();
  ::org::xrpl::rpc::v1::Expiration* mutable_expiration();
  void set_allocated_expiration(::org::xrpl::rpc::v1::Expiration* expiration);

  // .org.xrpl.rpc.v1.InvoiceID invoice_id = 12;
  bool has_invoice_id() const;
  void clear_invoice_id();
  static const int kInvoiceIdFieldNumber = 12;
  const ::org::xrpl::rpc::v1::InvoiceID& invoice_id() const;
  ::org::xrpl::rpc::v1::InvoiceID* release_invoice_id();
  ::org::xrpl::rpc::v1::InvoiceID* mutable_invoice_id();
  void set_allocated_invoice_id(::org::xrpl::rpc::v1::InvoiceID* invoice_id);

  // .org.xrpl.rpc.v1.SourceTag source_tag = 13;
  bool has_source_tag() const;
  void clear_source_tag();
  static const int kSourceTagFieldNumber = 13;
  const ::org::xrpl::rpc::v1::SourceTag& source_tag() const;
  ::org::xrpl::rpc::v1::SourceTag* release_source_tag();
  ::org::xrpl::rpc::v1::SourceTag* mutable_source_tag();
  void set_allocated_source_tag(::org::xrpl::rpc::v1::SourceTag* source_tag);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Check)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::Account* account_;
  ::org::xrpl::rpc::v1::Destination* destination_;
  ::org::xrpl::rpc::v1::Flags* flags_;
  ::org::xrpl::rpc::v1::OwnerNode* owner_node_;
  ::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id_;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence_;
  ::org::xrpl::rpc::v1::SendMax* send_max_;
  ::org::xrpl::rpc::v1::Sequence* sequence_;
  ::org::xrpl::rpc::v1::DestinationNode* destination_node_;
  ::org::xrpl::rpc::v1::DestinationTag* destination_tag_;
  ::org::xrpl::rpc::v1::Expiration* expiration_;
  ::org::xrpl::rpc::v1::InvoiceID* invoice_id_;
  ::org::xrpl::rpc::v1::SourceTag* source_tag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// -------------------------------------------------------------------

class DepositPreauthObject :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.DepositPreauthObject) */ {
 public:
  DepositPreauthObject();
  virtual ~DepositPreauthObject();

  DepositPreauthObject(const DepositPreauthObject& from);
  DepositPreauthObject(DepositPreauthObject&& from) noexcept
    : DepositPreauthObject() {
    *this = ::std::move(from);
  }

  inline DepositPreauthObject& operator=(const DepositPreauthObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline DepositPreauthObject& operator=(DepositPreauthObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DepositPreauthObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DepositPreauthObject* internal_default_instance() {
    return reinterpret_cast<const DepositPreauthObject*>(
               &_DepositPreauthObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(DepositPreauthObject* other);
  friend void swap(DepositPreauthObject& a, DepositPreauthObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DepositPreauthObject* New() const final {
    return CreateMaybeMessage<DepositPreauthObject>(nullptr);
  }

  DepositPreauthObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DepositPreauthObject>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DepositPreauthObject& from);
  void MergeFrom(const DepositPreauthObject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DepositPreauthObject* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.DepositPreauthObject";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.Account account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::org::xrpl::rpc::v1::Account& account() const;
  ::org::xrpl::rpc::v1::Account* release_account();
  ::org::xrpl::rpc::v1::Account* mutable_account();
  void set_allocated_account(::org::xrpl::rpc::v1::Account* account);

  // .org.xrpl.rpc.v1.Authorize authorize = 2;
  bool has_authorize() const;
  void clear_authorize();
  static const int kAuthorizeFieldNumber = 2;
  const ::org::xrpl::rpc::v1::Authorize& authorize() const;
  ::org::xrpl::rpc::v1::Authorize* release_authorize();
  ::org::xrpl::rpc::v1::Authorize* mutable_authorize();
  void set_allocated_authorize(::org::xrpl::rpc::v1::Authorize* authorize);

  // .org.xrpl.rpc.v1.Flags flags = 3;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 3;
  const ::org::xrpl::rpc::v1::Flags& flags() const;
  ::org::xrpl::rpc::v1::Flags* release_flags();
  ::org::xrpl::rpc::v1::Flags* mutable_flags();
  void set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags);

  // .org.xrpl.rpc.v1.OwnerNode owner_node = 4;
  bool has_owner_node() const;
  void clear_owner_node();
  static const int kOwnerNodeFieldNumber = 4;
  const ::org::xrpl::rpc::v1::OwnerNode& owner_node() const;
  ::org::xrpl::rpc::v1::OwnerNode* release_owner_node();
  ::org::xrpl::rpc::v1::OwnerNode* mutable_owner_node();
  void set_allocated_owner_node(::org::xrpl::rpc::v1::OwnerNode* owner_node);

  // .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 5;
  bool has_previous_transaction_id() const;
  void clear_previous_transaction_id();
  static const int kPreviousTransactionIdFieldNumber = 5;
  const ::org::xrpl::rpc::v1::PreviousTransactionID& previous_transaction_id() const;
  ::org::xrpl::rpc::v1::PreviousTransactionID* release_previous_transaction_id();
  ::org::xrpl::rpc::v1::PreviousTransactionID* mutable_previous_transaction_id();
  void set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id);

  // .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 6;
  bool has_previous_transaction_ledger_sequence() const;
  void clear_previous_transaction_ledger_sequence();
  static const int kPreviousTransactionLedgerSequenceFieldNumber = 6;
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& previous_transaction_ledger_sequence() const;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* release_previous_transaction_ledger_sequence();
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* mutable_previous_transaction_ledger_sequence();
  void set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.DepositPreauthObject)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::Account* account_;
  ::org::xrpl::rpc::v1::Authorize* authorize_;
  ::org::xrpl::rpc::v1::Flags* flags_;
  ::org::xrpl::rpc::v1::OwnerNode* owner_node_;
  ::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id_;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// -------------------------------------------------------------------

class DirectoryNode :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.DirectoryNode) */ {
 public:
  DirectoryNode();
  virtual ~DirectoryNode();

  DirectoryNode(const DirectoryNode& from);
  DirectoryNode(DirectoryNode&& from) noexcept
    : DirectoryNode() {
    *this = ::std::move(from);
  }

  inline DirectoryNode& operator=(const DirectoryNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectoryNode& operator=(DirectoryNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DirectoryNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectoryNode* internal_default_instance() {
    return reinterpret_cast<const DirectoryNode*>(
               &_DirectoryNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(DirectoryNode* other);
  friend void swap(DirectoryNode& a, DirectoryNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectoryNode* New() const final {
    return CreateMaybeMessage<DirectoryNode>(nullptr);
  }

  DirectoryNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectoryNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DirectoryNode& from);
  void MergeFrom(const DirectoryNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectoryNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.DirectoryNode";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .org.xrpl.rpc.v1.Index indexes = 3;
  int indexes_size() const;
  void clear_indexes();
  static const int kIndexesFieldNumber = 3;
  ::org::xrpl::rpc::v1::Index* mutable_indexes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Index >*
      mutable_indexes();
  const ::org::xrpl::rpc::v1::Index& indexes(int index) const;
  ::org::xrpl::rpc::v1::Index* add_indexes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Index >&
      indexes() const;

  // .org.xrpl.rpc.v1.Flags flags = 1;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 1;
  const ::org::xrpl::rpc::v1::Flags& flags() const;
  ::org::xrpl::rpc::v1::Flags* release_flags();
  ::org::xrpl::rpc::v1::Flags* mutable_flags();
  void set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags);

  // .org.xrpl.rpc.v1.RootIndex root_index = 2;
  bool has_root_index() const;
  void clear_root_index();
  static const int kRootIndexFieldNumber = 2;
  const ::org::xrpl::rpc::v1::RootIndex& root_index() const;
  ::org::xrpl::rpc::v1::RootIndex* release_root_index();
  ::org::xrpl::rpc::v1::RootIndex* mutable_root_index();
  void set_allocated_root_index(::org::xrpl::rpc::v1::RootIndex* root_index);

  // .org.xrpl.rpc.v1.IndexNext index_next = 4;
  bool has_index_next() const;
  void clear_index_next();
  static const int kIndexNextFieldNumber = 4;
  const ::org::xrpl::rpc::v1::IndexNext& index_next() const;
  ::org::xrpl::rpc::v1::IndexNext* release_index_next();
  ::org::xrpl::rpc::v1::IndexNext* mutable_index_next();
  void set_allocated_index_next(::org::xrpl::rpc::v1::IndexNext* index_next);

  // .org.xrpl.rpc.v1.IndexPrevious index_previous = 5;
  bool has_index_previous() const;
  void clear_index_previous();
  static const int kIndexPreviousFieldNumber = 5;
  const ::org::xrpl::rpc::v1::IndexPrevious& index_previous() const;
  ::org::xrpl::rpc::v1::IndexPrevious* release_index_previous();
  ::org::xrpl::rpc::v1::IndexPrevious* mutable_index_previous();
  void set_allocated_index_previous(::org::xrpl::rpc::v1::IndexPrevious* index_previous);

  // .org.xrpl.rpc.v1.Owner owner = 6;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 6;
  const ::org::xrpl::rpc::v1::Owner& owner() const;
  ::org::xrpl::rpc::v1::Owner* release_owner();
  ::org::xrpl::rpc::v1::Owner* mutable_owner();
  void set_allocated_owner(::org::xrpl::rpc::v1::Owner* owner);

  // .org.xrpl.rpc.v1.TakerPaysCurrency taker_pays_currency = 7;
  bool has_taker_pays_currency() const;
  void clear_taker_pays_currency();
  static const int kTakerPaysCurrencyFieldNumber = 7;
  const ::org::xrpl::rpc::v1::TakerPaysCurrency& taker_pays_currency() const;
  ::org::xrpl::rpc::v1::TakerPaysCurrency* release_taker_pays_currency();
  ::org::xrpl::rpc::v1::TakerPaysCurrency* mutable_taker_pays_currency();
  void set_allocated_taker_pays_currency(::org::xrpl::rpc::v1::TakerPaysCurrency* taker_pays_currency);

  // .org.xrpl.rpc.v1.TakerPaysIssuer taker_pays_issuer = 8;
  bool has_taker_pays_issuer() const;
  void clear_taker_pays_issuer();
  static const int kTakerPaysIssuerFieldNumber = 8;
  const ::org::xrpl::rpc::v1::TakerPaysIssuer& taker_pays_issuer() const;
  ::org::xrpl::rpc::v1::TakerPaysIssuer* release_taker_pays_issuer();
  ::org::xrpl::rpc::v1::TakerPaysIssuer* mutable_taker_pays_issuer();
  void set_allocated_taker_pays_issuer(::org::xrpl::rpc::v1::TakerPaysIssuer* taker_pays_issuer);

  // .org.xrpl.rpc.v1.TakerGetsCurreny taker_gets_currency = 9;
  bool has_taker_gets_currency() const;
  void clear_taker_gets_currency();
  static const int kTakerGetsCurrencyFieldNumber = 9;
  const ::org::xrpl::rpc::v1::TakerGetsCurreny& taker_gets_currency() const;
  ::org::xrpl::rpc::v1::TakerGetsCurreny* release_taker_gets_currency();
  ::org::xrpl::rpc::v1::TakerGetsCurreny* mutable_taker_gets_currency();
  void set_allocated_taker_gets_currency(::org::xrpl::rpc::v1::TakerGetsCurreny* taker_gets_currency);

  // .org.xrpl.rpc.v1.TakerGetsIssuer taker_gets_issuer = 10;
  bool has_taker_gets_issuer() const;
  void clear_taker_gets_issuer();
  static const int kTakerGetsIssuerFieldNumber = 10;
  const ::org::xrpl::rpc::v1::TakerGetsIssuer& taker_gets_issuer() const;
  ::org::xrpl::rpc::v1::TakerGetsIssuer* release_taker_gets_issuer();
  ::org::xrpl::rpc::v1::TakerGetsIssuer* mutable_taker_gets_issuer();
  void set_allocated_taker_gets_issuer(::org::xrpl::rpc::v1::TakerGetsIssuer* taker_gets_issuer);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.DirectoryNode)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Index > indexes_;
  ::org::xrpl::rpc::v1::Flags* flags_;
  ::org::xrpl::rpc::v1::RootIndex* root_index_;
  ::org::xrpl::rpc::v1::IndexNext* index_next_;
  ::org::xrpl::rpc::v1::IndexPrevious* index_previous_;
  ::org::xrpl::rpc::v1::Owner* owner_;
  ::org::xrpl::rpc::v1::TakerPaysCurrency* taker_pays_currency_;
  ::org::xrpl::rpc::v1::TakerPaysIssuer* taker_pays_issuer_;
  ::org::xrpl::rpc::v1::TakerGetsCurreny* taker_gets_currency_;
  ::org::xrpl::rpc::v1::TakerGetsIssuer* taker_gets_issuer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// -------------------------------------------------------------------

class Escrow :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Escrow) */ {
 public:
  Escrow();
  virtual ~Escrow();

  Escrow(const Escrow& from);
  Escrow(Escrow&& from) noexcept
    : Escrow() {
    *this = ::std::move(from);
  }

  inline Escrow& operator=(const Escrow& from) {
    CopyFrom(from);
    return *this;
  }
  inline Escrow& operator=(Escrow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Escrow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Escrow* internal_default_instance() {
    return reinterpret_cast<const Escrow*>(
               &_Escrow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Escrow* other);
  friend void swap(Escrow& a, Escrow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Escrow* New() const final {
    return CreateMaybeMessage<Escrow>(nullptr);
  }

  Escrow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Escrow>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Escrow& from);
  void MergeFrom(const Escrow& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Escrow* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Escrow";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.Account account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::org::xrpl::rpc::v1::Account& account() const;
  ::org::xrpl::rpc::v1::Account* release_account();
  ::org::xrpl::rpc::v1::Account* mutable_account();
  void set_allocated_account(::org::xrpl::rpc::v1::Account* account);

  // .org.xrpl.rpc.v1.Destination destination = 2;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  const ::org::xrpl::rpc::v1::Destination& destination() const;
  ::org::xrpl::rpc::v1::Destination* release_destination();
  ::org::xrpl::rpc::v1::Destination* mutable_destination();
  void set_allocated_destination(::org::xrpl::rpc::v1::Destination* destination);

  // .org.xrpl.rpc.v1.Amount amount = 3;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  const ::org::xrpl::rpc::v1::Amount& amount() const;
  ::org::xrpl::rpc::v1::Amount* release_amount();
  ::org::xrpl::rpc::v1::Amount* mutable_amount();
  void set_allocated_amount(::org::xrpl::rpc::v1::Amount* amount);

  // .org.xrpl.rpc.v1.Condition condition = 4;
  bool has_condition() const;
  void clear_condition();
  static const int kConditionFieldNumber = 4;
  const ::org::xrpl::rpc::v1::Condition& condition() const;
  ::org::xrpl::rpc::v1::Condition* release_condition();
  ::org::xrpl::rpc::v1::Condition* mutable_condition();
  void set_allocated_condition(::org::xrpl::rpc::v1::Condition* condition);

  // .org.xrpl.rpc.v1.CancelAfter cancel_after = 5;
  bool has_cancel_after() const;
  void clear_cancel_after();
  static const int kCancelAfterFieldNumber = 5;
  const ::org::xrpl::rpc::v1::CancelAfter& cancel_after() const;
  ::org::xrpl::rpc::v1::CancelAfter* release_cancel_after();
  ::org::xrpl::rpc::v1::CancelAfter* mutable_cancel_after();
  void set_allocated_cancel_after(::org::xrpl::rpc::v1::CancelAfter* cancel_after);

  // .org.xrpl.rpc.v1.FinishAfter finish_after = 6;
  bool has_finish_after() const;
  void clear_finish_after();
  static const int kFinishAfterFieldNumber = 6;
  const ::org::xrpl::rpc::v1::FinishAfter& finish_after() const;
  ::org::xrpl::rpc::v1::FinishAfter* release_finish_after();
  ::org::xrpl::rpc::v1::FinishAfter* mutable_finish_after();
  void set_allocated_finish_after(::org::xrpl::rpc::v1::FinishAfter* finish_after);

  // .org.xrpl.rpc.v1.Flags flags = 7;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 7;
  const ::org::xrpl::rpc::v1::Flags& flags() const;
  ::org::xrpl::rpc::v1::Flags* release_flags();
  ::org::xrpl::rpc::v1::Flags* mutable_flags();
  void set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags);

  // .org.xrpl.rpc.v1.SourceTag source_tag = 8;
  bool has_source_tag() const;
  void clear_source_tag();
  static const int kSourceTagFieldNumber = 8;
  const ::org::xrpl::rpc::v1::SourceTag& source_tag() const;
  ::org::xrpl::rpc::v1::SourceTag* release_source_tag();
  ::org::xrpl::rpc::v1::SourceTag* mutable_source_tag();
  void set_allocated_source_tag(::org::xrpl::rpc::v1::SourceTag* source_tag);

  // .org.xrpl.rpc.v1.DestinationTag destination_tag = 9;
  bool has_destination_tag() const;
  void clear_destination_tag();
  static const int kDestinationTagFieldNumber = 9;
  const ::org::xrpl::rpc::v1::DestinationTag& destination_tag() const;
  ::org::xrpl::rpc::v1::DestinationTag* release_destination_tag();
  ::org::xrpl::rpc::v1::DestinationTag* mutable_destination_tag();
  void set_allocated_destination_tag(::org::xrpl::rpc::v1::DestinationTag* destination_tag);

  // .org.xrpl.rpc.v1.OwnerNode owner_node = 10;
  bool has_owner_node() const;
  void clear_owner_node();
  static const int kOwnerNodeFieldNumber = 10;
  const ::org::xrpl::rpc::v1::OwnerNode& owner_node() const;
  ::org::xrpl::rpc::v1::OwnerNode* release_owner_node();
  ::org::xrpl::rpc::v1::OwnerNode* mutable_owner_node();
  void set_allocated_owner_node(::org::xrpl::rpc::v1::OwnerNode* owner_node);

  // .org.xrpl.rpc.v1.DestinationNode destination_node = 11;
  bool has_destination_node() const;
  void clear_destination_node();
  static const int kDestinationNodeFieldNumber = 11;
  const ::org::xrpl::rpc::v1::DestinationNode& destination_node() const;
  ::org::xrpl::rpc::v1::DestinationNode* release_destination_node();
  ::org::xrpl::rpc::v1::DestinationNode* mutable_destination_node();
  void set_allocated_destination_node(::org::xrpl::rpc::v1::DestinationNode* destination_node);

  // .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 12;
  bool has_previous_transaction_id() const;
  void clear_previous_transaction_id();
  static const int kPreviousTransactionIdFieldNumber = 12;
  const ::org::xrpl::rpc::v1::PreviousTransactionID& previous_transaction_id() const;
  ::org::xrpl::rpc::v1::PreviousTransactionID* release_previous_transaction_id();
  ::org::xrpl::rpc::v1::PreviousTransactionID* mutable_previous_transaction_id();
  void set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id);

  // .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 13;
  bool has_previous_transaction_ledger_sequence() const;
  void clear_previous_transaction_ledger_sequence();
  static const int kPreviousTransactionLedgerSequenceFieldNumber = 13;
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& previous_transaction_ledger_sequence() const;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* release_previous_transaction_ledger_sequence();
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* mutable_previous_transaction_ledger_sequence();
  void set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Escrow)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::Account* account_;
  ::org::xrpl::rpc::v1::Destination* destination_;
  ::org::xrpl::rpc::v1::Amount* amount_;
  ::org::xrpl::rpc::v1::Condition* condition_;
  ::org::xrpl::rpc::v1::CancelAfter* cancel_after_;
  ::org::xrpl::rpc::v1::FinishAfter* finish_after_;
  ::org::xrpl::rpc::v1::Flags* flags_;
  ::org::xrpl::rpc::v1::SourceTag* source_tag_;
  ::org::xrpl::rpc::v1::DestinationTag* destination_tag_;
  ::org::xrpl::rpc::v1::OwnerNode* owner_node_;
  ::org::xrpl::rpc::v1::DestinationNode* destination_node_;
  ::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id_;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// -------------------------------------------------------------------

class FeeSettings :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.FeeSettings) */ {
 public:
  FeeSettings();
  virtual ~FeeSettings();

  FeeSettings(const FeeSettings& from);
  FeeSettings(FeeSettings&& from) noexcept
    : FeeSettings() {
    *this = ::std::move(from);
  }

  inline FeeSettings& operator=(const FeeSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeeSettings& operator=(FeeSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FeeSettings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeeSettings* internal_default_instance() {
    return reinterpret_cast<const FeeSettings*>(
               &_FeeSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(FeeSettings* other);
  friend void swap(FeeSettings& a, FeeSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FeeSettings* New() const final {
    return CreateMaybeMessage<FeeSettings>(nullptr);
  }

  FeeSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FeeSettings>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FeeSettings& from);
  void MergeFrom(const FeeSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeeSettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.FeeSettings";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.BaseFee base_fee = 1;
  bool has_base_fee() const;
  void clear_base_fee();
  static const int kBaseFeeFieldNumber = 1;
  const ::org::xrpl::rpc::v1::BaseFee& base_fee() const;
  ::org::xrpl::rpc::v1::BaseFee* release_base_fee();
  ::org::xrpl::rpc::v1::BaseFee* mutable_base_fee();
  void set_allocated_base_fee(::org::xrpl::rpc::v1::BaseFee* base_fee);

  // .org.xrpl.rpc.v1.ReferenceFeeUnits reference_fee_units = 2;
  bool has_reference_fee_units() const;
  void clear_reference_fee_units();
  static const int kReferenceFeeUnitsFieldNumber = 2;
  const ::org::xrpl::rpc::v1::ReferenceFeeUnits& reference_fee_units() const;
  ::org::xrpl::rpc::v1::ReferenceFeeUnits* release_reference_fee_units();
  ::org::xrpl::rpc::v1::ReferenceFeeUnits* mutable_reference_fee_units();
  void set_allocated_reference_fee_units(::org::xrpl::rpc::v1::ReferenceFeeUnits* reference_fee_units);

  // .org.xrpl.rpc.v1.ReserveBase reserve_base = 3;
  bool has_reserve_base() const;
  void clear_reserve_base();
  static const int kReserveBaseFieldNumber = 3;
  const ::org::xrpl::rpc::v1::ReserveBase& reserve_base() const;
  ::org::xrpl::rpc::v1::ReserveBase* release_reserve_base();
  ::org::xrpl::rpc::v1::ReserveBase* mutable_reserve_base();
  void set_allocated_reserve_base(::org::xrpl::rpc::v1::ReserveBase* reserve_base);

  // .org.xrpl.rpc.v1.ReserveIncrement reserve_increment = 4;
  bool has_reserve_increment() const;
  void clear_reserve_increment();
  static const int kReserveIncrementFieldNumber = 4;
  const ::org::xrpl::rpc::v1::ReserveIncrement& reserve_increment() const;
  ::org::xrpl::rpc::v1::ReserveIncrement* release_reserve_increment();
  ::org::xrpl::rpc::v1::ReserveIncrement* mutable_reserve_increment();
  void set_allocated_reserve_increment(::org::xrpl::rpc::v1::ReserveIncrement* reserve_increment);

  // .org.xrpl.rpc.v1.Flags flags = 5;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 5;
  const ::org::xrpl::rpc::v1::Flags& flags() const;
  ::org::xrpl::rpc::v1::Flags* release_flags();
  ::org::xrpl::rpc::v1::Flags* mutable_flags();
  void set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.FeeSettings)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::BaseFee* base_fee_;
  ::org::xrpl::rpc::v1::ReferenceFeeUnits* reference_fee_units_;
  ::org::xrpl::rpc::v1::ReserveBase* reserve_base_;
  ::org::xrpl::rpc::v1::ReserveIncrement* reserve_increment_;
  ::org::xrpl::rpc::v1::Flags* flags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// -------------------------------------------------------------------

class LedgerHashes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.LedgerHashes) */ {
 public:
  LedgerHashes();
  virtual ~LedgerHashes();

  LedgerHashes(const LedgerHashes& from);
  LedgerHashes(LedgerHashes&& from) noexcept
    : LedgerHashes() {
    *this = ::std::move(from);
  }

  inline LedgerHashes& operator=(const LedgerHashes& from) {
    CopyFrom(from);
    return *this;
  }
  inline LedgerHashes& operator=(LedgerHashes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LedgerHashes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LedgerHashes* internal_default_instance() {
    return reinterpret_cast<const LedgerHashes*>(
               &_LedgerHashes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(LedgerHashes* other);
  friend void swap(LedgerHashes& a, LedgerHashes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LedgerHashes* New() const final {
    return CreateMaybeMessage<LedgerHashes>(nullptr);
  }

  LedgerHashes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LedgerHashes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LedgerHashes& from);
  void MergeFrom(const LedgerHashes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LedgerHashes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.LedgerHashes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .org.xrpl.rpc.v1.Hash hashes = 2;
  int hashes_size() const;
  void clear_hashes();
  static const int kHashesFieldNumber = 2;
  ::org::xrpl::rpc::v1::Hash* mutable_hashes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Hash >*
      mutable_hashes();
  const ::org::xrpl::rpc::v1::Hash& hashes(int index) const;
  ::org::xrpl::rpc::v1::Hash* add_hashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Hash >&
      hashes() const;

  // .org.xrpl.rpc.v1.LastLedgerSequence last_ledger_sequence = 1;
  bool has_last_ledger_sequence() const;
  void clear_last_ledger_sequence();
  static const int kLastLedgerSequenceFieldNumber = 1;
  const ::org::xrpl::rpc::v1::LastLedgerSequence& last_ledger_sequence() const;
  ::org::xrpl::rpc::v1::LastLedgerSequence* release_last_ledger_sequence();
  ::org::xrpl::rpc::v1::LastLedgerSequence* mutable_last_ledger_sequence();
  void set_allocated_last_ledger_sequence(::org::xrpl::rpc::v1::LastLedgerSequence* last_ledger_sequence);

  // .org.xrpl.rpc.v1.Flags flags = 3;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 3;
  const ::org::xrpl::rpc::v1::Flags& flags() const;
  ::org::xrpl::rpc::v1::Flags* release_flags();
  ::org::xrpl::rpc::v1::Flags* mutable_flags();
  void set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.LedgerHashes)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Hash > hashes_;
  ::org::xrpl::rpc::v1::LastLedgerSequence* last_ledger_sequence_;
  ::org::xrpl::rpc::v1::Flags* flags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// -------------------------------------------------------------------

class Offer :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.Offer) */ {
 public:
  Offer();
  virtual ~Offer();

  Offer(const Offer& from);
  Offer(Offer&& from) noexcept
    : Offer() {
    *this = ::std::move(from);
  }

  inline Offer& operator=(const Offer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Offer& operator=(Offer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Offer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Offer* internal_default_instance() {
    return reinterpret_cast<const Offer*>(
               &_Offer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Offer* other);
  friend void swap(Offer& a, Offer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Offer* New() const final {
    return CreateMaybeMessage<Offer>(nullptr);
  }

  Offer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Offer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Offer& from);
  void MergeFrom(const Offer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Offer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.Offer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.Account account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::org::xrpl::rpc::v1::Account& account() const;
  ::org::xrpl::rpc::v1::Account* release_account();
  ::org::xrpl::rpc::v1::Account* mutable_account();
  void set_allocated_account(::org::xrpl::rpc::v1::Account* account);

  // .org.xrpl.rpc.v1.Sequence sequence = 2;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  const ::org::xrpl::rpc::v1::Sequence& sequence() const;
  ::org::xrpl::rpc::v1::Sequence* release_sequence();
  ::org::xrpl::rpc::v1::Sequence* mutable_sequence();
  void set_allocated_sequence(::org::xrpl::rpc::v1::Sequence* sequence);

  // .org.xrpl.rpc.v1.Flags flags = 3;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 3;
  const ::org::xrpl::rpc::v1::Flags& flags() const;
  ::org::xrpl::rpc::v1::Flags* release_flags();
  ::org::xrpl::rpc::v1::Flags* mutable_flags();
  void set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags);

  // .org.xrpl.rpc.v1.TakerPays taker_pays = 4;
  bool has_taker_pays() const;
  void clear_taker_pays();
  static const int kTakerPaysFieldNumber = 4;
  const ::org::xrpl::rpc::v1::TakerPays& taker_pays() const;
  ::org::xrpl::rpc::v1::TakerPays* release_taker_pays();
  ::org::xrpl::rpc::v1::TakerPays* mutable_taker_pays();
  void set_allocated_taker_pays(::org::xrpl::rpc::v1::TakerPays* taker_pays);

  // .org.xrpl.rpc.v1.TakerGets taker_gets = 5;
  bool has_taker_gets() const;
  void clear_taker_gets();
  static const int kTakerGetsFieldNumber = 5;
  const ::org::xrpl::rpc::v1::TakerGets& taker_gets() const;
  ::org::xrpl::rpc::v1::TakerGets* release_taker_gets();
  ::org::xrpl::rpc::v1::TakerGets* mutable_taker_gets();
  void set_allocated_taker_gets(::org::xrpl::rpc::v1::TakerGets* taker_gets);

  // .org.xrpl.rpc.v1.BookDirectory book_directory = 6;
  bool has_book_directory() const;
  void clear_book_directory();
  static const int kBookDirectoryFieldNumber = 6;
  const ::org::xrpl::rpc::v1::BookDirectory& book_directory() const;
  ::org::xrpl::rpc::v1::BookDirectory* release_book_directory();
  ::org::xrpl::rpc::v1::BookDirectory* mutable_book_directory();
  void set_allocated_book_directory(::org::xrpl::rpc::v1::BookDirectory* book_directory);

  // .org.xrpl.rpc.v1.BookNode book_node = 7;
  bool has_book_node() const;
  void clear_book_node();
  static const int kBookNodeFieldNumber = 7;
  const ::org::xrpl::rpc::v1::BookNode& book_node() const;
  ::org::xrpl::rpc::v1::BookNode* release_book_node();
  ::org::xrpl::rpc::v1::BookNode* mutable_book_node();
  void set_allocated_book_node(::org::xrpl::rpc::v1::BookNode* book_node);

  // .org.xrpl.rpc.v1.OwnerNode owner_node = 8;
  bool has_owner_node() const;
  void clear_owner_node();
  static const int kOwnerNodeFieldNumber = 8;
  const ::org::xrpl::rpc::v1::OwnerNode& owner_node() const;
  ::org::xrpl::rpc::v1::OwnerNode* release_owner_node();
  ::org::xrpl::rpc::v1::OwnerNode* mutable_owner_node();
  void set_allocated_owner_node(::org::xrpl::rpc::v1::OwnerNode* owner_node);

  // .org.xrpl.rpc.v1.Expiration expiration = 9;
  bool has_expiration() const;
  void clear_expiration();
  static const int kExpirationFieldNumber = 9;
  const ::org::xrpl::rpc::v1::Expiration& expiration() const;
  ::org::xrpl::rpc::v1::Expiration* release_expiration();
  ::org::xrpl::rpc::v1::Expiration* mutable_expiration();
  void set_allocated_expiration(::org::xrpl::rpc::v1::Expiration* expiration);

  // .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 10;
  bool has_previous_transaction_id() const;
  void clear_previous_transaction_id();
  static const int kPreviousTransactionIdFieldNumber = 10;
  const ::org::xrpl::rpc::v1::PreviousTransactionID& previous_transaction_id() const;
  ::org::xrpl::rpc::v1::PreviousTransactionID* release_previous_transaction_id();
  ::org::xrpl::rpc::v1::PreviousTransactionID* mutable_previous_transaction_id();
  void set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id);

  // .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 11;
  bool has_previous_transaction_ledger_sequence() const;
  void clear_previous_transaction_ledger_sequence();
  static const int kPreviousTransactionLedgerSequenceFieldNumber = 11;
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& previous_transaction_ledger_sequence() const;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* release_previous_transaction_ledger_sequence();
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* mutable_previous_transaction_ledger_sequence();
  void set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.Offer)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::Account* account_;
  ::org::xrpl::rpc::v1::Sequence* sequence_;
  ::org::xrpl::rpc::v1::Flags* flags_;
  ::org::xrpl::rpc::v1::TakerPays* taker_pays_;
  ::org::xrpl::rpc::v1::TakerGets* taker_gets_;
  ::org::xrpl::rpc::v1::BookDirectory* book_directory_;
  ::org::xrpl::rpc::v1::BookNode* book_node_;
  ::org::xrpl::rpc::v1::OwnerNode* owner_node_;
  ::org::xrpl::rpc::v1::Expiration* expiration_;
  ::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id_;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// -------------------------------------------------------------------

class PayChannel :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.PayChannel) */ {
 public:
  PayChannel();
  virtual ~PayChannel();

  PayChannel(const PayChannel& from);
  PayChannel(PayChannel&& from) noexcept
    : PayChannel() {
    *this = ::std::move(from);
  }

  inline PayChannel& operator=(const PayChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayChannel& operator=(PayChannel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PayChannel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PayChannel* internal_default_instance() {
    return reinterpret_cast<const PayChannel*>(
               &_PayChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(PayChannel* other);
  friend void swap(PayChannel& a, PayChannel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PayChannel* New() const final {
    return CreateMaybeMessage<PayChannel>(nullptr);
  }

  PayChannel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PayChannel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PayChannel& from);
  void MergeFrom(const PayChannel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PayChannel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.PayChannel";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.Account account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::org::xrpl::rpc::v1::Account& account() const;
  ::org::xrpl::rpc::v1::Account* release_account();
  ::org::xrpl::rpc::v1::Account* mutable_account();
  void set_allocated_account(::org::xrpl::rpc::v1::Account* account);

  // .org.xrpl.rpc.v1.Destination destination = 2;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 2;
  const ::org::xrpl::rpc::v1::Destination& destination() const;
  ::org::xrpl::rpc::v1::Destination* release_destination();
  ::org::xrpl::rpc::v1::Destination* mutable_destination();
  void set_allocated_destination(::org::xrpl::rpc::v1::Destination* destination);

  // .org.xrpl.rpc.v1.Amount amount = 3;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  const ::org::xrpl::rpc::v1::Amount& amount() const;
  ::org::xrpl::rpc::v1::Amount* release_amount();
  ::org::xrpl::rpc::v1::Amount* mutable_amount();
  void set_allocated_amount(::org::xrpl::rpc::v1::Amount* amount);

  // .org.xrpl.rpc.v1.Balance balance = 4;
  bool has_balance() const;
  void clear_balance();
  static const int kBalanceFieldNumber = 4;
  const ::org::xrpl::rpc::v1::Balance& balance() const;
  ::org::xrpl::rpc::v1::Balance* release_balance();
  ::org::xrpl::rpc::v1::Balance* mutable_balance();
  void set_allocated_balance(::org::xrpl::rpc::v1::Balance* balance);

  // .org.xrpl.rpc.v1.PublicKey public_key = 5;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 5;
  const ::org::xrpl::rpc::v1::PublicKey& public_key() const;
  ::org::xrpl::rpc::v1::PublicKey* release_public_key();
  ::org::xrpl::rpc::v1::PublicKey* mutable_public_key();
  void set_allocated_public_key(::org::xrpl::rpc::v1::PublicKey* public_key);

  // .org.xrpl.rpc.v1.SettleDelay settle_delay = 6;
  bool has_settle_delay() const;
  void clear_settle_delay();
  static const int kSettleDelayFieldNumber = 6;
  const ::org::xrpl::rpc::v1::SettleDelay& settle_delay() const;
  ::org::xrpl::rpc::v1::SettleDelay* release_settle_delay();
  ::org::xrpl::rpc::v1::SettleDelay* mutable_settle_delay();
  void set_allocated_settle_delay(::org::xrpl::rpc::v1::SettleDelay* settle_delay);

  // .org.xrpl.rpc.v1.OwnerNode owner_node = 7;
  bool has_owner_node() const;
  void clear_owner_node();
  static const int kOwnerNodeFieldNumber = 7;
  const ::org::xrpl::rpc::v1::OwnerNode& owner_node() const;
  ::org::xrpl::rpc::v1::OwnerNode* release_owner_node();
  ::org::xrpl::rpc::v1::OwnerNode* mutable_owner_node();
  void set_allocated_owner_node(::org::xrpl::rpc::v1::OwnerNode* owner_node);

  // .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 8;
  bool has_previous_transaction_id() const;
  void clear_previous_transaction_id();
  static const int kPreviousTransactionIdFieldNumber = 8;
  const ::org::xrpl::rpc::v1::PreviousTransactionID& previous_transaction_id() const;
  ::org::xrpl::rpc::v1::PreviousTransactionID* release_previous_transaction_id();
  ::org::xrpl::rpc::v1::PreviousTransactionID* mutable_previous_transaction_id();
  void set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id);

  // .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 9;
  bool has_previous_transaction_ledger_sequence() const;
  void clear_previous_transaction_ledger_sequence();
  static const int kPreviousTransactionLedgerSequenceFieldNumber = 9;
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& previous_transaction_ledger_sequence() const;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* release_previous_transaction_ledger_sequence();
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* mutable_previous_transaction_ledger_sequence();
  void set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence);

  // .org.xrpl.rpc.v1.Flags flags = 10;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 10;
  const ::org::xrpl::rpc::v1::Flags& flags() const;
  ::org::xrpl::rpc::v1::Flags* release_flags();
  ::org::xrpl::rpc::v1::Flags* mutable_flags();
  void set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags);

  // .org.xrpl.rpc.v1.Expiration expiration = 11;
  bool has_expiration() const;
  void clear_expiration();
  static const int kExpirationFieldNumber = 11;
  const ::org::xrpl::rpc::v1::Expiration& expiration() const;
  ::org::xrpl::rpc::v1::Expiration* release_expiration();
  ::org::xrpl::rpc::v1::Expiration* mutable_expiration();
  void set_allocated_expiration(::org::xrpl::rpc::v1::Expiration* expiration);

  // .org.xrpl.rpc.v1.CancelAfter cancel_after = 12;
  bool has_cancel_after() const;
  void clear_cancel_after();
  static const int kCancelAfterFieldNumber = 12;
  const ::org::xrpl::rpc::v1::CancelAfter& cancel_after() const;
  ::org::xrpl::rpc::v1::CancelAfter* release_cancel_after();
  ::org::xrpl::rpc::v1::CancelAfter* mutable_cancel_after();
  void set_allocated_cancel_after(::org::xrpl::rpc::v1::CancelAfter* cancel_after);

  // .org.xrpl.rpc.v1.SourceTag source_tag = 13;
  bool has_source_tag() const;
  void clear_source_tag();
  static const int kSourceTagFieldNumber = 13;
  const ::org::xrpl::rpc::v1::SourceTag& source_tag() const;
  ::org::xrpl::rpc::v1::SourceTag* release_source_tag();
  ::org::xrpl::rpc::v1::SourceTag* mutable_source_tag();
  void set_allocated_source_tag(::org::xrpl::rpc::v1::SourceTag* source_tag);

  // .org.xrpl.rpc.v1.DestinationTag destination_tag = 14;
  bool has_destination_tag() const;
  void clear_destination_tag();
  static const int kDestinationTagFieldNumber = 14;
  const ::org::xrpl::rpc::v1::DestinationTag& destination_tag() const;
  ::org::xrpl::rpc::v1::DestinationTag* release_destination_tag();
  ::org::xrpl::rpc::v1::DestinationTag* mutable_destination_tag();
  void set_allocated_destination_tag(::org::xrpl::rpc::v1::DestinationTag* destination_tag);

  // .org.xrpl.rpc.v1.DestinationNode destination_node = 15;
  bool has_destination_node() const;
  void clear_destination_node();
  static const int kDestinationNodeFieldNumber = 15;
  const ::org::xrpl::rpc::v1::DestinationNode& destination_node() const;
  ::org::xrpl::rpc::v1::DestinationNode* release_destination_node();
  ::org::xrpl::rpc::v1::DestinationNode* mutable_destination_node();
  void set_allocated_destination_node(::org::xrpl::rpc::v1::DestinationNode* destination_node);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.PayChannel)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::Account* account_;
  ::org::xrpl::rpc::v1::Destination* destination_;
  ::org::xrpl::rpc::v1::Amount* amount_;
  ::org::xrpl::rpc::v1::Balance* balance_;
  ::org::xrpl::rpc::v1::PublicKey* public_key_;
  ::org::xrpl::rpc::v1::SettleDelay* settle_delay_;
  ::org::xrpl::rpc::v1::OwnerNode* owner_node_;
  ::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id_;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence_;
  ::org::xrpl::rpc::v1::Flags* flags_;
  ::org::xrpl::rpc::v1::Expiration* expiration_;
  ::org::xrpl::rpc::v1::CancelAfter* cancel_after_;
  ::org::xrpl::rpc::v1::SourceTag* source_tag_;
  ::org::xrpl::rpc::v1::DestinationTag* destination_tag_;
  ::org::xrpl::rpc::v1::DestinationNode* destination_node_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// -------------------------------------------------------------------

class RippleState :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.RippleState) */ {
 public:
  RippleState();
  virtual ~RippleState();

  RippleState(const RippleState& from);
  RippleState(RippleState&& from) noexcept
    : RippleState() {
    *this = ::std::move(from);
  }

  inline RippleState& operator=(const RippleState& from) {
    CopyFrom(from);
    return *this;
  }
  inline RippleState& operator=(RippleState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RippleState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RippleState* internal_default_instance() {
    return reinterpret_cast<const RippleState*>(
               &_RippleState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(RippleState* other);
  friend void swap(RippleState& a, RippleState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RippleState* New() const final {
    return CreateMaybeMessage<RippleState>(nullptr);
  }

  RippleState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RippleState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RippleState& from);
  void MergeFrom(const RippleState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RippleState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.RippleState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.Balance balance = 1;
  bool has_balance() const;
  void clear_balance();
  static const int kBalanceFieldNumber = 1;
  const ::org::xrpl::rpc::v1::Balance& balance() const;
  ::org::xrpl::rpc::v1::Balance* release_balance();
  ::org::xrpl::rpc::v1::Balance* mutable_balance();
  void set_allocated_balance(::org::xrpl::rpc::v1::Balance* balance);

  // .org.xrpl.rpc.v1.Flags flags = 2;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 2;
  const ::org::xrpl::rpc::v1::Flags& flags() const;
  ::org::xrpl::rpc::v1::Flags* release_flags();
  ::org::xrpl::rpc::v1::Flags* mutable_flags();
  void set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags);

  // .org.xrpl.rpc.v1.LowLimit low_limit = 3;
  bool has_low_limit() const;
  void clear_low_limit();
  static const int kLowLimitFieldNumber = 3;
  const ::org::xrpl::rpc::v1::LowLimit& low_limit() const;
  ::org::xrpl::rpc::v1::LowLimit* release_low_limit();
  ::org::xrpl::rpc::v1::LowLimit* mutable_low_limit();
  void set_allocated_low_limit(::org::xrpl::rpc::v1::LowLimit* low_limit);

  // .org.xrpl.rpc.v1.HighLimit high_limit = 4;
  bool has_high_limit() const;
  void clear_high_limit();
  static const int kHighLimitFieldNumber = 4;
  const ::org::xrpl::rpc::v1::HighLimit& high_limit() const;
  ::org::xrpl::rpc::v1::HighLimit* release_high_limit();
  ::org::xrpl::rpc::v1::HighLimit* mutable_high_limit();
  void set_allocated_high_limit(::org::xrpl::rpc::v1::HighLimit* high_limit);

  // .org.xrpl.rpc.v1.LowNode low_node = 5;
  bool has_low_node() const;
  void clear_low_node();
  static const int kLowNodeFieldNumber = 5;
  const ::org::xrpl::rpc::v1::LowNode& low_node() const;
  ::org::xrpl::rpc::v1::LowNode* release_low_node();
  ::org::xrpl::rpc::v1::LowNode* mutable_low_node();
  void set_allocated_low_node(::org::xrpl::rpc::v1::LowNode* low_node);

  // .org.xrpl.rpc.v1.HighNode high_node = 6;
  bool has_high_node() const;
  void clear_high_node();
  static const int kHighNodeFieldNumber = 6;
  const ::org::xrpl::rpc::v1::HighNode& high_node() const;
  ::org::xrpl::rpc::v1::HighNode* release_high_node();
  ::org::xrpl::rpc::v1::HighNode* mutable_high_node();
  void set_allocated_high_node(::org::xrpl::rpc::v1::HighNode* high_node);

  // .org.xrpl.rpc.v1.LowQualityIn low_quality_in = 7;
  bool has_low_quality_in() const;
  void clear_low_quality_in();
  static const int kLowQualityInFieldNumber = 7;
  const ::org::xrpl::rpc::v1::LowQualityIn& low_quality_in() const;
  ::org::xrpl::rpc::v1::LowQualityIn* release_low_quality_in();
  ::org::xrpl::rpc::v1::LowQualityIn* mutable_low_quality_in();
  void set_allocated_low_quality_in(::org::xrpl::rpc::v1::LowQualityIn* low_quality_in);

  // .org.xrpl.rpc.v1.LowQualityOut low_quality_out = 8;
  bool has_low_quality_out() const;
  void clear_low_quality_out();
  static const int kLowQualityOutFieldNumber = 8;
  const ::org::xrpl::rpc::v1::LowQualityOut& low_quality_out() const;
  ::org::xrpl::rpc::v1::LowQualityOut* release_low_quality_out();
  ::org::xrpl::rpc::v1::LowQualityOut* mutable_low_quality_out();
  void set_allocated_low_quality_out(::org::xrpl::rpc::v1::LowQualityOut* low_quality_out);

  // .org.xrpl.rpc.v1.HighQualityIn high_quality_in = 9;
  bool has_high_quality_in() const;
  void clear_high_quality_in();
  static const int kHighQualityInFieldNumber = 9;
  const ::org::xrpl::rpc::v1::HighQualityIn& high_quality_in() const;
  ::org::xrpl::rpc::v1::HighQualityIn* release_high_quality_in();
  ::org::xrpl::rpc::v1::HighQualityIn* mutable_high_quality_in();
  void set_allocated_high_quality_in(::org::xrpl::rpc::v1::HighQualityIn* high_quality_in);

  // .org.xrpl.rpc.v1.HighQualityOut high_quality_out = 10;
  bool has_high_quality_out() const;
  void clear_high_quality_out();
  static const int kHighQualityOutFieldNumber = 10;
  const ::org::xrpl::rpc::v1::HighQualityOut& high_quality_out() const;
  ::org::xrpl::rpc::v1::HighQualityOut* release_high_quality_out();
  ::org::xrpl::rpc::v1::HighQualityOut* mutable_high_quality_out();
  void set_allocated_high_quality_out(::org::xrpl::rpc::v1::HighQualityOut* high_quality_out);

  // .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 11;
  bool has_previous_transaction_id() const;
  void clear_previous_transaction_id();
  static const int kPreviousTransactionIdFieldNumber = 11;
  const ::org::xrpl::rpc::v1::PreviousTransactionID& previous_transaction_id() const;
  ::org::xrpl::rpc::v1::PreviousTransactionID* release_previous_transaction_id();
  ::org::xrpl::rpc::v1::PreviousTransactionID* mutable_previous_transaction_id();
  void set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id);

  // .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 12;
  bool has_previous_transaction_ledger_sequence() const;
  void clear_previous_transaction_ledger_sequence();
  static const int kPreviousTransactionLedgerSequenceFieldNumber = 12;
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& previous_transaction_ledger_sequence() const;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* release_previous_transaction_ledger_sequence();
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* mutable_previous_transaction_ledger_sequence();
  void set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.RippleState)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::Balance* balance_;
  ::org::xrpl::rpc::v1::Flags* flags_;
  ::org::xrpl::rpc::v1::LowLimit* low_limit_;
  ::org::xrpl::rpc::v1::HighLimit* high_limit_;
  ::org::xrpl::rpc::v1::LowNode* low_node_;
  ::org::xrpl::rpc::v1::HighNode* high_node_;
  ::org::xrpl::rpc::v1::LowQualityIn* low_quality_in_;
  ::org::xrpl::rpc::v1::LowQualityOut* low_quality_out_;
  ::org::xrpl::rpc::v1::HighQualityIn* high_quality_in_;
  ::org::xrpl::rpc::v1::HighQualityOut* high_quality_out_;
  ::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id_;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// -------------------------------------------------------------------

class SignerList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.SignerList) */ {
 public:
  SignerList();
  virtual ~SignerList();

  SignerList(const SignerList& from);
  SignerList(SignerList&& from) noexcept
    : SignerList() {
    *this = ::std::move(from);
  }

  inline SignerList& operator=(const SignerList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignerList& operator=(SignerList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignerList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignerList* internal_default_instance() {
    return reinterpret_cast<const SignerList*>(
               &_SignerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(SignerList* other);
  friend void swap(SignerList& a, SignerList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignerList* New() const final {
    return CreateMaybeMessage<SignerList>(nullptr);
  }

  SignerList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignerList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignerList& from);
  void MergeFrom(const SignerList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignerList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.SignerList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .org.xrpl.rpc.v1.SignerEntry signer_entries = 5;
  int signer_entries_size() const;
  void clear_signer_entries();
  static const int kSignerEntriesFieldNumber = 5;
  ::org::xrpl::rpc::v1::SignerEntry* mutable_signer_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::SignerEntry >*
      mutable_signer_entries();
  const ::org::xrpl::rpc::v1::SignerEntry& signer_entries(int index) const;
  ::org::xrpl::rpc::v1::SignerEntry* add_signer_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::SignerEntry >&
      signer_entries() const;

  // .org.xrpl.rpc.v1.Flags flags = 1;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 1;
  const ::org::xrpl::rpc::v1::Flags& flags() const;
  ::org::xrpl::rpc::v1::Flags* release_flags();
  ::org::xrpl::rpc::v1::Flags* mutable_flags();
  void set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags);

  // .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 2;
  bool has_previous_transaction_id() const;
  void clear_previous_transaction_id();
  static const int kPreviousTransactionIdFieldNumber = 2;
  const ::org::xrpl::rpc::v1::PreviousTransactionID& previous_transaction_id() const;
  ::org::xrpl::rpc::v1::PreviousTransactionID* release_previous_transaction_id();
  ::org::xrpl::rpc::v1::PreviousTransactionID* mutable_previous_transaction_id();
  void set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id);

  // .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 3;
  bool has_previous_transaction_ledger_sequence() const;
  void clear_previous_transaction_ledger_sequence();
  static const int kPreviousTransactionLedgerSequenceFieldNumber = 3;
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& previous_transaction_ledger_sequence() const;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* release_previous_transaction_ledger_sequence();
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* mutable_previous_transaction_ledger_sequence();
  void set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence);

  // .org.xrpl.rpc.v1.OwnerNode owner_node = 4;
  bool has_owner_node() const;
  void clear_owner_node();
  static const int kOwnerNodeFieldNumber = 4;
  const ::org::xrpl::rpc::v1::OwnerNode& owner_node() const;
  ::org::xrpl::rpc::v1::OwnerNode* release_owner_node();
  ::org::xrpl::rpc::v1::OwnerNode* mutable_owner_node();
  void set_allocated_owner_node(::org::xrpl::rpc::v1::OwnerNode* owner_node);

  // .org.xrpl.rpc.v1.SignerListID signer_list_id = 6;
  bool has_signer_list_id() const;
  void clear_signer_list_id();
  static const int kSignerListIdFieldNumber = 6;
  const ::org::xrpl::rpc::v1::SignerListID& signer_list_id() const;
  ::org::xrpl::rpc::v1::SignerListID* release_signer_list_id();
  ::org::xrpl::rpc::v1::SignerListID* mutable_signer_list_id();
  void set_allocated_signer_list_id(::org::xrpl::rpc::v1::SignerListID* signer_list_id);

  // .org.xrpl.rpc.v1.SignerQuorum signer_quorum = 7;
  bool has_signer_quorum() const;
  void clear_signer_quorum();
  static const int kSignerQuorumFieldNumber = 7;
  const ::org::xrpl::rpc::v1::SignerQuorum& signer_quorum() const;
  ::org::xrpl::rpc::v1::SignerQuorum* release_signer_quorum();
  ::org::xrpl::rpc::v1::SignerQuorum* mutable_signer_quorum();
  void set_allocated_signer_quorum(::org::xrpl::rpc::v1::SignerQuorum* signer_quorum);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.SignerList)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::SignerEntry > signer_entries_;
  ::org::xrpl::rpc::v1::Flags* flags_;
  ::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id_;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence_;
  ::org::xrpl::rpc::v1::OwnerNode* owner_node_;
  ::org::xrpl::rpc::v1::SignerListID* signer_list_id_;
  ::org::xrpl::rpc::v1::SignerQuorum* signer_quorum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// -------------------------------------------------------------------

class TicketObject :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.TicketObject) */ {
 public:
  TicketObject();
  virtual ~TicketObject();

  TicketObject(const TicketObject& from);
  TicketObject(TicketObject&& from) noexcept
    : TicketObject() {
    *this = ::std::move(from);
  }

  inline TicketObject& operator=(const TicketObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline TicketObject& operator=(TicketObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TicketObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TicketObject* internal_default_instance() {
    return reinterpret_cast<const TicketObject*>(
               &_TicketObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(TicketObject* other);
  friend void swap(TicketObject& a, TicketObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TicketObject* New() const final {
    return CreateMaybeMessage<TicketObject>(nullptr);
  }

  TicketObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TicketObject>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TicketObject& from);
  void MergeFrom(const TicketObject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TicketObject* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.TicketObject";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.xrpl.rpc.v1.Flags flags = 1;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 1;
  const ::org::xrpl::rpc::v1::Flags& flags() const;
  ::org::xrpl::rpc::v1::Flags* release_flags();
  ::org::xrpl::rpc::v1::Flags* mutable_flags();
  void set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags);

  // .org.xrpl.rpc.v1.Account account = 2;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 2;
  const ::org::xrpl::rpc::v1::Account& account() const;
  ::org::xrpl::rpc::v1::Account* release_account();
  ::org::xrpl::rpc::v1::Account* mutable_account();
  void set_allocated_account(::org::xrpl::rpc::v1::Account* account);

  // .org.xrpl.rpc.v1.OwnerNode owner_node = 3;
  bool has_owner_node() const;
  void clear_owner_node();
  static const int kOwnerNodeFieldNumber = 3;
  const ::org::xrpl::rpc::v1::OwnerNode& owner_node() const;
  ::org::xrpl::rpc::v1::OwnerNode* release_owner_node();
  ::org::xrpl::rpc::v1::OwnerNode* mutable_owner_node();
  void set_allocated_owner_node(::org::xrpl::rpc::v1::OwnerNode* owner_node);

  // .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 4;
  bool has_previous_transaction_id() const;
  void clear_previous_transaction_id();
  static const int kPreviousTransactionIdFieldNumber = 4;
  const ::org::xrpl::rpc::v1::PreviousTransactionID& previous_transaction_id() const;
  ::org::xrpl::rpc::v1::PreviousTransactionID* release_previous_transaction_id();
  ::org::xrpl::rpc::v1::PreviousTransactionID* mutable_previous_transaction_id();
  void set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id);

  // .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 5;
  bool has_previous_transaction_ledger_sequence() const;
  void clear_previous_transaction_ledger_sequence();
  static const int kPreviousTransactionLedgerSequenceFieldNumber = 5;
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& previous_transaction_ledger_sequence() const;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* release_previous_transaction_ledger_sequence();
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* mutable_previous_transaction_ledger_sequence();
  void set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence);

  // .org.xrpl.rpc.v1.TicketSequence ticket_sequence = 6;
  bool has_ticket_sequence() const;
  void clear_ticket_sequence();
  static const int kTicketSequenceFieldNumber = 6;
  const ::org::xrpl::rpc::v1::TicketSequence& ticket_sequence() const;
  ::org::xrpl::rpc::v1::TicketSequence* release_ticket_sequence();
  ::org::xrpl::rpc::v1::TicketSequence* mutable_ticket_sequence();
  void set_allocated_ticket_sequence(::org::xrpl::rpc::v1::TicketSequence* ticket_sequence);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.TicketObject)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::xrpl::rpc::v1::Flags* flags_;
  ::org::xrpl::rpc::v1::Account* account_;
  ::org::xrpl::rpc::v1::OwnerNode* owner_node_;
  ::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id_;
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence_;
  ::org::xrpl::rpc::v1::TicketSequence* ticket_sequence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// -------------------------------------------------------------------

class NegativeUNL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:org.xrpl.rpc.v1.NegativeUNL) */ {
 public:
  NegativeUNL();
  virtual ~NegativeUNL();

  NegativeUNL(const NegativeUNL& from);
  NegativeUNL(NegativeUNL&& from) noexcept
    : NegativeUNL() {
    *this = ::std::move(from);
  }

  inline NegativeUNL& operator=(const NegativeUNL& from) {
    CopyFrom(from);
    return *this;
  }
  inline NegativeUNL& operator=(NegativeUNL&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NegativeUNL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NegativeUNL* internal_default_instance() {
    return reinterpret_cast<const NegativeUNL*>(
               &_NegativeUNL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(NegativeUNL* other);
  friend void swap(NegativeUNL& a, NegativeUNL& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NegativeUNL* New() const final {
    return CreateMaybeMessage<NegativeUNL>(nullptr);
  }

  NegativeUNL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NegativeUNL>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NegativeUNL& from);
  void MergeFrom(const NegativeUNL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NegativeUNL* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "org.xrpl.rpc.v1.NegativeUNL";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto);
    return ::descriptor_table_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .org.xrpl.rpc.v1.DisabledValidator disabled_validators = 1;
  int disabled_validators_size() const;
  void clear_disabled_validators();
  static const int kDisabledValidatorsFieldNumber = 1;
  ::org::xrpl::rpc::v1::DisabledValidator* mutable_disabled_validators(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::DisabledValidator >*
      mutable_disabled_validators();
  const ::org::xrpl::rpc::v1::DisabledValidator& disabled_validators(int index) const;
  ::org::xrpl::rpc::v1::DisabledValidator* add_disabled_validators();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::DisabledValidator >&
      disabled_validators() const;

  // .org.xrpl.rpc.v1.ValidatorToDisable validator_to_disable = 2;
  bool has_validator_to_disable() const;
  void clear_validator_to_disable();
  static const int kValidatorToDisableFieldNumber = 2;
  const ::org::xrpl::rpc::v1::ValidatorToDisable& validator_to_disable() const;
  ::org::xrpl::rpc::v1::ValidatorToDisable* release_validator_to_disable();
  ::org::xrpl::rpc::v1::ValidatorToDisable* mutable_validator_to_disable();
  void set_allocated_validator_to_disable(::org::xrpl::rpc::v1::ValidatorToDisable* validator_to_disable);

  // .org.xrpl.rpc.v1.ValidatorToReEnable validator_to_re_enable = 3;
  bool has_validator_to_re_enable() const;
  void clear_validator_to_re_enable();
  static const int kValidatorToReEnableFieldNumber = 3;
  const ::org::xrpl::rpc::v1::ValidatorToReEnable& validator_to_re_enable() const;
  ::org::xrpl::rpc::v1::ValidatorToReEnable* release_validator_to_re_enable();
  ::org::xrpl::rpc::v1::ValidatorToReEnable* mutable_validator_to_re_enable();
  void set_allocated_validator_to_re_enable(::org::xrpl::rpc::v1::ValidatorToReEnable* validator_to_re_enable);

  // .org.xrpl.rpc.v1.Flags flags = 4;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 4;
  const ::org::xrpl::rpc::v1::Flags& flags() const;
  ::org::xrpl::rpc::v1::Flags* release_flags();
  ::org::xrpl::rpc::v1::Flags* mutable_flags();
  void set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags);

  // @@protoc_insertion_point(class_scope:org.xrpl.rpc.v1.NegativeUNL)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::DisabledValidator > disabled_validators_;
  ::org::xrpl::rpc::v1::ValidatorToDisable* validator_to_disable_;
  ::org::xrpl::rpc::v1::ValidatorToReEnable* validator_to_re_enable_;
  ::org::xrpl::rpc::v1::Flags* flags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LedgerObject

// .org.xrpl.rpc.v1.AccountRoot account_root = 1;
inline bool LedgerObject::has_account_root() const {
  return object_case() == kAccountRoot;
}
inline void LedgerObject::set_has_account_root() {
  _oneof_case_[0] = kAccountRoot;
}
inline void LedgerObject::clear_account_root() {
  if (has_account_root()) {
    delete object_.account_root_;
    clear_has_object();
  }
}
inline ::org::xrpl::rpc::v1::AccountRoot* LedgerObject::release_account_root() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LedgerObject.account_root)
  if (has_account_root()) {
    clear_has_object();
      ::org::xrpl::rpc::v1::AccountRoot* temp = object_.account_root_;
    object_.account_root_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::org::xrpl::rpc::v1::AccountRoot& LedgerObject::account_root() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerObject.account_root)
  return has_account_root()
      ? *object_.account_root_
      : *reinterpret_cast< ::org::xrpl::rpc::v1::AccountRoot*>(&::org::xrpl::rpc::v1::_AccountRoot_default_instance_);
}
inline ::org::xrpl::rpc::v1::AccountRoot* LedgerObject::mutable_account_root() {
  if (!has_account_root()) {
    clear_object();
    set_has_account_root();
    object_.account_root_ = CreateMaybeMessage< ::org::xrpl::rpc::v1::AccountRoot >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerObject.account_root)
  return object_.account_root_;
}

// .org.xrpl.rpc.v1.Amendments amendments = 2;
inline bool LedgerObject::has_amendments() const {
  return object_case() == kAmendments;
}
inline void LedgerObject::set_has_amendments() {
  _oneof_case_[0] = kAmendments;
}
inline void LedgerObject::clear_amendments() {
  if (has_amendments()) {
    delete object_.amendments_;
    clear_has_object();
  }
}
inline ::org::xrpl::rpc::v1::Amendments* LedgerObject::release_amendments() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LedgerObject.amendments)
  if (has_amendments()) {
    clear_has_object();
      ::org::xrpl::rpc::v1::Amendments* temp = object_.amendments_;
    object_.amendments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::org::xrpl::rpc::v1::Amendments& LedgerObject::amendments() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerObject.amendments)
  return has_amendments()
      ? *object_.amendments_
      : *reinterpret_cast< ::org::xrpl::rpc::v1::Amendments*>(&::org::xrpl::rpc::v1::_Amendments_default_instance_);
}
inline ::org::xrpl::rpc::v1::Amendments* LedgerObject::mutable_amendments() {
  if (!has_amendments()) {
    clear_object();
    set_has_amendments();
    object_.amendments_ = CreateMaybeMessage< ::org::xrpl::rpc::v1::Amendments >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerObject.amendments)
  return object_.amendments_;
}

// .org.xrpl.rpc.v1.Check check = 3;
inline bool LedgerObject::has_check() const {
  return object_case() == kCheck;
}
inline void LedgerObject::set_has_check() {
  _oneof_case_[0] = kCheck;
}
inline void LedgerObject::clear_check() {
  if (has_check()) {
    delete object_.check_;
    clear_has_object();
  }
}
inline ::org::xrpl::rpc::v1::Check* LedgerObject::release_check() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LedgerObject.check)
  if (has_check()) {
    clear_has_object();
      ::org::xrpl::rpc::v1::Check* temp = object_.check_;
    object_.check_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::org::xrpl::rpc::v1::Check& LedgerObject::check() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerObject.check)
  return has_check()
      ? *object_.check_
      : *reinterpret_cast< ::org::xrpl::rpc::v1::Check*>(&::org::xrpl::rpc::v1::_Check_default_instance_);
}
inline ::org::xrpl::rpc::v1::Check* LedgerObject::mutable_check() {
  if (!has_check()) {
    clear_object();
    set_has_check();
    object_.check_ = CreateMaybeMessage< ::org::xrpl::rpc::v1::Check >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerObject.check)
  return object_.check_;
}

// .org.xrpl.rpc.v1.DepositPreauthObject deposit_preauth = 4;
inline bool LedgerObject::has_deposit_preauth() const {
  return object_case() == kDepositPreauth;
}
inline void LedgerObject::set_has_deposit_preauth() {
  _oneof_case_[0] = kDepositPreauth;
}
inline void LedgerObject::clear_deposit_preauth() {
  if (has_deposit_preauth()) {
    delete object_.deposit_preauth_;
    clear_has_object();
  }
}
inline ::org::xrpl::rpc::v1::DepositPreauthObject* LedgerObject::release_deposit_preauth() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LedgerObject.deposit_preauth)
  if (has_deposit_preauth()) {
    clear_has_object();
      ::org::xrpl::rpc::v1::DepositPreauthObject* temp = object_.deposit_preauth_;
    object_.deposit_preauth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::org::xrpl::rpc::v1::DepositPreauthObject& LedgerObject::deposit_preauth() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerObject.deposit_preauth)
  return has_deposit_preauth()
      ? *object_.deposit_preauth_
      : *reinterpret_cast< ::org::xrpl::rpc::v1::DepositPreauthObject*>(&::org::xrpl::rpc::v1::_DepositPreauthObject_default_instance_);
}
inline ::org::xrpl::rpc::v1::DepositPreauthObject* LedgerObject::mutable_deposit_preauth() {
  if (!has_deposit_preauth()) {
    clear_object();
    set_has_deposit_preauth();
    object_.deposit_preauth_ = CreateMaybeMessage< ::org::xrpl::rpc::v1::DepositPreauthObject >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerObject.deposit_preauth)
  return object_.deposit_preauth_;
}

// .org.xrpl.rpc.v1.DirectoryNode directory_node = 5;
inline bool LedgerObject::has_directory_node() const {
  return object_case() == kDirectoryNode;
}
inline void LedgerObject::set_has_directory_node() {
  _oneof_case_[0] = kDirectoryNode;
}
inline void LedgerObject::clear_directory_node() {
  if (has_directory_node()) {
    delete object_.directory_node_;
    clear_has_object();
  }
}
inline ::org::xrpl::rpc::v1::DirectoryNode* LedgerObject::release_directory_node() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LedgerObject.directory_node)
  if (has_directory_node()) {
    clear_has_object();
      ::org::xrpl::rpc::v1::DirectoryNode* temp = object_.directory_node_;
    object_.directory_node_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::org::xrpl::rpc::v1::DirectoryNode& LedgerObject::directory_node() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerObject.directory_node)
  return has_directory_node()
      ? *object_.directory_node_
      : *reinterpret_cast< ::org::xrpl::rpc::v1::DirectoryNode*>(&::org::xrpl::rpc::v1::_DirectoryNode_default_instance_);
}
inline ::org::xrpl::rpc::v1::DirectoryNode* LedgerObject::mutable_directory_node() {
  if (!has_directory_node()) {
    clear_object();
    set_has_directory_node();
    object_.directory_node_ = CreateMaybeMessage< ::org::xrpl::rpc::v1::DirectoryNode >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerObject.directory_node)
  return object_.directory_node_;
}

// .org.xrpl.rpc.v1.Escrow escrow = 6;
inline bool LedgerObject::has_escrow() const {
  return object_case() == kEscrow;
}
inline void LedgerObject::set_has_escrow() {
  _oneof_case_[0] = kEscrow;
}
inline void LedgerObject::clear_escrow() {
  if (has_escrow()) {
    delete object_.escrow_;
    clear_has_object();
  }
}
inline ::org::xrpl::rpc::v1::Escrow* LedgerObject::release_escrow() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LedgerObject.escrow)
  if (has_escrow()) {
    clear_has_object();
      ::org::xrpl::rpc::v1::Escrow* temp = object_.escrow_;
    object_.escrow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::org::xrpl::rpc::v1::Escrow& LedgerObject::escrow() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerObject.escrow)
  return has_escrow()
      ? *object_.escrow_
      : *reinterpret_cast< ::org::xrpl::rpc::v1::Escrow*>(&::org::xrpl::rpc::v1::_Escrow_default_instance_);
}
inline ::org::xrpl::rpc::v1::Escrow* LedgerObject::mutable_escrow() {
  if (!has_escrow()) {
    clear_object();
    set_has_escrow();
    object_.escrow_ = CreateMaybeMessage< ::org::xrpl::rpc::v1::Escrow >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerObject.escrow)
  return object_.escrow_;
}

// .org.xrpl.rpc.v1.FeeSettings fee_settings = 7;
inline bool LedgerObject::has_fee_settings() const {
  return object_case() == kFeeSettings;
}
inline void LedgerObject::set_has_fee_settings() {
  _oneof_case_[0] = kFeeSettings;
}
inline void LedgerObject::clear_fee_settings() {
  if (has_fee_settings()) {
    delete object_.fee_settings_;
    clear_has_object();
  }
}
inline ::org::xrpl::rpc::v1::FeeSettings* LedgerObject::release_fee_settings() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LedgerObject.fee_settings)
  if (has_fee_settings()) {
    clear_has_object();
      ::org::xrpl::rpc::v1::FeeSettings* temp = object_.fee_settings_;
    object_.fee_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::org::xrpl::rpc::v1::FeeSettings& LedgerObject::fee_settings() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerObject.fee_settings)
  return has_fee_settings()
      ? *object_.fee_settings_
      : *reinterpret_cast< ::org::xrpl::rpc::v1::FeeSettings*>(&::org::xrpl::rpc::v1::_FeeSettings_default_instance_);
}
inline ::org::xrpl::rpc::v1::FeeSettings* LedgerObject::mutable_fee_settings() {
  if (!has_fee_settings()) {
    clear_object();
    set_has_fee_settings();
    object_.fee_settings_ = CreateMaybeMessage< ::org::xrpl::rpc::v1::FeeSettings >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerObject.fee_settings)
  return object_.fee_settings_;
}

// .org.xrpl.rpc.v1.LedgerHashes ledger_hashes = 8;
inline bool LedgerObject::has_ledger_hashes() const {
  return object_case() == kLedgerHashes;
}
inline void LedgerObject::set_has_ledger_hashes() {
  _oneof_case_[0] = kLedgerHashes;
}
inline void LedgerObject::clear_ledger_hashes() {
  if (has_ledger_hashes()) {
    delete object_.ledger_hashes_;
    clear_has_object();
  }
}
inline ::org::xrpl::rpc::v1::LedgerHashes* LedgerObject::release_ledger_hashes() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LedgerObject.ledger_hashes)
  if (has_ledger_hashes()) {
    clear_has_object();
      ::org::xrpl::rpc::v1::LedgerHashes* temp = object_.ledger_hashes_;
    object_.ledger_hashes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::org::xrpl::rpc::v1::LedgerHashes& LedgerObject::ledger_hashes() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerObject.ledger_hashes)
  return has_ledger_hashes()
      ? *object_.ledger_hashes_
      : *reinterpret_cast< ::org::xrpl::rpc::v1::LedgerHashes*>(&::org::xrpl::rpc::v1::_LedgerHashes_default_instance_);
}
inline ::org::xrpl::rpc::v1::LedgerHashes* LedgerObject::mutable_ledger_hashes() {
  if (!has_ledger_hashes()) {
    clear_object();
    set_has_ledger_hashes();
    object_.ledger_hashes_ = CreateMaybeMessage< ::org::xrpl::rpc::v1::LedgerHashes >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerObject.ledger_hashes)
  return object_.ledger_hashes_;
}

// .org.xrpl.rpc.v1.Offer offer = 9;
inline bool LedgerObject::has_offer() const {
  return object_case() == kOffer;
}
inline void LedgerObject::set_has_offer() {
  _oneof_case_[0] = kOffer;
}
inline void LedgerObject::clear_offer() {
  if (has_offer()) {
    delete object_.offer_;
    clear_has_object();
  }
}
inline ::org::xrpl::rpc::v1::Offer* LedgerObject::release_offer() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LedgerObject.offer)
  if (has_offer()) {
    clear_has_object();
      ::org::xrpl::rpc::v1::Offer* temp = object_.offer_;
    object_.offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::org::xrpl::rpc::v1::Offer& LedgerObject::offer() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerObject.offer)
  return has_offer()
      ? *object_.offer_
      : *reinterpret_cast< ::org::xrpl::rpc::v1::Offer*>(&::org::xrpl::rpc::v1::_Offer_default_instance_);
}
inline ::org::xrpl::rpc::v1::Offer* LedgerObject::mutable_offer() {
  if (!has_offer()) {
    clear_object();
    set_has_offer();
    object_.offer_ = CreateMaybeMessage< ::org::xrpl::rpc::v1::Offer >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerObject.offer)
  return object_.offer_;
}

// .org.xrpl.rpc.v1.PayChannel pay_channel = 10;
inline bool LedgerObject::has_pay_channel() const {
  return object_case() == kPayChannel;
}
inline void LedgerObject::set_has_pay_channel() {
  _oneof_case_[0] = kPayChannel;
}
inline void LedgerObject::clear_pay_channel() {
  if (has_pay_channel()) {
    delete object_.pay_channel_;
    clear_has_object();
  }
}
inline ::org::xrpl::rpc::v1::PayChannel* LedgerObject::release_pay_channel() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LedgerObject.pay_channel)
  if (has_pay_channel()) {
    clear_has_object();
      ::org::xrpl::rpc::v1::PayChannel* temp = object_.pay_channel_;
    object_.pay_channel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::org::xrpl::rpc::v1::PayChannel& LedgerObject::pay_channel() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerObject.pay_channel)
  return has_pay_channel()
      ? *object_.pay_channel_
      : *reinterpret_cast< ::org::xrpl::rpc::v1::PayChannel*>(&::org::xrpl::rpc::v1::_PayChannel_default_instance_);
}
inline ::org::xrpl::rpc::v1::PayChannel* LedgerObject::mutable_pay_channel() {
  if (!has_pay_channel()) {
    clear_object();
    set_has_pay_channel();
    object_.pay_channel_ = CreateMaybeMessage< ::org::xrpl::rpc::v1::PayChannel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerObject.pay_channel)
  return object_.pay_channel_;
}

// .org.xrpl.rpc.v1.RippleState ripple_state = 11;
inline bool LedgerObject::has_ripple_state() const {
  return object_case() == kRippleState;
}
inline void LedgerObject::set_has_ripple_state() {
  _oneof_case_[0] = kRippleState;
}
inline void LedgerObject::clear_ripple_state() {
  if (has_ripple_state()) {
    delete object_.ripple_state_;
    clear_has_object();
  }
}
inline ::org::xrpl::rpc::v1::RippleState* LedgerObject::release_ripple_state() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LedgerObject.ripple_state)
  if (has_ripple_state()) {
    clear_has_object();
      ::org::xrpl::rpc::v1::RippleState* temp = object_.ripple_state_;
    object_.ripple_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::org::xrpl::rpc::v1::RippleState& LedgerObject::ripple_state() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerObject.ripple_state)
  return has_ripple_state()
      ? *object_.ripple_state_
      : *reinterpret_cast< ::org::xrpl::rpc::v1::RippleState*>(&::org::xrpl::rpc::v1::_RippleState_default_instance_);
}
inline ::org::xrpl::rpc::v1::RippleState* LedgerObject::mutable_ripple_state() {
  if (!has_ripple_state()) {
    clear_object();
    set_has_ripple_state();
    object_.ripple_state_ = CreateMaybeMessage< ::org::xrpl::rpc::v1::RippleState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerObject.ripple_state)
  return object_.ripple_state_;
}

// .org.xrpl.rpc.v1.SignerList signer_list = 12;
inline bool LedgerObject::has_signer_list() const {
  return object_case() == kSignerList;
}
inline void LedgerObject::set_has_signer_list() {
  _oneof_case_[0] = kSignerList;
}
inline void LedgerObject::clear_signer_list() {
  if (has_signer_list()) {
    delete object_.signer_list_;
    clear_has_object();
  }
}
inline ::org::xrpl::rpc::v1::SignerList* LedgerObject::release_signer_list() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LedgerObject.signer_list)
  if (has_signer_list()) {
    clear_has_object();
      ::org::xrpl::rpc::v1::SignerList* temp = object_.signer_list_;
    object_.signer_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::org::xrpl::rpc::v1::SignerList& LedgerObject::signer_list() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerObject.signer_list)
  return has_signer_list()
      ? *object_.signer_list_
      : *reinterpret_cast< ::org::xrpl::rpc::v1::SignerList*>(&::org::xrpl::rpc::v1::_SignerList_default_instance_);
}
inline ::org::xrpl::rpc::v1::SignerList* LedgerObject::mutable_signer_list() {
  if (!has_signer_list()) {
    clear_object();
    set_has_signer_list();
    object_.signer_list_ = CreateMaybeMessage< ::org::xrpl::rpc::v1::SignerList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerObject.signer_list)
  return object_.signer_list_;
}

// .org.xrpl.rpc.v1.NegativeUNL negative_unl = 13;
inline bool LedgerObject::has_negative_unl() const {
  return object_case() == kNegativeUnl;
}
inline void LedgerObject::set_has_negative_unl() {
  _oneof_case_[0] = kNegativeUnl;
}
inline void LedgerObject::clear_negative_unl() {
  if (has_negative_unl()) {
    delete object_.negative_unl_;
    clear_has_object();
  }
}
inline ::org::xrpl::rpc::v1::NegativeUNL* LedgerObject::release_negative_unl() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LedgerObject.negative_unl)
  if (has_negative_unl()) {
    clear_has_object();
      ::org::xrpl::rpc::v1::NegativeUNL* temp = object_.negative_unl_;
    object_.negative_unl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::org::xrpl::rpc::v1::NegativeUNL& LedgerObject::negative_unl() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerObject.negative_unl)
  return has_negative_unl()
      ? *object_.negative_unl_
      : *reinterpret_cast< ::org::xrpl::rpc::v1::NegativeUNL*>(&::org::xrpl::rpc::v1::_NegativeUNL_default_instance_);
}
inline ::org::xrpl::rpc::v1::NegativeUNL* LedgerObject::mutable_negative_unl() {
  if (!has_negative_unl()) {
    clear_object();
    set_has_negative_unl();
    object_.negative_unl_ = CreateMaybeMessage< ::org::xrpl::rpc::v1::NegativeUNL >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerObject.negative_unl)
  return object_.negative_unl_;
}

// .org.xrpl.rpc.v1.TicketObject ticket = 14;
inline bool LedgerObject::has_ticket() const {
  return object_case() == kTicket;
}
inline void LedgerObject::set_has_ticket() {
  _oneof_case_[0] = kTicket;
}
inline void LedgerObject::clear_ticket() {
  if (has_ticket()) {
    delete object_.ticket_;
    clear_has_object();
  }
}
inline ::org::xrpl::rpc::v1::TicketObject* LedgerObject::release_ticket() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LedgerObject.ticket)
  if (has_ticket()) {
    clear_has_object();
      ::org::xrpl::rpc::v1::TicketObject* temp = object_.ticket_;
    object_.ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::org::xrpl::rpc::v1::TicketObject& LedgerObject::ticket() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerObject.ticket)
  return has_ticket()
      ? *object_.ticket_
      : *reinterpret_cast< ::org::xrpl::rpc::v1::TicketObject*>(&::org::xrpl::rpc::v1::_TicketObject_default_instance_);
}
inline ::org::xrpl::rpc::v1::TicketObject* LedgerObject::mutable_ticket() {
  if (!has_ticket()) {
    clear_object();
    set_has_ticket();
    object_.ticket_ = CreateMaybeMessage< ::org::xrpl::rpc::v1::TicketObject >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerObject.ticket)
  return object_.ticket_;
}

inline bool LedgerObject::has_object() const {
  return object_case() != OBJECT_NOT_SET;
}
inline void LedgerObject::clear_has_object() {
  _oneof_case_[0] = OBJECT_NOT_SET;
}
inline LedgerObject::ObjectCase LedgerObject::object_case() const {
  return LedgerObject::ObjectCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AccountRoot

// .org.xrpl.rpc.v1.Account account = 1;
inline bool AccountRoot::has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Account& AccountRoot::account() const {
  const ::org::xrpl::rpc::v1::Account* p = account_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.AccountRoot.account)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Account*>(
      &::org::xrpl::rpc::v1::_Account_default_instance_);
}
inline ::org::xrpl::rpc::v1::Account* AccountRoot::release_account() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.AccountRoot.account)
  
  ::org::xrpl::rpc::v1::Account* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Account* AccountRoot::mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Account>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.AccountRoot.account)
  return account_;
}
inline void AccountRoot::set_allocated_account(::org::xrpl::rpc::v1::Account* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.AccountRoot.account)
}

// .org.xrpl.rpc.v1.Balance balance = 2;
inline bool AccountRoot::has_balance() const {
  return this != internal_default_instance() && balance_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Balance& AccountRoot::balance() const {
  const ::org::xrpl::rpc::v1::Balance* p = balance_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.AccountRoot.balance)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Balance*>(
      &::org::xrpl::rpc::v1::_Balance_default_instance_);
}
inline ::org::xrpl::rpc::v1::Balance* AccountRoot::release_balance() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.AccountRoot.balance)
  
  ::org::xrpl::rpc::v1::Balance* temp = balance_;
  balance_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Balance* AccountRoot::mutable_balance() {
  
  if (balance_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Balance>(GetArenaNoVirtual());
    balance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.AccountRoot.balance)
  return balance_;
}
inline void AccountRoot::set_allocated_balance(::org::xrpl::rpc::v1::Balance* balance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(balance_);
  }
  if (balance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      balance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, balance, submessage_arena);
    }
    
  } else {
    
  }
  balance_ = balance;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.AccountRoot.balance)
}

// .org.xrpl.rpc.v1.Sequence sequence = 3;
inline bool AccountRoot::has_sequence() const {
  return this != internal_default_instance() && sequence_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Sequence& AccountRoot::sequence() const {
  const ::org::xrpl::rpc::v1::Sequence* p = sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.AccountRoot.sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Sequence*>(
      &::org::xrpl::rpc::v1::_Sequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::Sequence* AccountRoot::release_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.AccountRoot.sequence)
  
  ::org::xrpl::rpc::v1::Sequence* temp = sequence_;
  sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Sequence* AccountRoot::mutable_sequence() {
  
  if (sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Sequence>(GetArenaNoVirtual());
    sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.AccountRoot.sequence)
  return sequence_;
}
inline void AccountRoot::set_allocated_sequence(::org::xrpl::rpc::v1::Sequence* sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sequence_);
  }
  if (sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sequence, submessage_arena);
    }
    
  } else {
    
  }
  sequence_ = sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.AccountRoot.sequence)
}

// .org.xrpl.rpc.v1.Flags flags = 4;
inline bool AccountRoot::has_flags() const {
  return this != internal_default_instance() && flags_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Flags& AccountRoot::flags() const {
  const ::org::xrpl::rpc::v1::Flags* p = flags_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.AccountRoot.flags)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Flags*>(
      &::org::xrpl::rpc::v1::_Flags_default_instance_);
}
inline ::org::xrpl::rpc::v1::Flags* AccountRoot::release_flags() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.AccountRoot.flags)
  
  ::org::xrpl::rpc::v1::Flags* temp = flags_;
  flags_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Flags* AccountRoot::mutable_flags() {
  
  if (flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Flags>(GetArenaNoVirtual());
    flags_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.AccountRoot.flags)
  return flags_;
}
inline void AccountRoot::set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flags_);
  }
  if (flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flags, submessage_arena);
    }
    
  } else {
    
  }
  flags_ = flags;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.AccountRoot.flags)
}

// .org.xrpl.rpc.v1.OwnerCount owner_count = 5;
inline bool AccountRoot::has_owner_count() const {
  return this != internal_default_instance() && owner_count_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::OwnerCount& AccountRoot::owner_count() const {
  const ::org::xrpl::rpc::v1::OwnerCount* p = owner_count_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.AccountRoot.owner_count)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::OwnerCount*>(
      &::org::xrpl::rpc::v1::_OwnerCount_default_instance_);
}
inline ::org::xrpl::rpc::v1::OwnerCount* AccountRoot::release_owner_count() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.AccountRoot.owner_count)
  
  ::org::xrpl::rpc::v1::OwnerCount* temp = owner_count_;
  owner_count_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::OwnerCount* AccountRoot::mutable_owner_count() {
  
  if (owner_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::OwnerCount>(GetArenaNoVirtual());
    owner_count_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.AccountRoot.owner_count)
  return owner_count_;
}
inline void AccountRoot::set_allocated_owner_count(::org::xrpl::rpc::v1::OwnerCount* owner_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_count_);
  }
  if (owner_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      owner_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_count, submessage_arena);
    }
    
  } else {
    
  }
  owner_count_ = owner_count;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.AccountRoot.owner_count)
}

// .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 6;
inline bool AccountRoot::has_previous_transaction_id() const {
  return this != internal_default_instance() && previous_transaction_id_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionID& AccountRoot::previous_transaction_id() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionID* p = previous_transaction_id_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.AccountRoot.previous_transaction_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionID*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionID_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* AccountRoot::release_previous_transaction_id() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.AccountRoot.previous_transaction_id)
  
  ::org::xrpl::rpc::v1::PreviousTransactionID* temp = previous_transaction_id_;
  previous_transaction_id_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* AccountRoot::mutable_previous_transaction_id() {
  
  if (previous_transaction_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionID>(GetArenaNoVirtual());
    previous_transaction_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.AccountRoot.previous_transaction_id)
  return previous_transaction_id_;
}
inline void AccountRoot::set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_id_);
  }
  if (previous_transaction_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_id, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_id_ = previous_transaction_id;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.AccountRoot.previous_transaction_id)
}

// .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 7;
inline bool AccountRoot::has_previous_transaction_ledger_sequence() const {
  return this != internal_default_instance() && previous_transaction_ledger_sequence_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& AccountRoot::previous_transaction_ledger_sequence() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* p = previous_transaction_ledger_sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.AccountRoot.previous_transaction_ledger_sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionLedgerSequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* AccountRoot::release_previous_transaction_ledger_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.AccountRoot.previous_transaction_ledger_sequence)
  
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* temp = previous_transaction_ledger_sequence_;
  previous_transaction_ledger_sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* AccountRoot::mutable_previous_transaction_ledger_sequence() {
  
  if (previous_transaction_ledger_sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence>(GetArenaNoVirtual());
    previous_transaction_ledger_sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.AccountRoot.previous_transaction_ledger_sequence)
  return previous_transaction_ledger_sequence_;
}
inline void AccountRoot::set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_ledger_sequence_);
  }
  if (previous_transaction_ledger_sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_ledger_sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_ledger_sequence, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_ledger_sequence_ = previous_transaction_ledger_sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.AccountRoot.previous_transaction_ledger_sequence)
}

// .org.xrpl.rpc.v1.AccountTransactionID account_transaction_id = 8;
inline bool AccountRoot::has_account_transaction_id() const {
  return this != internal_default_instance() && account_transaction_id_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::AccountTransactionID& AccountRoot::account_transaction_id() const {
  const ::org::xrpl::rpc::v1::AccountTransactionID* p = account_transaction_id_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.AccountRoot.account_transaction_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::AccountTransactionID*>(
      &::org::xrpl::rpc::v1::_AccountTransactionID_default_instance_);
}
inline ::org::xrpl::rpc::v1::AccountTransactionID* AccountRoot::release_account_transaction_id() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.AccountRoot.account_transaction_id)
  
  ::org::xrpl::rpc::v1::AccountTransactionID* temp = account_transaction_id_;
  account_transaction_id_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::AccountTransactionID* AccountRoot::mutable_account_transaction_id() {
  
  if (account_transaction_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::AccountTransactionID>(GetArenaNoVirtual());
    account_transaction_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.AccountRoot.account_transaction_id)
  return account_transaction_id_;
}
inline void AccountRoot::set_allocated_account_transaction_id(::org::xrpl::rpc::v1::AccountTransactionID* account_transaction_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_transaction_id_);
  }
  if (account_transaction_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account_transaction_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account_transaction_id, submessage_arena);
    }
    
  } else {
    
  }
  account_transaction_id_ = account_transaction_id;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.AccountRoot.account_transaction_id)
}

// .org.xrpl.rpc.v1.Domain domain = 9;
inline bool AccountRoot::has_domain() const {
  return this != internal_default_instance() && domain_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Domain& AccountRoot::domain() const {
  const ::org::xrpl::rpc::v1::Domain* p = domain_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.AccountRoot.domain)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Domain*>(
      &::org::xrpl::rpc::v1::_Domain_default_instance_);
}
inline ::org::xrpl::rpc::v1::Domain* AccountRoot::release_domain() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.AccountRoot.domain)
  
  ::org::xrpl::rpc::v1::Domain* temp = domain_;
  domain_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Domain* AccountRoot::mutable_domain() {
  
  if (domain_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Domain>(GetArenaNoVirtual());
    domain_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.AccountRoot.domain)
  return domain_;
}
inline void AccountRoot::set_allocated_domain(::org::xrpl::rpc::v1::Domain* domain) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(domain_);
  }
  if (domain) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      domain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, domain, submessage_arena);
    }
    
  } else {
    
  }
  domain_ = domain;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.AccountRoot.domain)
}

// .org.xrpl.rpc.v1.EmailHash email_hash = 10;
inline bool AccountRoot::has_email_hash() const {
  return this != internal_default_instance() && email_hash_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::EmailHash& AccountRoot::email_hash() const {
  const ::org::xrpl::rpc::v1::EmailHash* p = email_hash_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.AccountRoot.email_hash)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::EmailHash*>(
      &::org::xrpl::rpc::v1::_EmailHash_default_instance_);
}
inline ::org::xrpl::rpc::v1::EmailHash* AccountRoot::release_email_hash() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.AccountRoot.email_hash)
  
  ::org::xrpl::rpc::v1::EmailHash* temp = email_hash_;
  email_hash_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::EmailHash* AccountRoot::mutable_email_hash() {
  
  if (email_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::EmailHash>(GetArenaNoVirtual());
    email_hash_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.AccountRoot.email_hash)
  return email_hash_;
}
inline void AccountRoot::set_allocated_email_hash(::org::xrpl::rpc::v1::EmailHash* email_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(email_hash_);
  }
  if (email_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      email_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, email_hash, submessage_arena);
    }
    
  } else {
    
  }
  email_hash_ = email_hash;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.AccountRoot.email_hash)
}

// .org.xrpl.rpc.v1.MessageKey message_key = 11;
inline bool AccountRoot::has_message_key() const {
  return this != internal_default_instance() && message_key_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::MessageKey& AccountRoot::message_key() const {
  const ::org::xrpl::rpc::v1::MessageKey* p = message_key_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.AccountRoot.message_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::MessageKey*>(
      &::org::xrpl::rpc::v1::_MessageKey_default_instance_);
}
inline ::org::xrpl::rpc::v1::MessageKey* AccountRoot::release_message_key() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.AccountRoot.message_key)
  
  ::org::xrpl::rpc::v1::MessageKey* temp = message_key_;
  message_key_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::MessageKey* AccountRoot::mutable_message_key() {
  
  if (message_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::MessageKey>(GetArenaNoVirtual());
    message_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.AccountRoot.message_key)
  return message_key_;
}
inline void AccountRoot::set_allocated_message_key(::org::xrpl::rpc::v1::MessageKey* message_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_key_);
  }
  if (message_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      message_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message_key, submessage_arena);
    }
    
  } else {
    
  }
  message_key_ = message_key;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.AccountRoot.message_key)
}

// .org.xrpl.rpc.v1.RegularKey regular_key = 12;
inline bool AccountRoot::has_regular_key() const {
  return this != internal_default_instance() && regular_key_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::RegularKey& AccountRoot::regular_key() const {
  const ::org::xrpl::rpc::v1::RegularKey* p = regular_key_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.AccountRoot.regular_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::RegularKey*>(
      &::org::xrpl::rpc::v1::_RegularKey_default_instance_);
}
inline ::org::xrpl::rpc::v1::RegularKey* AccountRoot::release_regular_key() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.AccountRoot.regular_key)
  
  ::org::xrpl::rpc::v1::RegularKey* temp = regular_key_;
  regular_key_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::RegularKey* AccountRoot::mutable_regular_key() {
  
  if (regular_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::RegularKey>(GetArenaNoVirtual());
    regular_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.AccountRoot.regular_key)
  return regular_key_;
}
inline void AccountRoot::set_allocated_regular_key(::org::xrpl::rpc::v1::RegularKey* regular_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(regular_key_);
  }
  if (regular_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      regular_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regular_key, submessage_arena);
    }
    
  } else {
    
  }
  regular_key_ = regular_key;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.AccountRoot.regular_key)
}

// .org.xrpl.rpc.v1.TickSize tick_size = 13;
inline bool AccountRoot::has_tick_size() const {
  return this != internal_default_instance() && tick_size_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::TickSize& AccountRoot::tick_size() const {
  const ::org::xrpl::rpc::v1::TickSize* p = tick_size_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.AccountRoot.tick_size)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::TickSize*>(
      &::org::xrpl::rpc::v1::_TickSize_default_instance_);
}
inline ::org::xrpl::rpc::v1::TickSize* AccountRoot::release_tick_size() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.AccountRoot.tick_size)
  
  ::org::xrpl::rpc::v1::TickSize* temp = tick_size_;
  tick_size_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::TickSize* AccountRoot::mutable_tick_size() {
  
  if (tick_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::TickSize>(GetArenaNoVirtual());
    tick_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.AccountRoot.tick_size)
  return tick_size_;
}
inline void AccountRoot::set_allocated_tick_size(::org::xrpl::rpc::v1::TickSize* tick_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tick_size_);
  }
  if (tick_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tick_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tick_size, submessage_arena);
    }
    
  } else {
    
  }
  tick_size_ = tick_size;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.AccountRoot.tick_size)
}

// .org.xrpl.rpc.v1.TransferRate transfer_rate = 14;
inline bool AccountRoot::has_transfer_rate() const {
  return this != internal_default_instance() && transfer_rate_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::TransferRate& AccountRoot::transfer_rate() const {
  const ::org::xrpl::rpc::v1::TransferRate* p = transfer_rate_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.AccountRoot.transfer_rate)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::TransferRate*>(
      &::org::xrpl::rpc::v1::_TransferRate_default_instance_);
}
inline ::org::xrpl::rpc::v1::TransferRate* AccountRoot::release_transfer_rate() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.AccountRoot.transfer_rate)
  
  ::org::xrpl::rpc::v1::TransferRate* temp = transfer_rate_;
  transfer_rate_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::TransferRate* AccountRoot::mutable_transfer_rate() {
  
  if (transfer_rate_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::TransferRate>(GetArenaNoVirtual());
    transfer_rate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.AccountRoot.transfer_rate)
  return transfer_rate_;
}
inline void AccountRoot::set_allocated_transfer_rate(::org::xrpl::rpc::v1::TransferRate* transfer_rate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transfer_rate_);
  }
  if (transfer_rate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      transfer_rate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transfer_rate, submessage_arena);
    }
    
  } else {
    
  }
  transfer_rate_ = transfer_rate;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.AccountRoot.transfer_rate)
}

// .org.xrpl.rpc.v1.TicketCount ticket_count = 15;
inline bool AccountRoot::has_ticket_count() const {
  return this != internal_default_instance() && ticket_count_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::TicketCount& AccountRoot::ticket_count() const {
  const ::org::xrpl::rpc::v1::TicketCount* p = ticket_count_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.AccountRoot.ticket_count)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::TicketCount*>(
      &::org::xrpl::rpc::v1::_TicketCount_default_instance_);
}
inline ::org::xrpl::rpc::v1::TicketCount* AccountRoot::release_ticket_count() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.AccountRoot.ticket_count)
  
  ::org::xrpl::rpc::v1::TicketCount* temp = ticket_count_;
  ticket_count_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::TicketCount* AccountRoot::mutable_ticket_count() {
  
  if (ticket_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::TicketCount>(GetArenaNoVirtual());
    ticket_count_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.AccountRoot.ticket_count)
  return ticket_count_;
}
inline void AccountRoot::set_allocated_ticket_count(::org::xrpl::rpc::v1::TicketCount* ticket_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ticket_count_);
  }
  if (ticket_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ticket_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ticket_count, submessage_arena);
    }
    
  } else {
    
  }
  ticket_count_ = ticket_count;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.AccountRoot.ticket_count)
}

// -------------------------------------------------------------------

// Amendments_Amendment

// bytes value = 1;
inline void Amendments_Amendment::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Amendments_Amendment::value() const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Amendments.Amendment.value)
  return value_.GetNoArena();
}
inline void Amendments_Amendment::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.xrpl.rpc.v1.Amendments.Amendment.value)
}
inline void Amendments_Amendment::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.xrpl.rpc.v1.Amendments.Amendment.value)
}
inline void Amendments_Amendment::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.xrpl.rpc.v1.Amendments.Amendment.value)
}
inline void Amendments_Amendment::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.xrpl.rpc.v1.Amendments.Amendment.value)
}
inline std::string* Amendments_Amendment::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Amendments.Amendment.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Amendments_Amendment::release_value() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Amendments.Amendment.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Amendments_Amendment::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Amendments.Amendment.value)
}

// -------------------------------------------------------------------

// Amendments_Majority

// .org.xrpl.rpc.v1.Amendments.Amendment amendment = 1;
inline bool Amendments_Majority::has_amendment() const {
  return this != internal_default_instance() && amendment_ != nullptr;
}
inline void Amendments_Majority::clear_amendment() {
  if (GetArenaNoVirtual() == nullptr && amendment_ != nullptr) {
    delete amendment_;
  }
  amendment_ = nullptr;
}
inline const ::org::xrpl::rpc::v1::Amendments_Amendment& Amendments_Majority::amendment() const {
  const ::org::xrpl::rpc::v1::Amendments_Amendment* p = amendment_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Amendments.Majority.amendment)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Amendments_Amendment*>(
      &::org::xrpl::rpc::v1::_Amendments_Amendment_default_instance_);
}
inline ::org::xrpl::rpc::v1::Amendments_Amendment* Amendments_Majority::release_amendment() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Amendments.Majority.amendment)
  
  ::org::xrpl::rpc::v1::Amendments_Amendment* temp = amendment_;
  amendment_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Amendments_Amendment* Amendments_Majority::mutable_amendment() {
  
  if (amendment_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Amendments_Amendment>(GetArenaNoVirtual());
    amendment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Amendments.Majority.amendment)
  return amendment_;
}
inline void Amendments_Majority::set_allocated_amendment(::org::xrpl::rpc::v1::Amendments_Amendment* amendment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete amendment_;
  }
  if (amendment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      amendment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amendment, submessage_arena);
    }
    
  } else {
    
  }
  amendment_ = amendment;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Amendments.Majority.amendment)
}

// .org.xrpl.rpc.v1.CloseTime close_time = 2;
inline bool Amendments_Majority::has_close_time() const {
  return this != internal_default_instance() && close_time_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::CloseTime& Amendments_Majority::close_time() const {
  const ::org::xrpl::rpc::v1::CloseTime* p = close_time_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Amendments.Majority.close_time)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::CloseTime*>(
      &::org::xrpl::rpc::v1::_CloseTime_default_instance_);
}
inline ::org::xrpl::rpc::v1::CloseTime* Amendments_Majority::release_close_time() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Amendments.Majority.close_time)
  
  ::org::xrpl::rpc::v1::CloseTime* temp = close_time_;
  close_time_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::CloseTime* Amendments_Majority::mutable_close_time() {
  
  if (close_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::CloseTime>(GetArenaNoVirtual());
    close_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Amendments.Majority.close_time)
  return close_time_;
}
inline void Amendments_Majority::set_allocated_close_time(::org::xrpl::rpc::v1::CloseTime* close_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(close_time_);
  }
  if (close_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      close_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, close_time, submessage_arena);
    }
    
  } else {
    
  }
  close_time_ = close_time;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Amendments.Majority.close_time)
}

// -------------------------------------------------------------------

// Amendments

// repeated .org.xrpl.rpc.v1.Amendments.Amendment amendments = 1;
inline int Amendments::amendments_size() const {
  return amendments_.size();
}
inline void Amendments::clear_amendments() {
  amendments_.Clear();
}
inline ::org::xrpl::rpc::v1::Amendments_Amendment* Amendments::mutable_amendments(int index) {
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Amendments.amendments)
  return amendments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Amendments_Amendment >*
Amendments::mutable_amendments() {
  // @@protoc_insertion_point(field_mutable_list:org.xrpl.rpc.v1.Amendments.amendments)
  return &amendments_;
}
inline const ::org::xrpl::rpc::v1::Amendments_Amendment& Amendments::amendments(int index) const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Amendments.amendments)
  return amendments_.Get(index);
}
inline ::org::xrpl::rpc::v1::Amendments_Amendment* Amendments::add_amendments() {
  // @@protoc_insertion_point(field_add:org.xrpl.rpc.v1.Amendments.amendments)
  return amendments_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Amendments_Amendment >&
Amendments::amendments() const {
  // @@protoc_insertion_point(field_list:org.xrpl.rpc.v1.Amendments.amendments)
  return amendments_;
}

// repeated .org.xrpl.rpc.v1.Amendments.Majority majorities = 2;
inline int Amendments::majorities_size() const {
  return majorities_.size();
}
inline void Amendments::clear_majorities() {
  majorities_.Clear();
}
inline ::org::xrpl::rpc::v1::Amendments_Majority* Amendments::mutable_majorities(int index) {
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Amendments.majorities)
  return majorities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Amendments_Majority >*
Amendments::mutable_majorities() {
  // @@protoc_insertion_point(field_mutable_list:org.xrpl.rpc.v1.Amendments.majorities)
  return &majorities_;
}
inline const ::org::xrpl::rpc::v1::Amendments_Majority& Amendments::majorities(int index) const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Amendments.majorities)
  return majorities_.Get(index);
}
inline ::org::xrpl::rpc::v1::Amendments_Majority* Amendments::add_majorities() {
  // @@protoc_insertion_point(field_add:org.xrpl.rpc.v1.Amendments.majorities)
  return majorities_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Amendments_Majority >&
Amendments::majorities() const {
  // @@protoc_insertion_point(field_list:org.xrpl.rpc.v1.Amendments.majorities)
  return majorities_;
}

// .org.xrpl.rpc.v1.Flags flags = 3;
inline bool Amendments::has_flags() const {
  return this != internal_default_instance() && flags_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Flags& Amendments::flags() const {
  const ::org::xrpl::rpc::v1::Flags* p = flags_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Amendments.flags)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Flags*>(
      &::org::xrpl::rpc::v1::_Flags_default_instance_);
}
inline ::org::xrpl::rpc::v1::Flags* Amendments::release_flags() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Amendments.flags)
  
  ::org::xrpl::rpc::v1::Flags* temp = flags_;
  flags_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Flags* Amendments::mutable_flags() {
  
  if (flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Flags>(GetArenaNoVirtual());
    flags_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Amendments.flags)
  return flags_;
}
inline void Amendments::set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flags_);
  }
  if (flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flags, submessage_arena);
    }
    
  } else {
    
  }
  flags_ = flags;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Amendments.flags)
}

// -------------------------------------------------------------------

// Check

// .org.xrpl.rpc.v1.Account account = 1;
inline bool Check::has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Account& Check::account() const {
  const ::org::xrpl::rpc::v1::Account* p = account_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Check.account)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Account*>(
      &::org::xrpl::rpc::v1::_Account_default_instance_);
}
inline ::org::xrpl::rpc::v1::Account* Check::release_account() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Check.account)
  
  ::org::xrpl::rpc::v1::Account* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Account* Check::mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Account>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Check.account)
  return account_;
}
inline void Check::set_allocated_account(::org::xrpl::rpc::v1::Account* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Check.account)
}

// .org.xrpl.rpc.v1.Destination destination = 2;
inline bool Check::has_destination() const {
  return this != internal_default_instance() && destination_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Destination& Check::destination() const {
  const ::org::xrpl::rpc::v1::Destination* p = destination_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Check.destination)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Destination*>(
      &::org::xrpl::rpc::v1::_Destination_default_instance_);
}
inline ::org::xrpl::rpc::v1::Destination* Check::release_destination() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Check.destination)
  
  ::org::xrpl::rpc::v1::Destination* temp = destination_;
  destination_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Destination* Check::mutable_destination() {
  
  if (destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Destination>(GetArenaNoVirtual());
    destination_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Check.destination)
  return destination_;
}
inline void Check::set_allocated_destination(::org::xrpl::rpc::v1::Destination* destination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_);
  }
  if (destination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      destination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination, submessage_arena);
    }
    
  } else {
    
  }
  destination_ = destination;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Check.destination)
}

// .org.xrpl.rpc.v1.Flags flags = 3;
inline bool Check::has_flags() const {
  return this != internal_default_instance() && flags_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Flags& Check::flags() const {
  const ::org::xrpl::rpc::v1::Flags* p = flags_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Check.flags)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Flags*>(
      &::org::xrpl::rpc::v1::_Flags_default_instance_);
}
inline ::org::xrpl::rpc::v1::Flags* Check::release_flags() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Check.flags)
  
  ::org::xrpl::rpc::v1::Flags* temp = flags_;
  flags_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Flags* Check::mutable_flags() {
  
  if (flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Flags>(GetArenaNoVirtual());
    flags_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Check.flags)
  return flags_;
}
inline void Check::set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flags_);
  }
  if (flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flags, submessage_arena);
    }
    
  } else {
    
  }
  flags_ = flags;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Check.flags)
}

// .org.xrpl.rpc.v1.OwnerNode owner_node = 4;
inline bool Check::has_owner_node() const {
  return this != internal_default_instance() && owner_node_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::OwnerNode& Check::owner_node() const {
  const ::org::xrpl::rpc::v1::OwnerNode* p = owner_node_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Check.owner_node)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::OwnerNode*>(
      &::org::xrpl::rpc::v1::_OwnerNode_default_instance_);
}
inline ::org::xrpl::rpc::v1::OwnerNode* Check::release_owner_node() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Check.owner_node)
  
  ::org::xrpl::rpc::v1::OwnerNode* temp = owner_node_;
  owner_node_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::OwnerNode* Check::mutable_owner_node() {
  
  if (owner_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::OwnerNode>(GetArenaNoVirtual());
    owner_node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Check.owner_node)
  return owner_node_;
}
inline void Check::set_allocated_owner_node(::org::xrpl::rpc::v1::OwnerNode* owner_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_node_);
  }
  if (owner_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      owner_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_node, submessage_arena);
    }
    
  } else {
    
  }
  owner_node_ = owner_node;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Check.owner_node)
}

// .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 5;
inline bool Check::has_previous_transaction_id() const {
  return this != internal_default_instance() && previous_transaction_id_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionID& Check::previous_transaction_id() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionID* p = previous_transaction_id_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Check.previous_transaction_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionID*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionID_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* Check::release_previous_transaction_id() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Check.previous_transaction_id)
  
  ::org::xrpl::rpc::v1::PreviousTransactionID* temp = previous_transaction_id_;
  previous_transaction_id_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* Check::mutable_previous_transaction_id() {
  
  if (previous_transaction_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionID>(GetArenaNoVirtual());
    previous_transaction_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Check.previous_transaction_id)
  return previous_transaction_id_;
}
inline void Check::set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_id_);
  }
  if (previous_transaction_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_id, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_id_ = previous_transaction_id;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Check.previous_transaction_id)
}

// .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 6;
inline bool Check::has_previous_transaction_ledger_sequence() const {
  return this != internal_default_instance() && previous_transaction_ledger_sequence_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& Check::previous_transaction_ledger_sequence() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* p = previous_transaction_ledger_sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Check.previous_transaction_ledger_sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionLedgerSequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* Check::release_previous_transaction_ledger_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Check.previous_transaction_ledger_sequence)
  
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* temp = previous_transaction_ledger_sequence_;
  previous_transaction_ledger_sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* Check::mutable_previous_transaction_ledger_sequence() {
  
  if (previous_transaction_ledger_sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence>(GetArenaNoVirtual());
    previous_transaction_ledger_sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Check.previous_transaction_ledger_sequence)
  return previous_transaction_ledger_sequence_;
}
inline void Check::set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_ledger_sequence_);
  }
  if (previous_transaction_ledger_sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_ledger_sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_ledger_sequence, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_ledger_sequence_ = previous_transaction_ledger_sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Check.previous_transaction_ledger_sequence)
}

// .org.xrpl.rpc.v1.SendMax send_max = 7;
inline bool Check::has_send_max() const {
  return this != internal_default_instance() && send_max_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::SendMax& Check::send_max() const {
  const ::org::xrpl::rpc::v1::SendMax* p = send_max_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Check.send_max)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::SendMax*>(
      &::org::xrpl::rpc::v1::_SendMax_default_instance_);
}
inline ::org::xrpl::rpc::v1::SendMax* Check::release_send_max() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Check.send_max)
  
  ::org::xrpl::rpc::v1::SendMax* temp = send_max_;
  send_max_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::SendMax* Check::mutable_send_max() {
  
  if (send_max_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::SendMax>(GetArenaNoVirtual());
    send_max_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Check.send_max)
  return send_max_;
}
inline void Check::set_allocated_send_max(::org::xrpl::rpc::v1::SendMax* send_max) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(send_max_);
  }
  if (send_max) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      send_max = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, send_max, submessage_arena);
    }
    
  } else {
    
  }
  send_max_ = send_max;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Check.send_max)
}

// .org.xrpl.rpc.v1.Sequence sequence = 8;
inline bool Check::has_sequence() const {
  return this != internal_default_instance() && sequence_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Sequence& Check::sequence() const {
  const ::org::xrpl::rpc::v1::Sequence* p = sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Check.sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Sequence*>(
      &::org::xrpl::rpc::v1::_Sequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::Sequence* Check::release_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Check.sequence)
  
  ::org::xrpl::rpc::v1::Sequence* temp = sequence_;
  sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Sequence* Check::mutable_sequence() {
  
  if (sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Sequence>(GetArenaNoVirtual());
    sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Check.sequence)
  return sequence_;
}
inline void Check::set_allocated_sequence(::org::xrpl::rpc::v1::Sequence* sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sequence_);
  }
  if (sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sequence, submessage_arena);
    }
    
  } else {
    
  }
  sequence_ = sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Check.sequence)
}

// .org.xrpl.rpc.v1.DestinationNode destination_node = 9;
inline bool Check::has_destination_node() const {
  return this != internal_default_instance() && destination_node_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::DestinationNode& Check::destination_node() const {
  const ::org::xrpl::rpc::v1::DestinationNode* p = destination_node_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Check.destination_node)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::DestinationNode*>(
      &::org::xrpl::rpc::v1::_DestinationNode_default_instance_);
}
inline ::org::xrpl::rpc::v1::DestinationNode* Check::release_destination_node() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Check.destination_node)
  
  ::org::xrpl::rpc::v1::DestinationNode* temp = destination_node_;
  destination_node_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::DestinationNode* Check::mutable_destination_node() {
  
  if (destination_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::DestinationNode>(GetArenaNoVirtual());
    destination_node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Check.destination_node)
  return destination_node_;
}
inline void Check::set_allocated_destination_node(::org::xrpl::rpc::v1::DestinationNode* destination_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_node_);
  }
  if (destination_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      destination_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination_node, submessage_arena);
    }
    
  } else {
    
  }
  destination_node_ = destination_node;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Check.destination_node)
}

// .org.xrpl.rpc.v1.DestinationTag destination_tag = 10;
inline bool Check::has_destination_tag() const {
  return this != internal_default_instance() && destination_tag_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::DestinationTag& Check::destination_tag() const {
  const ::org::xrpl::rpc::v1::DestinationTag* p = destination_tag_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Check.destination_tag)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::DestinationTag*>(
      &::org::xrpl::rpc::v1::_DestinationTag_default_instance_);
}
inline ::org::xrpl::rpc::v1::DestinationTag* Check::release_destination_tag() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Check.destination_tag)
  
  ::org::xrpl::rpc::v1::DestinationTag* temp = destination_tag_;
  destination_tag_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::DestinationTag* Check::mutable_destination_tag() {
  
  if (destination_tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::DestinationTag>(GetArenaNoVirtual());
    destination_tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Check.destination_tag)
  return destination_tag_;
}
inline void Check::set_allocated_destination_tag(::org::xrpl::rpc::v1::DestinationTag* destination_tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_tag_);
  }
  if (destination_tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      destination_tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination_tag, submessage_arena);
    }
    
  } else {
    
  }
  destination_tag_ = destination_tag;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Check.destination_tag)
}

// .org.xrpl.rpc.v1.Expiration expiration = 11;
inline bool Check::has_expiration() const {
  return this != internal_default_instance() && expiration_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Expiration& Check::expiration() const {
  const ::org::xrpl::rpc::v1::Expiration* p = expiration_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Check.expiration)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Expiration*>(
      &::org::xrpl::rpc::v1::_Expiration_default_instance_);
}
inline ::org::xrpl::rpc::v1::Expiration* Check::release_expiration() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Check.expiration)
  
  ::org::xrpl::rpc::v1::Expiration* temp = expiration_;
  expiration_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Expiration* Check::mutable_expiration() {
  
  if (expiration_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Expiration>(GetArenaNoVirtual());
    expiration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Check.expiration)
  return expiration_;
}
inline void Check::set_allocated_expiration(::org::xrpl::rpc::v1::Expiration* expiration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(expiration_);
  }
  if (expiration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      expiration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expiration, submessage_arena);
    }
    
  } else {
    
  }
  expiration_ = expiration;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Check.expiration)
}

// .org.xrpl.rpc.v1.InvoiceID invoice_id = 12;
inline bool Check::has_invoice_id() const {
  return this != internal_default_instance() && invoice_id_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::InvoiceID& Check::invoice_id() const {
  const ::org::xrpl::rpc::v1::InvoiceID* p = invoice_id_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Check.invoice_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::InvoiceID*>(
      &::org::xrpl::rpc::v1::_InvoiceID_default_instance_);
}
inline ::org::xrpl::rpc::v1::InvoiceID* Check::release_invoice_id() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Check.invoice_id)
  
  ::org::xrpl::rpc::v1::InvoiceID* temp = invoice_id_;
  invoice_id_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::InvoiceID* Check::mutable_invoice_id() {
  
  if (invoice_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::InvoiceID>(GetArenaNoVirtual());
    invoice_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Check.invoice_id)
  return invoice_id_;
}
inline void Check::set_allocated_invoice_id(::org::xrpl::rpc::v1::InvoiceID* invoice_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(invoice_id_);
  }
  if (invoice_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      invoice_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invoice_id, submessage_arena);
    }
    
  } else {
    
  }
  invoice_id_ = invoice_id;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Check.invoice_id)
}

// .org.xrpl.rpc.v1.SourceTag source_tag = 13;
inline bool Check::has_source_tag() const {
  return this != internal_default_instance() && source_tag_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::SourceTag& Check::source_tag() const {
  const ::org::xrpl::rpc::v1::SourceTag* p = source_tag_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Check.source_tag)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::SourceTag*>(
      &::org::xrpl::rpc::v1::_SourceTag_default_instance_);
}
inline ::org::xrpl::rpc::v1::SourceTag* Check::release_source_tag() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Check.source_tag)
  
  ::org::xrpl::rpc::v1::SourceTag* temp = source_tag_;
  source_tag_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::SourceTag* Check::mutable_source_tag() {
  
  if (source_tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::SourceTag>(GetArenaNoVirtual());
    source_tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Check.source_tag)
  return source_tag_;
}
inline void Check::set_allocated_source_tag(::org::xrpl::rpc::v1::SourceTag* source_tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_tag_);
  }
  if (source_tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source_tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_tag, submessage_arena);
    }
    
  } else {
    
  }
  source_tag_ = source_tag;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Check.source_tag)
}

// -------------------------------------------------------------------

// DepositPreauthObject

// .org.xrpl.rpc.v1.Account account = 1;
inline bool DepositPreauthObject::has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Account& DepositPreauthObject::account() const {
  const ::org::xrpl::rpc::v1::Account* p = account_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DepositPreauthObject.account)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Account*>(
      &::org::xrpl::rpc::v1::_Account_default_instance_);
}
inline ::org::xrpl::rpc::v1::Account* DepositPreauthObject::release_account() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DepositPreauthObject.account)
  
  ::org::xrpl::rpc::v1::Account* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Account* DepositPreauthObject::mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Account>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DepositPreauthObject.account)
  return account_;
}
inline void DepositPreauthObject::set_allocated_account(::org::xrpl::rpc::v1::Account* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DepositPreauthObject.account)
}

// .org.xrpl.rpc.v1.Authorize authorize = 2;
inline bool DepositPreauthObject::has_authorize() const {
  return this != internal_default_instance() && authorize_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Authorize& DepositPreauthObject::authorize() const {
  const ::org::xrpl::rpc::v1::Authorize* p = authorize_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DepositPreauthObject.authorize)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Authorize*>(
      &::org::xrpl::rpc::v1::_Authorize_default_instance_);
}
inline ::org::xrpl::rpc::v1::Authorize* DepositPreauthObject::release_authorize() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DepositPreauthObject.authorize)
  
  ::org::xrpl::rpc::v1::Authorize* temp = authorize_;
  authorize_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Authorize* DepositPreauthObject::mutable_authorize() {
  
  if (authorize_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Authorize>(GetArenaNoVirtual());
    authorize_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DepositPreauthObject.authorize)
  return authorize_;
}
inline void DepositPreauthObject::set_allocated_authorize(::org::xrpl::rpc::v1::Authorize* authorize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(authorize_);
  }
  if (authorize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      authorize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authorize, submessage_arena);
    }
    
  } else {
    
  }
  authorize_ = authorize;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DepositPreauthObject.authorize)
}

// .org.xrpl.rpc.v1.Flags flags = 3;
inline bool DepositPreauthObject::has_flags() const {
  return this != internal_default_instance() && flags_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Flags& DepositPreauthObject::flags() const {
  const ::org::xrpl::rpc::v1::Flags* p = flags_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DepositPreauthObject.flags)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Flags*>(
      &::org::xrpl::rpc::v1::_Flags_default_instance_);
}
inline ::org::xrpl::rpc::v1::Flags* DepositPreauthObject::release_flags() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DepositPreauthObject.flags)
  
  ::org::xrpl::rpc::v1::Flags* temp = flags_;
  flags_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Flags* DepositPreauthObject::mutable_flags() {
  
  if (flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Flags>(GetArenaNoVirtual());
    flags_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DepositPreauthObject.flags)
  return flags_;
}
inline void DepositPreauthObject::set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flags_);
  }
  if (flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flags, submessage_arena);
    }
    
  } else {
    
  }
  flags_ = flags;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DepositPreauthObject.flags)
}

// .org.xrpl.rpc.v1.OwnerNode owner_node = 4;
inline bool DepositPreauthObject::has_owner_node() const {
  return this != internal_default_instance() && owner_node_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::OwnerNode& DepositPreauthObject::owner_node() const {
  const ::org::xrpl::rpc::v1::OwnerNode* p = owner_node_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DepositPreauthObject.owner_node)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::OwnerNode*>(
      &::org::xrpl::rpc::v1::_OwnerNode_default_instance_);
}
inline ::org::xrpl::rpc::v1::OwnerNode* DepositPreauthObject::release_owner_node() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DepositPreauthObject.owner_node)
  
  ::org::xrpl::rpc::v1::OwnerNode* temp = owner_node_;
  owner_node_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::OwnerNode* DepositPreauthObject::mutable_owner_node() {
  
  if (owner_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::OwnerNode>(GetArenaNoVirtual());
    owner_node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DepositPreauthObject.owner_node)
  return owner_node_;
}
inline void DepositPreauthObject::set_allocated_owner_node(::org::xrpl::rpc::v1::OwnerNode* owner_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_node_);
  }
  if (owner_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      owner_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_node, submessage_arena);
    }
    
  } else {
    
  }
  owner_node_ = owner_node;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DepositPreauthObject.owner_node)
}

// .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 5;
inline bool DepositPreauthObject::has_previous_transaction_id() const {
  return this != internal_default_instance() && previous_transaction_id_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionID& DepositPreauthObject::previous_transaction_id() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionID* p = previous_transaction_id_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DepositPreauthObject.previous_transaction_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionID*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionID_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* DepositPreauthObject::release_previous_transaction_id() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DepositPreauthObject.previous_transaction_id)
  
  ::org::xrpl::rpc::v1::PreviousTransactionID* temp = previous_transaction_id_;
  previous_transaction_id_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* DepositPreauthObject::mutable_previous_transaction_id() {
  
  if (previous_transaction_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionID>(GetArenaNoVirtual());
    previous_transaction_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DepositPreauthObject.previous_transaction_id)
  return previous_transaction_id_;
}
inline void DepositPreauthObject::set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_id_);
  }
  if (previous_transaction_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_id, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_id_ = previous_transaction_id;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DepositPreauthObject.previous_transaction_id)
}

// .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 6;
inline bool DepositPreauthObject::has_previous_transaction_ledger_sequence() const {
  return this != internal_default_instance() && previous_transaction_ledger_sequence_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& DepositPreauthObject::previous_transaction_ledger_sequence() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* p = previous_transaction_ledger_sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DepositPreauthObject.previous_transaction_ledger_sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionLedgerSequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* DepositPreauthObject::release_previous_transaction_ledger_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DepositPreauthObject.previous_transaction_ledger_sequence)
  
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* temp = previous_transaction_ledger_sequence_;
  previous_transaction_ledger_sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* DepositPreauthObject::mutable_previous_transaction_ledger_sequence() {
  
  if (previous_transaction_ledger_sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence>(GetArenaNoVirtual());
    previous_transaction_ledger_sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DepositPreauthObject.previous_transaction_ledger_sequence)
  return previous_transaction_ledger_sequence_;
}
inline void DepositPreauthObject::set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_ledger_sequence_);
  }
  if (previous_transaction_ledger_sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_ledger_sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_ledger_sequence, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_ledger_sequence_ = previous_transaction_ledger_sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DepositPreauthObject.previous_transaction_ledger_sequence)
}

// -------------------------------------------------------------------

// DirectoryNode

// .org.xrpl.rpc.v1.Flags flags = 1;
inline bool DirectoryNode::has_flags() const {
  return this != internal_default_instance() && flags_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Flags& DirectoryNode::flags() const {
  const ::org::xrpl::rpc::v1::Flags* p = flags_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DirectoryNode.flags)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Flags*>(
      &::org::xrpl::rpc::v1::_Flags_default_instance_);
}
inline ::org::xrpl::rpc::v1::Flags* DirectoryNode::release_flags() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DirectoryNode.flags)
  
  ::org::xrpl::rpc::v1::Flags* temp = flags_;
  flags_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Flags* DirectoryNode::mutable_flags() {
  
  if (flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Flags>(GetArenaNoVirtual());
    flags_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DirectoryNode.flags)
  return flags_;
}
inline void DirectoryNode::set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flags_);
  }
  if (flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flags, submessage_arena);
    }
    
  } else {
    
  }
  flags_ = flags;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DirectoryNode.flags)
}

// .org.xrpl.rpc.v1.RootIndex root_index = 2;
inline bool DirectoryNode::has_root_index() const {
  return this != internal_default_instance() && root_index_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::RootIndex& DirectoryNode::root_index() const {
  const ::org::xrpl::rpc::v1::RootIndex* p = root_index_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DirectoryNode.root_index)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::RootIndex*>(
      &::org::xrpl::rpc::v1::_RootIndex_default_instance_);
}
inline ::org::xrpl::rpc::v1::RootIndex* DirectoryNode::release_root_index() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DirectoryNode.root_index)
  
  ::org::xrpl::rpc::v1::RootIndex* temp = root_index_;
  root_index_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::RootIndex* DirectoryNode::mutable_root_index() {
  
  if (root_index_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::RootIndex>(GetArenaNoVirtual());
    root_index_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DirectoryNode.root_index)
  return root_index_;
}
inline void DirectoryNode::set_allocated_root_index(::org::xrpl::rpc::v1::RootIndex* root_index) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(root_index_);
  }
  if (root_index) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      root_index = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root_index, submessage_arena);
    }
    
  } else {
    
  }
  root_index_ = root_index;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DirectoryNode.root_index)
}

// repeated .org.xrpl.rpc.v1.Index indexes = 3;
inline int DirectoryNode::indexes_size() const {
  return indexes_.size();
}
inline ::org::xrpl::rpc::v1::Index* DirectoryNode::mutable_indexes(int index) {
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DirectoryNode.indexes)
  return indexes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Index >*
DirectoryNode::mutable_indexes() {
  // @@protoc_insertion_point(field_mutable_list:org.xrpl.rpc.v1.DirectoryNode.indexes)
  return &indexes_;
}
inline const ::org::xrpl::rpc::v1::Index& DirectoryNode::indexes(int index) const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DirectoryNode.indexes)
  return indexes_.Get(index);
}
inline ::org::xrpl::rpc::v1::Index* DirectoryNode::add_indexes() {
  // @@protoc_insertion_point(field_add:org.xrpl.rpc.v1.DirectoryNode.indexes)
  return indexes_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Index >&
DirectoryNode::indexes() const {
  // @@protoc_insertion_point(field_list:org.xrpl.rpc.v1.DirectoryNode.indexes)
  return indexes_;
}

// .org.xrpl.rpc.v1.IndexNext index_next = 4;
inline bool DirectoryNode::has_index_next() const {
  return this != internal_default_instance() && index_next_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::IndexNext& DirectoryNode::index_next() const {
  const ::org::xrpl::rpc::v1::IndexNext* p = index_next_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DirectoryNode.index_next)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::IndexNext*>(
      &::org::xrpl::rpc::v1::_IndexNext_default_instance_);
}
inline ::org::xrpl::rpc::v1::IndexNext* DirectoryNode::release_index_next() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DirectoryNode.index_next)
  
  ::org::xrpl::rpc::v1::IndexNext* temp = index_next_;
  index_next_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::IndexNext* DirectoryNode::mutable_index_next() {
  
  if (index_next_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::IndexNext>(GetArenaNoVirtual());
    index_next_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DirectoryNode.index_next)
  return index_next_;
}
inline void DirectoryNode::set_allocated_index_next(::org::xrpl::rpc::v1::IndexNext* index_next) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(index_next_);
  }
  if (index_next) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      index_next = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, index_next, submessage_arena);
    }
    
  } else {
    
  }
  index_next_ = index_next;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DirectoryNode.index_next)
}

// .org.xrpl.rpc.v1.IndexPrevious index_previous = 5;
inline bool DirectoryNode::has_index_previous() const {
  return this != internal_default_instance() && index_previous_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::IndexPrevious& DirectoryNode::index_previous() const {
  const ::org::xrpl::rpc::v1::IndexPrevious* p = index_previous_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DirectoryNode.index_previous)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::IndexPrevious*>(
      &::org::xrpl::rpc::v1::_IndexPrevious_default_instance_);
}
inline ::org::xrpl::rpc::v1::IndexPrevious* DirectoryNode::release_index_previous() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DirectoryNode.index_previous)
  
  ::org::xrpl::rpc::v1::IndexPrevious* temp = index_previous_;
  index_previous_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::IndexPrevious* DirectoryNode::mutable_index_previous() {
  
  if (index_previous_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::IndexPrevious>(GetArenaNoVirtual());
    index_previous_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DirectoryNode.index_previous)
  return index_previous_;
}
inline void DirectoryNode::set_allocated_index_previous(::org::xrpl::rpc::v1::IndexPrevious* index_previous) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(index_previous_);
  }
  if (index_previous) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      index_previous = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, index_previous, submessage_arena);
    }
    
  } else {
    
  }
  index_previous_ = index_previous;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DirectoryNode.index_previous)
}

// .org.xrpl.rpc.v1.Owner owner = 6;
inline bool DirectoryNode::has_owner() const {
  return this != internal_default_instance() && owner_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Owner& DirectoryNode::owner() const {
  const ::org::xrpl::rpc::v1::Owner* p = owner_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DirectoryNode.owner)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Owner*>(
      &::org::xrpl::rpc::v1::_Owner_default_instance_);
}
inline ::org::xrpl::rpc::v1::Owner* DirectoryNode::release_owner() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DirectoryNode.owner)
  
  ::org::xrpl::rpc::v1::Owner* temp = owner_;
  owner_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Owner* DirectoryNode::mutable_owner() {
  
  if (owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Owner>(GetArenaNoVirtual());
    owner_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DirectoryNode.owner)
  return owner_;
}
inline void DirectoryNode::set_allocated_owner(::org::xrpl::rpc::v1::Owner* owner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_);
  }
  if (owner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      owner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    
  } else {
    
  }
  owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DirectoryNode.owner)
}

// .org.xrpl.rpc.v1.TakerPaysCurrency taker_pays_currency = 7;
inline bool DirectoryNode::has_taker_pays_currency() const {
  return this != internal_default_instance() && taker_pays_currency_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::TakerPaysCurrency& DirectoryNode::taker_pays_currency() const {
  const ::org::xrpl::rpc::v1::TakerPaysCurrency* p = taker_pays_currency_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DirectoryNode.taker_pays_currency)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::TakerPaysCurrency*>(
      &::org::xrpl::rpc::v1::_TakerPaysCurrency_default_instance_);
}
inline ::org::xrpl::rpc::v1::TakerPaysCurrency* DirectoryNode::release_taker_pays_currency() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DirectoryNode.taker_pays_currency)
  
  ::org::xrpl::rpc::v1::TakerPaysCurrency* temp = taker_pays_currency_;
  taker_pays_currency_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::TakerPaysCurrency* DirectoryNode::mutable_taker_pays_currency() {
  
  if (taker_pays_currency_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::TakerPaysCurrency>(GetArenaNoVirtual());
    taker_pays_currency_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DirectoryNode.taker_pays_currency)
  return taker_pays_currency_;
}
inline void DirectoryNode::set_allocated_taker_pays_currency(::org::xrpl::rpc::v1::TakerPaysCurrency* taker_pays_currency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(taker_pays_currency_);
  }
  if (taker_pays_currency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      taker_pays_currency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, taker_pays_currency, submessage_arena);
    }
    
  } else {
    
  }
  taker_pays_currency_ = taker_pays_currency;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DirectoryNode.taker_pays_currency)
}

// .org.xrpl.rpc.v1.TakerPaysIssuer taker_pays_issuer = 8;
inline bool DirectoryNode::has_taker_pays_issuer() const {
  return this != internal_default_instance() && taker_pays_issuer_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::TakerPaysIssuer& DirectoryNode::taker_pays_issuer() const {
  const ::org::xrpl::rpc::v1::TakerPaysIssuer* p = taker_pays_issuer_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DirectoryNode.taker_pays_issuer)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::TakerPaysIssuer*>(
      &::org::xrpl::rpc::v1::_TakerPaysIssuer_default_instance_);
}
inline ::org::xrpl::rpc::v1::TakerPaysIssuer* DirectoryNode::release_taker_pays_issuer() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DirectoryNode.taker_pays_issuer)
  
  ::org::xrpl::rpc::v1::TakerPaysIssuer* temp = taker_pays_issuer_;
  taker_pays_issuer_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::TakerPaysIssuer* DirectoryNode::mutable_taker_pays_issuer() {
  
  if (taker_pays_issuer_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::TakerPaysIssuer>(GetArenaNoVirtual());
    taker_pays_issuer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DirectoryNode.taker_pays_issuer)
  return taker_pays_issuer_;
}
inline void DirectoryNode::set_allocated_taker_pays_issuer(::org::xrpl::rpc::v1::TakerPaysIssuer* taker_pays_issuer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(taker_pays_issuer_);
  }
  if (taker_pays_issuer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      taker_pays_issuer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, taker_pays_issuer, submessage_arena);
    }
    
  } else {
    
  }
  taker_pays_issuer_ = taker_pays_issuer;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DirectoryNode.taker_pays_issuer)
}

// .org.xrpl.rpc.v1.TakerGetsCurreny taker_gets_currency = 9;
inline bool DirectoryNode::has_taker_gets_currency() const {
  return this != internal_default_instance() && taker_gets_currency_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::TakerGetsCurreny& DirectoryNode::taker_gets_currency() const {
  const ::org::xrpl::rpc::v1::TakerGetsCurreny* p = taker_gets_currency_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DirectoryNode.taker_gets_currency)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::TakerGetsCurreny*>(
      &::org::xrpl::rpc::v1::_TakerGetsCurreny_default_instance_);
}
inline ::org::xrpl::rpc::v1::TakerGetsCurreny* DirectoryNode::release_taker_gets_currency() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DirectoryNode.taker_gets_currency)
  
  ::org::xrpl::rpc::v1::TakerGetsCurreny* temp = taker_gets_currency_;
  taker_gets_currency_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::TakerGetsCurreny* DirectoryNode::mutable_taker_gets_currency() {
  
  if (taker_gets_currency_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::TakerGetsCurreny>(GetArenaNoVirtual());
    taker_gets_currency_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DirectoryNode.taker_gets_currency)
  return taker_gets_currency_;
}
inline void DirectoryNode::set_allocated_taker_gets_currency(::org::xrpl::rpc::v1::TakerGetsCurreny* taker_gets_currency) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(taker_gets_currency_);
  }
  if (taker_gets_currency) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      taker_gets_currency = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, taker_gets_currency, submessage_arena);
    }
    
  } else {
    
  }
  taker_gets_currency_ = taker_gets_currency;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DirectoryNode.taker_gets_currency)
}

// .org.xrpl.rpc.v1.TakerGetsIssuer taker_gets_issuer = 10;
inline bool DirectoryNode::has_taker_gets_issuer() const {
  return this != internal_default_instance() && taker_gets_issuer_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::TakerGetsIssuer& DirectoryNode::taker_gets_issuer() const {
  const ::org::xrpl::rpc::v1::TakerGetsIssuer* p = taker_gets_issuer_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.DirectoryNode.taker_gets_issuer)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::TakerGetsIssuer*>(
      &::org::xrpl::rpc::v1::_TakerGetsIssuer_default_instance_);
}
inline ::org::xrpl::rpc::v1::TakerGetsIssuer* DirectoryNode::release_taker_gets_issuer() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.DirectoryNode.taker_gets_issuer)
  
  ::org::xrpl::rpc::v1::TakerGetsIssuer* temp = taker_gets_issuer_;
  taker_gets_issuer_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::TakerGetsIssuer* DirectoryNode::mutable_taker_gets_issuer() {
  
  if (taker_gets_issuer_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::TakerGetsIssuer>(GetArenaNoVirtual());
    taker_gets_issuer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.DirectoryNode.taker_gets_issuer)
  return taker_gets_issuer_;
}
inline void DirectoryNode::set_allocated_taker_gets_issuer(::org::xrpl::rpc::v1::TakerGetsIssuer* taker_gets_issuer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(taker_gets_issuer_);
  }
  if (taker_gets_issuer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      taker_gets_issuer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, taker_gets_issuer, submessage_arena);
    }
    
  } else {
    
  }
  taker_gets_issuer_ = taker_gets_issuer;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.DirectoryNode.taker_gets_issuer)
}

// -------------------------------------------------------------------

// Escrow

// .org.xrpl.rpc.v1.Account account = 1;
inline bool Escrow::has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Account& Escrow::account() const {
  const ::org::xrpl::rpc::v1::Account* p = account_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Escrow.account)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Account*>(
      &::org::xrpl::rpc::v1::_Account_default_instance_);
}
inline ::org::xrpl::rpc::v1::Account* Escrow::release_account() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Escrow.account)
  
  ::org::xrpl::rpc::v1::Account* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Account* Escrow::mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Account>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Escrow.account)
  return account_;
}
inline void Escrow::set_allocated_account(::org::xrpl::rpc::v1::Account* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Escrow.account)
}

// .org.xrpl.rpc.v1.Destination destination = 2;
inline bool Escrow::has_destination() const {
  return this != internal_default_instance() && destination_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Destination& Escrow::destination() const {
  const ::org::xrpl::rpc::v1::Destination* p = destination_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Escrow.destination)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Destination*>(
      &::org::xrpl::rpc::v1::_Destination_default_instance_);
}
inline ::org::xrpl::rpc::v1::Destination* Escrow::release_destination() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Escrow.destination)
  
  ::org::xrpl::rpc::v1::Destination* temp = destination_;
  destination_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Destination* Escrow::mutable_destination() {
  
  if (destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Destination>(GetArenaNoVirtual());
    destination_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Escrow.destination)
  return destination_;
}
inline void Escrow::set_allocated_destination(::org::xrpl::rpc::v1::Destination* destination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_);
  }
  if (destination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      destination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination, submessage_arena);
    }
    
  } else {
    
  }
  destination_ = destination;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Escrow.destination)
}

// .org.xrpl.rpc.v1.Amount amount = 3;
inline bool Escrow::has_amount() const {
  return this != internal_default_instance() && amount_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Amount& Escrow::amount() const {
  const ::org::xrpl::rpc::v1::Amount* p = amount_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Escrow.amount)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Amount*>(
      &::org::xrpl::rpc::v1::_Amount_default_instance_);
}
inline ::org::xrpl::rpc::v1::Amount* Escrow::release_amount() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Escrow.amount)
  
  ::org::xrpl::rpc::v1::Amount* temp = amount_;
  amount_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Amount* Escrow::mutable_amount() {
  
  if (amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Amount>(GetArenaNoVirtual());
    amount_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Escrow.amount)
  return amount_;
}
inline void Escrow::set_allocated_amount(::org::xrpl::rpc::v1::Amount* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    
  } else {
    
  }
  amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Escrow.amount)
}

// .org.xrpl.rpc.v1.Condition condition = 4;
inline bool Escrow::has_condition() const {
  return this != internal_default_instance() && condition_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Condition& Escrow::condition() const {
  const ::org::xrpl::rpc::v1::Condition* p = condition_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Escrow.condition)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Condition*>(
      &::org::xrpl::rpc::v1::_Condition_default_instance_);
}
inline ::org::xrpl::rpc::v1::Condition* Escrow::release_condition() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Escrow.condition)
  
  ::org::xrpl::rpc::v1::Condition* temp = condition_;
  condition_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Condition* Escrow::mutable_condition() {
  
  if (condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Condition>(GetArenaNoVirtual());
    condition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Escrow.condition)
  return condition_;
}
inline void Escrow::set_allocated_condition(::org::xrpl::rpc::v1::Condition* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(condition_);
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    
  } else {
    
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Escrow.condition)
}

// .org.xrpl.rpc.v1.CancelAfter cancel_after = 5;
inline bool Escrow::has_cancel_after() const {
  return this != internal_default_instance() && cancel_after_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::CancelAfter& Escrow::cancel_after() const {
  const ::org::xrpl::rpc::v1::CancelAfter* p = cancel_after_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Escrow.cancel_after)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::CancelAfter*>(
      &::org::xrpl::rpc::v1::_CancelAfter_default_instance_);
}
inline ::org::xrpl::rpc::v1::CancelAfter* Escrow::release_cancel_after() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Escrow.cancel_after)
  
  ::org::xrpl::rpc::v1::CancelAfter* temp = cancel_after_;
  cancel_after_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::CancelAfter* Escrow::mutable_cancel_after() {
  
  if (cancel_after_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::CancelAfter>(GetArenaNoVirtual());
    cancel_after_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Escrow.cancel_after)
  return cancel_after_;
}
inline void Escrow::set_allocated_cancel_after(::org::xrpl::rpc::v1::CancelAfter* cancel_after) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cancel_after_);
  }
  if (cancel_after) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cancel_after = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cancel_after, submessage_arena);
    }
    
  } else {
    
  }
  cancel_after_ = cancel_after;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Escrow.cancel_after)
}

// .org.xrpl.rpc.v1.FinishAfter finish_after = 6;
inline bool Escrow::has_finish_after() const {
  return this != internal_default_instance() && finish_after_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::FinishAfter& Escrow::finish_after() const {
  const ::org::xrpl::rpc::v1::FinishAfter* p = finish_after_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Escrow.finish_after)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::FinishAfter*>(
      &::org::xrpl::rpc::v1::_FinishAfter_default_instance_);
}
inline ::org::xrpl::rpc::v1::FinishAfter* Escrow::release_finish_after() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Escrow.finish_after)
  
  ::org::xrpl::rpc::v1::FinishAfter* temp = finish_after_;
  finish_after_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::FinishAfter* Escrow::mutable_finish_after() {
  
  if (finish_after_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::FinishAfter>(GetArenaNoVirtual());
    finish_after_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Escrow.finish_after)
  return finish_after_;
}
inline void Escrow::set_allocated_finish_after(::org::xrpl::rpc::v1::FinishAfter* finish_after) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(finish_after_);
  }
  if (finish_after) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      finish_after = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, finish_after, submessage_arena);
    }
    
  } else {
    
  }
  finish_after_ = finish_after;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Escrow.finish_after)
}

// .org.xrpl.rpc.v1.Flags flags = 7;
inline bool Escrow::has_flags() const {
  return this != internal_default_instance() && flags_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Flags& Escrow::flags() const {
  const ::org::xrpl::rpc::v1::Flags* p = flags_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Escrow.flags)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Flags*>(
      &::org::xrpl::rpc::v1::_Flags_default_instance_);
}
inline ::org::xrpl::rpc::v1::Flags* Escrow::release_flags() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Escrow.flags)
  
  ::org::xrpl::rpc::v1::Flags* temp = flags_;
  flags_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Flags* Escrow::mutable_flags() {
  
  if (flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Flags>(GetArenaNoVirtual());
    flags_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Escrow.flags)
  return flags_;
}
inline void Escrow::set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flags_);
  }
  if (flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flags, submessage_arena);
    }
    
  } else {
    
  }
  flags_ = flags;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Escrow.flags)
}

// .org.xrpl.rpc.v1.SourceTag source_tag = 8;
inline bool Escrow::has_source_tag() const {
  return this != internal_default_instance() && source_tag_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::SourceTag& Escrow::source_tag() const {
  const ::org::xrpl::rpc::v1::SourceTag* p = source_tag_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Escrow.source_tag)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::SourceTag*>(
      &::org::xrpl::rpc::v1::_SourceTag_default_instance_);
}
inline ::org::xrpl::rpc::v1::SourceTag* Escrow::release_source_tag() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Escrow.source_tag)
  
  ::org::xrpl::rpc::v1::SourceTag* temp = source_tag_;
  source_tag_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::SourceTag* Escrow::mutable_source_tag() {
  
  if (source_tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::SourceTag>(GetArenaNoVirtual());
    source_tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Escrow.source_tag)
  return source_tag_;
}
inline void Escrow::set_allocated_source_tag(::org::xrpl::rpc::v1::SourceTag* source_tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_tag_);
  }
  if (source_tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source_tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_tag, submessage_arena);
    }
    
  } else {
    
  }
  source_tag_ = source_tag;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Escrow.source_tag)
}

// .org.xrpl.rpc.v1.DestinationTag destination_tag = 9;
inline bool Escrow::has_destination_tag() const {
  return this != internal_default_instance() && destination_tag_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::DestinationTag& Escrow::destination_tag() const {
  const ::org::xrpl::rpc::v1::DestinationTag* p = destination_tag_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Escrow.destination_tag)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::DestinationTag*>(
      &::org::xrpl::rpc::v1::_DestinationTag_default_instance_);
}
inline ::org::xrpl::rpc::v1::DestinationTag* Escrow::release_destination_tag() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Escrow.destination_tag)
  
  ::org::xrpl::rpc::v1::DestinationTag* temp = destination_tag_;
  destination_tag_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::DestinationTag* Escrow::mutable_destination_tag() {
  
  if (destination_tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::DestinationTag>(GetArenaNoVirtual());
    destination_tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Escrow.destination_tag)
  return destination_tag_;
}
inline void Escrow::set_allocated_destination_tag(::org::xrpl::rpc::v1::DestinationTag* destination_tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_tag_);
  }
  if (destination_tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      destination_tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination_tag, submessage_arena);
    }
    
  } else {
    
  }
  destination_tag_ = destination_tag;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Escrow.destination_tag)
}

// .org.xrpl.rpc.v1.OwnerNode owner_node = 10;
inline bool Escrow::has_owner_node() const {
  return this != internal_default_instance() && owner_node_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::OwnerNode& Escrow::owner_node() const {
  const ::org::xrpl::rpc::v1::OwnerNode* p = owner_node_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Escrow.owner_node)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::OwnerNode*>(
      &::org::xrpl::rpc::v1::_OwnerNode_default_instance_);
}
inline ::org::xrpl::rpc::v1::OwnerNode* Escrow::release_owner_node() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Escrow.owner_node)
  
  ::org::xrpl::rpc::v1::OwnerNode* temp = owner_node_;
  owner_node_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::OwnerNode* Escrow::mutable_owner_node() {
  
  if (owner_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::OwnerNode>(GetArenaNoVirtual());
    owner_node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Escrow.owner_node)
  return owner_node_;
}
inline void Escrow::set_allocated_owner_node(::org::xrpl::rpc::v1::OwnerNode* owner_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_node_);
  }
  if (owner_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      owner_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_node, submessage_arena);
    }
    
  } else {
    
  }
  owner_node_ = owner_node;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Escrow.owner_node)
}

// .org.xrpl.rpc.v1.DestinationNode destination_node = 11;
inline bool Escrow::has_destination_node() const {
  return this != internal_default_instance() && destination_node_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::DestinationNode& Escrow::destination_node() const {
  const ::org::xrpl::rpc::v1::DestinationNode* p = destination_node_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Escrow.destination_node)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::DestinationNode*>(
      &::org::xrpl::rpc::v1::_DestinationNode_default_instance_);
}
inline ::org::xrpl::rpc::v1::DestinationNode* Escrow::release_destination_node() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Escrow.destination_node)
  
  ::org::xrpl::rpc::v1::DestinationNode* temp = destination_node_;
  destination_node_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::DestinationNode* Escrow::mutable_destination_node() {
  
  if (destination_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::DestinationNode>(GetArenaNoVirtual());
    destination_node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Escrow.destination_node)
  return destination_node_;
}
inline void Escrow::set_allocated_destination_node(::org::xrpl::rpc::v1::DestinationNode* destination_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_node_);
  }
  if (destination_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      destination_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination_node, submessage_arena);
    }
    
  } else {
    
  }
  destination_node_ = destination_node;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Escrow.destination_node)
}

// .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 12;
inline bool Escrow::has_previous_transaction_id() const {
  return this != internal_default_instance() && previous_transaction_id_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionID& Escrow::previous_transaction_id() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionID* p = previous_transaction_id_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Escrow.previous_transaction_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionID*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionID_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* Escrow::release_previous_transaction_id() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Escrow.previous_transaction_id)
  
  ::org::xrpl::rpc::v1::PreviousTransactionID* temp = previous_transaction_id_;
  previous_transaction_id_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* Escrow::mutable_previous_transaction_id() {
  
  if (previous_transaction_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionID>(GetArenaNoVirtual());
    previous_transaction_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Escrow.previous_transaction_id)
  return previous_transaction_id_;
}
inline void Escrow::set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_id_);
  }
  if (previous_transaction_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_id, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_id_ = previous_transaction_id;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Escrow.previous_transaction_id)
}

// .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 13;
inline bool Escrow::has_previous_transaction_ledger_sequence() const {
  return this != internal_default_instance() && previous_transaction_ledger_sequence_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& Escrow::previous_transaction_ledger_sequence() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* p = previous_transaction_ledger_sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Escrow.previous_transaction_ledger_sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionLedgerSequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* Escrow::release_previous_transaction_ledger_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Escrow.previous_transaction_ledger_sequence)
  
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* temp = previous_transaction_ledger_sequence_;
  previous_transaction_ledger_sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* Escrow::mutable_previous_transaction_ledger_sequence() {
  
  if (previous_transaction_ledger_sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence>(GetArenaNoVirtual());
    previous_transaction_ledger_sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Escrow.previous_transaction_ledger_sequence)
  return previous_transaction_ledger_sequence_;
}
inline void Escrow::set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_ledger_sequence_);
  }
  if (previous_transaction_ledger_sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_ledger_sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_ledger_sequence, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_ledger_sequence_ = previous_transaction_ledger_sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Escrow.previous_transaction_ledger_sequence)
}

// -------------------------------------------------------------------

// FeeSettings

// .org.xrpl.rpc.v1.BaseFee base_fee = 1;
inline bool FeeSettings::has_base_fee() const {
  return this != internal_default_instance() && base_fee_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::BaseFee& FeeSettings::base_fee() const {
  const ::org::xrpl::rpc::v1::BaseFee* p = base_fee_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.FeeSettings.base_fee)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::BaseFee*>(
      &::org::xrpl::rpc::v1::_BaseFee_default_instance_);
}
inline ::org::xrpl::rpc::v1::BaseFee* FeeSettings::release_base_fee() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.FeeSettings.base_fee)
  
  ::org::xrpl::rpc::v1::BaseFee* temp = base_fee_;
  base_fee_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::BaseFee* FeeSettings::mutable_base_fee() {
  
  if (base_fee_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::BaseFee>(GetArenaNoVirtual());
    base_fee_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.FeeSettings.base_fee)
  return base_fee_;
}
inline void FeeSettings::set_allocated_base_fee(::org::xrpl::rpc::v1::BaseFee* base_fee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_fee_);
  }
  if (base_fee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      base_fee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base_fee, submessage_arena);
    }
    
  } else {
    
  }
  base_fee_ = base_fee;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.FeeSettings.base_fee)
}

// .org.xrpl.rpc.v1.ReferenceFeeUnits reference_fee_units = 2;
inline bool FeeSettings::has_reference_fee_units() const {
  return this != internal_default_instance() && reference_fee_units_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::ReferenceFeeUnits& FeeSettings::reference_fee_units() const {
  const ::org::xrpl::rpc::v1::ReferenceFeeUnits* p = reference_fee_units_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.FeeSettings.reference_fee_units)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::ReferenceFeeUnits*>(
      &::org::xrpl::rpc::v1::_ReferenceFeeUnits_default_instance_);
}
inline ::org::xrpl::rpc::v1::ReferenceFeeUnits* FeeSettings::release_reference_fee_units() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.FeeSettings.reference_fee_units)
  
  ::org::xrpl::rpc::v1::ReferenceFeeUnits* temp = reference_fee_units_;
  reference_fee_units_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::ReferenceFeeUnits* FeeSettings::mutable_reference_fee_units() {
  
  if (reference_fee_units_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::ReferenceFeeUnits>(GetArenaNoVirtual());
    reference_fee_units_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.FeeSettings.reference_fee_units)
  return reference_fee_units_;
}
inline void FeeSettings::set_allocated_reference_fee_units(::org::xrpl::rpc::v1::ReferenceFeeUnits* reference_fee_units) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(reference_fee_units_);
  }
  if (reference_fee_units) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reference_fee_units = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference_fee_units, submessage_arena);
    }
    
  } else {
    
  }
  reference_fee_units_ = reference_fee_units;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.FeeSettings.reference_fee_units)
}

// .org.xrpl.rpc.v1.ReserveBase reserve_base = 3;
inline bool FeeSettings::has_reserve_base() const {
  return this != internal_default_instance() && reserve_base_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::ReserveBase& FeeSettings::reserve_base() const {
  const ::org::xrpl::rpc::v1::ReserveBase* p = reserve_base_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.FeeSettings.reserve_base)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::ReserveBase*>(
      &::org::xrpl::rpc::v1::_ReserveBase_default_instance_);
}
inline ::org::xrpl::rpc::v1::ReserveBase* FeeSettings::release_reserve_base() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.FeeSettings.reserve_base)
  
  ::org::xrpl::rpc::v1::ReserveBase* temp = reserve_base_;
  reserve_base_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::ReserveBase* FeeSettings::mutable_reserve_base() {
  
  if (reserve_base_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::ReserveBase>(GetArenaNoVirtual());
    reserve_base_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.FeeSettings.reserve_base)
  return reserve_base_;
}
inline void FeeSettings::set_allocated_reserve_base(::org::xrpl::rpc::v1::ReserveBase* reserve_base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(reserve_base_);
  }
  if (reserve_base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reserve_base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reserve_base, submessage_arena);
    }
    
  } else {
    
  }
  reserve_base_ = reserve_base;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.FeeSettings.reserve_base)
}

// .org.xrpl.rpc.v1.ReserveIncrement reserve_increment = 4;
inline bool FeeSettings::has_reserve_increment() const {
  return this != internal_default_instance() && reserve_increment_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::ReserveIncrement& FeeSettings::reserve_increment() const {
  const ::org::xrpl::rpc::v1::ReserveIncrement* p = reserve_increment_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.FeeSettings.reserve_increment)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::ReserveIncrement*>(
      &::org::xrpl::rpc::v1::_ReserveIncrement_default_instance_);
}
inline ::org::xrpl::rpc::v1::ReserveIncrement* FeeSettings::release_reserve_increment() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.FeeSettings.reserve_increment)
  
  ::org::xrpl::rpc::v1::ReserveIncrement* temp = reserve_increment_;
  reserve_increment_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::ReserveIncrement* FeeSettings::mutable_reserve_increment() {
  
  if (reserve_increment_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::ReserveIncrement>(GetArenaNoVirtual());
    reserve_increment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.FeeSettings.reserve_increment)
  return reserve_increment_;
}
inline void FeeSettings::set_allocated_reserve_increment(::org::xrpl::rpc::v1::ReserveIncrement* reserve_increment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(reserve_increment_);
  }
  if (reserve_increment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reserve_increment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reserve_increment, submessage_arena);
    }
    
  } else {
    
  }
  reserve_increment_ = reserve_increment;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.FeeSettings.reserve_increment)
}

// .org.xrpl.rpc.v1.Flags flags = 5;
inline bool FeeSettings::has_flags() const {
  return this != internal_default_instance() && flags_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Flags& FeeSettings::flags() const {
  const ::org::xrpl::rpc::v1::Flags* p = flags_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.FeeSettings.flags)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Flags*>(
      &::org::xrpl::rpc::v1::_Flags_default_instance_);
}
inline ::org::xrpl::rpc::v1::Flags* FeeSettings::release_flags() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.FeeSettings.flags)
  
  ::org::xrpl::rpc::v1::Flags* temp = flags_;
  flags_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Flags* FeeSettings::mutable_flags() {
  
  if (flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Flags>(GetArenaNoVirtual());
    flags_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.FeeSettings.flags)
  return flags_;
}
inline void FeeSettings::set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flags_);
  }
  if (flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flags, submessage_arena);
    }
    
  } else {
    
  }
  flags_ = flags;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.FeeSettings.flags)
}

// -------------------------------------------------------------------

// LedgerHashes

// .org.xrpl.rpc.v1.LastLedgerSequence last_ledger_sequence = 1;
inline bool LedgerHashes::has_last_ledger_sequence() const {
  return this != internal_default_instance() && last_ledger_sequence_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::LastLedgerSequence& LedgerHashes::last_ledger_sequence() const {
  const ::org::xrpl::rpc::v1::LastLedgerSequence* p = last_ledger_sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerHashes.last_ledger_sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::LastLedgerSequence*>(
      &::org::xrpl::rpc::v1::_LastLedgerSequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::LastLedgerSequence* LedgerHashes::release_last_ledger_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LedgerHashes.last_ledger_sequence)
  
  ::org::xrpl::rpc::v1::LastLedgerSequence* temp = last_ledger_sequence_;
  last_ledger_sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::LastLedgerSequence* LedgerHashes::mutable_last_ledger_sequence() {
  
  if (last_ledger_sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::LastLedgerSequence>(GetArenaNoVirtual());
    last_ledger_sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerHashes.last_ledger_sequence)
  return last_ledger_sequence_;
}
inline void LedgerHashes::set_allocated_last_ledger_sequence(::org::xrpl::rpc::v1::LastLedgerSequence* last_ledger_sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_ledger_sequence_);
  }
  if (last_ledger_sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      last_ledger_sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_ledger_sequence, submessage_arena);
    }
    
  } else {
    
  }
  last_ledger_sequence_ = last_ledger_sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.LedgerHashes.last_ledger_sequence)
}

// repeated .org.xrpl.rpc.v1.Hash hashes = 2;
inline int LedgerHashes::hashes_size() const {
  return hashes_.size();
}
inline ::org::xrpl::rpc::v1::Hash* LedgerHashes::mutable_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerHashes.hashes)
  return hashes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Hash >*
LedgerHashes::mutable_hashes() {
  // @@protoc_insertion_point(field_mutable_list:org.xrpl.rpc.v1.LedgerHashes.hashes)
  return &hashes_;
}
inline const ::org::xrpl::rpc::v1::Hash& LedgerHashes::hashes(int index) const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerHashes.hashes)
  return hashes_.Get(index);
}
inline ::org::xrpl::rpc::v1::Hash* LedgerHashes::add_hashes() {
  // @@protoc_insertion_point(field_add:org.xrpl.rpc.v1.LedgerHashes.hashes)
  return hashes_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::Hash >&
LedgerHashes::hashes() const {
  // @@protoc_insertion_point(field_list:org.xrpl.rpc.v1.LedgerHashes.hashes)
  return hashes_;
}

// .org.xrpl.rpc.v1.Flags flags = 3;
inline bool LedgerHashes::has_flags() const {
  return this != internal_default_instance() && flags_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Flags& LedgerHashes::flags() const {
  const ::org::xrpl::rpc::v1::Flags* p = flags_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.LedgerHashes.flags)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Flags*>(
      &::org::xrpl::rpc::v1::_Flags_default_instance_);
}
inline ::org::xrpl::rpc::v1::Flags* LedgerHashes::release_flags() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.LedgerHashes.flags)
  
  ::org::xrpl::rpc::v1::Flags* temp = flags_;
  flags_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Flags* LedgerHashes::mutable_flags() {
  
  if (flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Flags>(GetArenaNoVirtual());
    flags_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.LedgerHashes.flags)
  return flags_;
}
inline void LedgerHashes::set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flags_);
  }
  if (flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flags, submessage_arena);
    }
    
  } else {
    
  }
  flags_ = flags;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.LedgerHashes.flags)
}

// -------------------------------------------------------------------

// Offer

// .org.xrpl.rpc.v1.Account account = 1;
inline bool Offer::has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Account& Offer::account() const {
  const ::org::xrpl::rpc::v1::Account* p = account_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Offer.account)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Account*>(
      &::org::xrpl::rpc::v1::_Account_default_instance_);
}
inline ::org::xrpl::rpc::v1::Account* Offer::release_account() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Offer.account)
  
  ::org::xrpl::rpc::v1::Account* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Account* Offer::mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Account>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Offer.account)
  return account_;
}
inline void Offer::set_allocated_account(::org::xrpl::rpc::v1::Account* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Offer.account)
}

// .org.xrpl.rpc.v1.Sequence sequence = 2;
inline bool Offer::has_sequence() const {
  return this != internal_default_instance() && sequence_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Sequence& Offer::sequence() const {
  const ::org::xrpl::rpc::v1::Sequence* p = sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Offer.sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Sequence*>(
      &::org::xrpl::rpc::v1::_Sequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::Sequence* Offer::release_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Offer.sequence)
  
  ::org::xrpl::rpc::v1::Sequence* temp = sequence_;
  sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Sequence* Offer::mutable_sequence() {
  
  if (sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Sequence>(GetArenaNoVirtual());
    sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Offer.sequence)
  return sequence_;
}
inline void Offer::set_allocated_sequence(::org::xrpl::rpc::v1::Sequence* sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sequence_);
  }
  if (sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sequence, submessage_arena);
    }
    
  } else {
    
  }
  sequence_ = sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Offer.sequence)
}

// .org.xrpl.rpc.v1.Flags flags = 3;
inline bool Offer::has_flags() const {
  return this != internal_default_instance() && flags_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Flags& Offer::flags() const {
  const ::org::xrpl::rpc::v1::Flags* p = flags_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Offer.flags)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Flags*>(
      &::org::xrpl::rpc::v1::_Flags_default_instance_);
}
inline ::org::xrpl::rpc::v1::Flags* Offer::release_flags() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Offer.flags)
  
  ::org::xrpl::rpc::v1::Flags* temp = flags_;
  flags_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Flags* Offer::mutable_flags() {
  
  if (flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Flags>(GetArenaNoVirtual());
    flags_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Offer.flags)
  return flags_;
}
inline void Offer::set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flags_);
  }
  if (flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flags, submessage_arena);
    }
    
  } else {
    
  }
  flags_ = flags;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Offer.flags)
}

// .org.xrpl.rpc.v1.TakerPays taker_pays = 4;
inline bool Offer::has_taker_pays() const {
  return this != internal_default_instance() && taker_pays_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::TakerPays& Offer::taker_pays() const {
  const ::org::xrpl::rpc::v1::TakerPays* p = taker_pays_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Offer.taker_pays)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::TakerPays*>(
      &::org::xrpl::rpc::v1::_TakerPays_default_instance_);
}
inline ::org::xrpl::rpc::v1::TakerPays* Offer::release_taker_pays() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Offer.taker_pays)
  
  ::org::xrpl::rpc::v1::TakerPays* temp = taker_pays_;
  taker_pays_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::TakerPays* Offer::mutable_taker_pays() {
  
  if (taker_pays_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::TakerPays>(GetArenaNoVirtual());
    taker_pays_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Offer.taker_pays)
  return taker_pays_;
}
inline void Offer::set_allocated_taker_pays(::org::xrpl::rpc::v1::TakerPays* taker_pays) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(taker_pays_);
  }
  if (taker_pays) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      taker_pays = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, taker_pays, submessage_arena);
    }
    
  } else {
    
  }
  taker_pays_ = taker_pays;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Offer.taker_pays)
}

// .org.xrpl.rpc.v1.TakerGets taker_gets = 5;
inline bool Offer::has_taker_gets() const {
  return this != internal_default_instance() && taker_gets_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::TakerGets& Offer::taker_gets() const {
  const ::org::xrpl::rpc::v1::TakerGets* p = taker_gets_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Offer.taker_gets)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::TakerGets*>(
      &::org::xrpl::rpc::v1::_TakerGets_default_instance_);
}
inline ::org::xrpl::rpc::v1::TakerGets* Offer::release_taker_gets() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Offer.taker_gets)
  
  ::org::xrpl::rpc::v1::TakerGets* temp = taker_gets_;
  taker_gets_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::TakerGets* Offer::mutable_taker_gets() {
  
  if (taker_gets_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::TakerGets>(GetArenaNoVirtual());
    taker_gets_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Offer.taker_gets)
  return taker_gets_;
}
inline void Offer::set_allocated_taker_gets(::org::xrpl::rpc::v1::TakerGets* taker_gets) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(taker_gets_);
  }
  if (taker_gets) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      taker_gets = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, taker_gets, submessage_arena);
    }
    
  } else {
    
  }
  taker_gets_ = taker_gets;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Offer.taker_gets)
}

// .org.xrpl.rpc.v1.BookDirectory book_directory = 6;
inline bool Offer::has_book_directory() const {
  return this != internal_default_instance() && book_directory_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::BookDirectory& Offer::book_directory() const {
  const ::org::xrpl::rpc::v1::BookDirectory* p = book_directory_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Offer.book_directory)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::BookDirectory*>(
      &::org::xrpl::rpc::v1::_BookDirectory_default_instance_);
}
inline ::org::xrpl::rpc::v1::BookDirectory* Offer::release_book_directory() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Offer.book_directory)
  
  ::org::xrpl::rpc::v1::BookDirectory* temp = book_directory_;
  book_directory_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::BookDirectory* Offer::mutable_book_directory() {
  
  if (book_directory_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::BookDirectory>(GetArenaNoVirtual());
    book_directory_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Offer.book_directory)
  return book_directory_;
}
inline void Offer::set_allocated_book_directory(::org::xrpl::rpc::v1::BookDirectory* book_directory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(book_directory_);
  }
  if (book_directory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      book_directory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, book_directory, submessage_arena);
    }
    
  } else {
    
  }
  book_directory_ = book_directory;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Offer.book_directory)
}

// .org.xrpl.rpc.v1.BookNode book_node = 7;
inline bool Offer::has_book_node() const {
  return this != internal_default_instance() && book_node_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::BookNode& Offer::book_node() const {
  const ::org::xrpl::rpc::v1::BookNode* p = book_node_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Offer.book_node)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::BookNode*>(
      &::org::xrpl::rpc::v1::_BookNode_default_instance_);
}
inline ::org::xrpl::rpc::v1::BookNode* Offer::release_book_node() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Offer.book_node)
  
  ::org::xrpl::rpc::v1::BookNode* temp = book_node_;
  book_node_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::BookNode* Offer::mutable_book_node() {
  
  if (book_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::BookNode>(GetArenaNoVirtual());
    book_node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Offer.book_node)
  return book_node_;
}
inline void Offer::set_allocated_book_node(::org::xrpl::rpc::v1::BookNode* book_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(book_node_);
  }
  if (book_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      book_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, book_node, submessage_arena);
    }
    
  } else {
    
  }
  book_node_ = book_node;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Offer.book_node)
}

// .org.xrpl.rpc.v1.OwnerNode owner_node = 8;
inline bool Offer::has_owner_node() const {
  return this != internal_default_instance() && owner_node_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::OwnerNode& Offer::owner_node() const {
  const ::org::xrpl::rpc::v1::OwnerNode* p = owner_node_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Offer.owner_node)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::OwnerNode*>(
      &::org::xrpl::rpc::v1::_OwnerNode_default_instance_);
}
inline ::org::xrpl::rpc::v1::OwnerNode* Offer::release_owner_node() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Offer.owner_node)
  
  ::org::xrpl::rpc::v1::OwnerNode* temp = owner_node_;
  owner_node_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::OwnerNode* Offer::mutable_owner_node() {
  
  if (owner_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::OwnerNode>(GetArenaNoVirtual());
    owner_node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Offer.owner_node)
  return owner_node_;
}
inline void Offer::set_allocated_owner_node(::org::xrpl::rpc::v1::OwnerNode* owner_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_node_);
  }
  if (owner_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      owner_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_node, submessage_arena);
    }
    
  } else {
    
  }
  owner_node_ = owner_node;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Offer.owner_node)
}

// .org.xrpl.rpc.v1.Expiration expiration = 9;
inline bool Offer::has_expiration() const {
  return this != internal_default_instance() && expiration_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Expiration& Offer::expiration() const {
  const ::org::xrpl::rpc::v1::Expiration* p = expiration_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Offer.expiration)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Expiration*>(
      &::org::xrpl::rpc::v1::_Expiration_default_instance_);
}
inline ::org::xrpl::rpc::v1::Expiration* Offer::release_expiration() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Offer.expiration)
  
  ::org::xrpl::rpc::v1::Expiration* temp = expiration_;
  expiration_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Expiration* Offer::mutable_expiration() {
  
  if (expiration_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Expiration>(GetArenaNoVirtual());
    expiration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Offer.expiration)
  return expiration_;
}
inline void Offer::set_allocated_expiration(::org::xrpl::rpc::v1::Expiration* expiration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(expiration_);
  }
  if (expiration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      expiration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expiration, submessage_arena);
    }
    
  } else {
    
  }
  expiration_ = expiration;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Offer.expiration)
}

// .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 10;
inline bool Offer::has_previous_transaction_id() const {
  return this != internal_default_instance() && previous_transaction_id_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionID& Offer::previous_transaction_id() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionID* p = previous_transaction_id_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Offer.previous_transaction_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionID*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionID_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* Offer::release_previous_transaction_id() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Offer.previous_transaction_id)
  
  ::org::xrpl::rpc::v1::PreviousTransactionID* temp = previous_transaction_id_;
  previous_transaction_id_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* Offer::mutable_previous_transaction_id() {
  
  if (previous_transaction_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionID>(GetArenaNoVirtual());
    previous_transaction_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Offer.previous_transaction_id)
  return previous_transaction_id_;
}
inline void Offer::set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_id_);
  }
  if (previous_transaction_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_id, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_id_ = previous_transaction_id;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Offer.previous_transaction_id)
}

// .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 11;
inline bool Offer::has_previous_transaction_ledger_sequence() const {
  return this != internal_default_instance() && previous_transaction_ledger_sequence_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& Offer::previous_transaction_ledger_sequence() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* p = previous_transaction_ledger_sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.Offer.previous_transaction_ledger_sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionLedgerSequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* Offer::release_previous_transaction_ledger_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.Offer.previous_transaction_ledger_sequence)
  
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* temp = previous_transaction_ledger_sequence_;
  previous_transaction_ledger_sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* Offer::mutable_previous_transaction_ledger_sequence() {
  
  if (previous_transaction_ledger_sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence>(GetArenaNoVirtual());
    previous_transaction_ledger_sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.Offer.previous_transaction_ledger_sequence)
  return previous_transaction_ledger_sequence_;
}
inline void Offer::set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_ledger_sequence_);
  }
  if (previous_transaction_ledger_sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_ledger_sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_ledger_sequence, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_ledger_sequence_ = previous_transaction_ledger_sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.Offer.previous_transaction_ledger_sequence)
}

// -------------------------------------------------------------------

// PayChannel

// .org.xrpl.rpc.v1.Account account = 1;
inline bool PayChannel::has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Account& PayChannel::account() const {
  const ::org::xrpl::rpc::v1::Account* p = account_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PayChannel.account)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Account*>(
      &::org::xrpl::rpc::v1::_Account_default_instance_);
}
inline ::org::xrpl::rpc::v1::Account* PayChannel::release_account() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PayChannel.account)
  
  ::org::xrpl::rpc::v1::Account* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Account* PayChannel::mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Account>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PayChannel.account)
  return account_;
}
inline void PayChannel::set_allocated_account(::org::xrpl::rpc::v1::Account* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PayChannel.account)
}

// .org.xrpl.rpc.v1.Destination destination = 2;
inline bool PayChannel::has_destination() const {
  return this != internal_default_instance() && destination_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Destination& PayChannel::destination() const {
  const ::org::xrpl::rpc::v1::Destination* p = destination_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PayChannel.destination)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Destination*>(
      &::org::xrpl::rpc::v1::_Destination_default_instance_);
}
inline ::org::xrpl::rpc::v1::Destination* PayChannel::release_destination() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PayChannel.destination)
  
  ::org::xrpl::rpc::v1::Destination* temp = destination_;
  destination_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Destination* PayChannel::mutable_destination() {
  
  if (destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Destination>(GetArenaNoVirtual());
    destination_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PayChannel.destination)
  return destination_;
}
inline void PayChannel::set_allocated_destination(::org::xrpl::rpc::v1::Destination* destination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_);
  }
  if (destination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      destination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination, submessage_arena);
    }
    
  } else {
    
  }
  destination_ = destination;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PayChannel.destination)
}

// .org.xrpl.rpc.v1.Amount amount = 3;
inline bool PayChannel::has_amount() const {
  return this != internal_default_instance() && amount_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Amount& PayChannel::amount() const {
  const ::org::xrpl::rpc::v1::Amount* p = amount_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PayChannel.amount)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Amount*>(
      &::org::xrpl::rpc::v1::_Amount_default_instance_);
}
inline ::org::xrpl::rpc::v1::Amount* PayChannel::release_amount() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PayChannel.amount)
  
  ::org::xrpl::rpc::v1::Amount* temp = amount_;
  amount_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Amount* PayChannel::mutable_amount() {
  
  if (amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Amount>(GetArenaNoVirtual());
    amount_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PayChannel.amount)
  return amount_;
}
inline void PayChannel::set_allocated_amount(::org::xrpl::rpc::v1::Amount* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount_);
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    
  } else {
    
  }
  amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PayChannel.amount)
}

// .org.xrpl.rpc.v1.Balance balance = 4;
inline bool PayChannel::has_balance() const {
  return this != internal_default_instance() && balance_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Balance& PayChannel::balance() const {
  const ::org::xrpl::rpc::v1::Balance* p = balance_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PayChannel.balance)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Balance*>(
      &::org::xrpl::rpc::v1::_Balance_default_instance_);
}
inline ::org::xrpl::rpc::v1::Balance* PayChannel::release_balance() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PayChannel.balance)
  
  ::org::xrpl::rpc::v1::Balance* temp = balance_;
  balance_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Balance* PayChannel::mutable_balance() {
  
  if (balance_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Balance>(GetArenaNoVirtual());
    balance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PayChannel.balance)
  return balance_;
}
inline void PayChannel::set_allocated_balance(::org::xrpl::rpc::v1::Balance* balance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(balance_);
  }
  if (balance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      balance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, balance, submessage_arena);
    }
    
  } else {
    
  }
  balance_ = balance;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PayChannel.balance)
}

// .org.xrpl.rpc.v1.PublicKey public_key = 5;
inline bool PayChannel::has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PublicKey& PayChannel::public_key() const {
  const ::org::xrpl::rpc::v1::PublicKey* p = public_key_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PayChannel.public_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PublicKey*>(
      &::org::xrpl::rpc::v1::_PublicKey_default_instance_);
}
inline ::org::xrpl::rpc::v1::PublicKey* PayChannel::release_public_key() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PayChannel.public_key)
  
  ::org::xrpl::rpc::v1::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PublicKey* PayChannel::mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PublicKey>(GetArenaNoVirtual());
    public_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PayChannel.public_key)
  return public_key_;
}
inline void PayChannel::set_allocated_public_key(::org::xrpl::rpc::v1::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PayChannel.public_key)
}

// .org.xrpl.rpc.v1.SettleDelay settle_delay = 6;
inline bool PayChannel::has_settle_delay() const {
  return this != internal_default_instance() && settle_delay_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::SettleDelay& PayChannel::settle_delay() const {
  const ::org::xrpl::rpc::v1::SettleDelay* p = settle_delay_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PayChannel.settle_delay)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::SettleDelay*>(
      &::org::xrpl::rpc::v1::_SettleDelay_default_instance_);
}
inline ::org::xrpl::rpc::v1::SettleDelay* PayChannel::release_settle_delay() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PayChannel.settle_delay)
  
  ::org::xrpl::rpc::v1::SettleDelay* temp = settle_delay_;
  settle_delay_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::SettleDelay* PayChannel::mutable_settle_delay() {
  
  if (settle_delay_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::SettleDelay>(GetArenaNoVirtual());
    settle_delay_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PayChannel.settle_delay)
  return settle_delay_;
}
inline void PayChannel::set_allocated_settle_delay(::org::xrpl::rpc::v1::SettleDelay* settle_delay) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(settle_delay_);
  }
  if (settle_delay) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      settle_delay = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settle_delay, submessage_arena);
    }
    
  } else {
    
  }
  settle_delay_ = settle_delay;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PayChannel.settle_delay)
}

// .org.xrpl.rpc.v1.OwnerNode owner_node = 7;
inline bool PayChannel::has_owner_node() const {
  return this != internal_default_instance() && owner_node_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::OwnerNode& PayChannel::owner_node() const {
  const ::org::xrpl::rpc::v1::OwnerNode* p = owner_node_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PayChannel.owner_node)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::OwnerNode*>(
      &::org::xrpl::rpc::v1::_OwnerNode_default_instance_);
}
inline ::org::xrpl::rpc::v1::OwnerNode* PayChannel::release_owner_node() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PayChannel.owner_node)
  
  ::org::xrpl::rpc::v1::OwnerNode* temp = owner_node_;
  owner_node_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::OwnerNode* PayChannel::mutable_owner_node() {
  
  if (owner_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::OwnerNode>(GetArenaNoVirtual());
    owner_node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PayChannel.owner_node)
  return owner_node_;
}
inline void PayChannel::set_allocated_owner_node(::org::xrpl::rpc::v1::OwnerNode* owner_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_node_);
  }
  if (owner_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      owner_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_node, submessage_arena);
    }
    
  } else {
    
  }
  owner_node_ = owner_node;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PayChannel.owner_node)
}

// .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 8;
inline bool PayChannel::has_previous_transaction_id() const {
  return this != internal_default_instance() && previous_transaction_id_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionID& PayChannel::previous_transaction_id() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionID* p = previous_transaction_id_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PayChannel.previous_transaction_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionID*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionID_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* PayChannel::release_previous_transaction_id() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PayChannel.previous_transaction_id)
  
  ::org::xrpl::rpc::v1::PreviousTransactionID* temp = previous_transaction_id_;
  previous_transaction_id_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* PayChannel::mutable_previous_transaction_id() {
  
  if (previous_transaction_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionID>(GetArenaNoVirtual());
    previous_transaction_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PayChannel.previous_transaction_id)
  return previous_transaction_id_;
}
inline void PayChannel::set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_id_);
  }
  if (previous_transaction_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_id, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_id_ = previous_transaction_id;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PayChannel.previous_transaction_id)
}

// .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 9;
inline bool PayChannel::has_previous_transaction_ledger_sequence() const {
  return this != internal_default_instance() && previous_transaction_ledger_sequence_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& PayChannel::previous_transaction_ledger_sequence() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* p = previous_transaction_ledger_sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PayChannel.previous_transaction_ledger_sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionLedgerSequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* PayChannel::release_previous_transaction_ledger_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PayChannel.previous_transaction_ledger_sequence)
  
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* temp = previous_transaction_ledger_sequence_;
  previous_transaction_ledger_sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* PayChannel::mutable_previous_transaction_ledger_sequence() {
  
  if (previous_transaction_ledger_sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence>(GetArenaNoVirtual());
    previous_transaction_ledger_sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PayChannel.previous_transaction_ledger_sequence)
  return previous_transaction_ledger_sequence_;
}
inline void PayChannel::set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_ledger_sequence_);
  }
  if (previous_transaction_ledger_sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_ledger_sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_ledger_sequence, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_ledger_sequence_ = previous_transaction_ledger_sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PayChannel.previous_transaction_ledger_sequence)
}

// .org.xrpl.rpc.v1.Flags flags = 10;
inline bool PayChannel::has_flags() const {
  return this != internal_default_instance() && flags_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Flags& PayChannel::flags() const {
  const ::org::xrpl::rpc::v1::Flags* p = flags_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PayChannel.flags)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Flags*>(
      &::org::xrpl::rpc::v1::_Flags_default_instance_);
}
inline ::org::xrpl::rpc::v1::Flags* PayChannel::release_flags() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PayChannel.flags)
  
  ::org::xrpl::rpc::v1::Flags* temp = flags_;
  flags_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Flags* PayChannel::mutable_flags() {
  
  if (flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Flags>(GetArenaNoVirtual());
    flags_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PayChannel.flags)
  return flags_;
}
inline void PayChannel::set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flags_);
  }
  if (flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flags, submessage_arena);
    }
    
  } else {
    
  }
  flags_ = flags;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PayChannel.flags)
}

// .org.xrpl.rpc.v1.Expiration expiration = 11;
inline bool PayChannel::has_expiration() const {
  return this != internal_default_instance() && expiration_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Expiration& PayChannel::expiration() const {
  const ::org::xrpl::rpc::v1::Expiration* p = expiration_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PayChannel.expiration)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Expiration*>(
      &::org::xrpl::rpc::v1::_Expiration_default_instance_);
}
inline ::org::xrpl::rpc::v1::Expiration* PayChannel::release_expiration() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PayChannel.expiration)
  
  ::org::xrpl::rpc::v1::Expiration* temp = expiration_;
  expiration_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Expiration* PayChannel::mutable_expiration() {
  
  if (expiration_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Expiration>(GetArenaNoVirtual());
    expiration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PayChannel.expiration)
  return expiration_;
}
inline void PayChannel::set_allocated_expiration(::org::xrpl::rpc::v1::Expiration* expiration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(expiration_);
  }
  if (expiration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      expiration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expiration, submessage_arena);
    }
    
  } else {
    
  }
  expiration_ = expiration;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PayChannel.expiration)
}

// .org.xrpl.rpc.v1.CancelAfter cancel_after = 12;
inline bool PayChannel::has_cancel_after() const {
  return this != internal_default_instance() && cancel_after_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::CancelAfter& PayChannel::cancel_after() const {
  const ::org::xrpl::rpc::v1::CancelAfter* p = cancel_after_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PayChannel.cancel_after)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::CancelAfter*>(
      &::org::xrpl::rpc::v1::_CancelAfter_default_instance_);
}
inline ::org::xrpl::rpc::v1::CancelAfter* PayChannel::release_cancel_after() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PayChannel.cancel_after)
  
  ::org::xrpl::rpc::v1::CancelAfter* temp = cancel_after_;
  cancel_after_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::CancelAfter* PayChannel::mutable_cancel_after() {
  
  if (cancel_after_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::CancelAfter>(GetArenaNoVirtual());
    cancel_after_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PayChannel.cancel_after)
  return cancel_after_;
}
inline void PayChannel::set_allocated_cancel_after(::org::xrpl::rpc::v1::CancelAfter* cancel_after) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cancel_after_);
  }
  if (cancel_after) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cancel_after = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cancel_after, submessage_arena);
    }
    
  } else {
    
  }
  cancel_after_ = cancel_after;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PayChannel.cancel_after)
}

// .org.xrpl.rpc.v1.SourceTag source_tag = 13;
inline bool PayChannel::has_source_tag() const {
  return this != internal_default_instance() && source_tag_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::SourceTag& PayChannel::source_tag() const {
  const ::org::xrpl::rpc::v1::SourceTag* p = source_tag_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PayChannel.source_tag)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::SourceTag*>(
      &::org::xrpl::rpc::v1::_SourceTag_default_instance_);
}
inline ::org::xrpl::rpc::v1::SourceTag* PayChannel::release_source_tag() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PayChannel.source_tag)
  
  ::org::xrpl::rpc::v1::SourceTag* temp = source_tag_;
  source_tag_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::SourceTag* PayChannel::mutable_source_tag() {
  
  if (source_tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::SourceTag>(GetArenaNoVirtual());
    source_tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PayChannel.source_tag)
  return source_tag_;
}
inline void PayChannel::set_allocated_source_tag(::org::xrpl::rpc::v1::SourceTag* source_tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_tag_);
  }
  if (source_tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source_tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_tag, submessage_arena);
    }
    
  } else {
    
  }
  source_tag_ = source_tag;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PayChannel.source_tag)
}

// .org.xrpl.rpc.v1.DestinationTag destination_tag = 14;
inline bool PayChannel::has_destination_tag() const {
  return this != internal_default_instance() && destination_tag_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::DestinationTag& PayChannel::destination_tag() const {
  const ::org::xrpl::rpc::v1::DestinationTag* p = destination_tag_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PayChannel.destination_tag)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::DestinationTag*>(
      &::org::xrpl::rpc::v1::_DestinationTag_default_instance_);
}
inline ::org::xrpl::rpc::v1::DestinationTag* PayChannel::release_destination_tag() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PayChannel.destination_tag)
  
  ::org::xrpl::rpc::v1::DestinationTag* temp = destination_tag_;
  destination_tag_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::DestinationTag* PayChannel::mutable_destination_tag() {
  
  if (destination_tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::DestinationTag>(GetArenaNoVirtual());
    destination_tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PayChannel.destination_tag)
  return destination_tag_;
}
inline void PayChannel::set_allocated_destination_tag(::org::xrpl::rpc::v1::DestinationTag* destination_tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_tag_);
  }
  if (destination_tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      destination_tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination_tag, submessage_arena);
    }
    
  } else {
    
  }
  destination_tag_ = destination_tag;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PayChannel.destination_tag)
}

// .org.xrpl.rpc.v1.DestinationNode destination_node = 15;
inline bool PayChannel::has_destination_node() const {
  return this != internal_default_instance() && destination_node_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::DestinationNode& PayChannel::destination_node() const {
  const ::org::xrpl::rpc::v1::DestinationNode* p = destination_node_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.PayChannel.destination_node)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::DestinationNode*>(
      &::org::xrpl::rpc::v1::_DestinationNode_default_instance_);
}
inline ::org::xrpl::rpc::v1::DestinationNode* PayChannel::release_destination_node() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.PayChannel.destination_node)
  
  ::org::xrpl::rpc::v1::DestinationNode* temp = destination_node_;
  destination_node_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::DestinationNode* PayChannel::mutable_destination_node() {
  
  if (destination_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::DestinationNode>(GetArenaNoVirtual());
    destination_node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.PayChannel.destination_node)
  return destination_node_;
}
inline void PayChannel::set_allocated_destination_node(::org::xrpl::rpc::v1::DestinationNode* destination_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_node_);
  }
  if (destination_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      destination_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination_node, submessage_arena);
    }
    
  } else {
    
  }
  destination_node_ = destination_node;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.PayChannel.destination_node)
}

// -------------------------------------------------------------------

// RippleState

// .org.xrpl.rpc.v1.Balance balance = 1;
inline bool RippleState::has_balance() const {
  return this != internal_default_instance() && balance_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Balance& RippleState::balance() const {
  const ::org::xrpl::rpc::v1::Balance* p = balance_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.RippleState.balance)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Balance*>(
      &::org::xrpl::rpc::v1::_Balance_default_instance_);
}
inline ::org::xrpl::rpc::v1::Balance* RippleState::release_balance() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.RippleState.balance)
  
  ::org::xrpl::rpc::v1::Balance* temp = balance_;
  balance_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Balance* RippleState::mutable_balance() {
  
  if (balance_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Balance>(GetArenaNoVirtual());
    balance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.RippleState.balance)
  return balance_;
}
inline void RippleState::set_allocated_balance(::org::xrpl::rpc::v1::Balance* balance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(balance_);
  }
  if (balance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      balance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, balance, submessage_arena);
    }
    
  } else {
    
  }
  balance_ = balance;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.RippleState.balance)
}

// .org.xrpl.rpc.v1.Flags flags = 2;
inline bool RippleState::has_flags() const {
  return this != internal_default_instance() && flags_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Flags& RippleState::flags() const {
  const ::org::xrpl::rpc::v1::Flags* p = flags_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.RippleState.flags)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Flags*>(
      &::org::xrpl::rpc::v1::_Flags_default_instance_);
}
inline ::org::xrpl::rpc::v1::Flags* RippleState::release_flags() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.RippleState.flags)
  
  ::org::xrpl::rpc::v1::Flags* temp = flags_;
  flags_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Flags* RippleState::mutable_flags() {
  
  if (flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Flags>(GetArenaNoVirtual());
    flags_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.RippleState.flags)
  return flags_;
}
inline void RippleState::set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flags_);
  }
  if (flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flags, submessage_arena);
    }
    
  } else {
    
  }
  flags_ = flags;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.RippleState.flags)
}

// .org.xrpl.rpc.v1.LowLimit low_limit = 3;
inline bool RippleState::has_low_limit() const {
  return this != internal_default_instance() && low_limit_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::LowLimit& RippleState::low_limit() const {
  const ::org::xrpl::rpc::v1::LowLimit* p = low_limit_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.RippleState.low_limit)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::LowLimit*>(
      &::org::xrpl::rpc::v1::_LowLimit_default_instance_);
}
inline ::org::xrpl::rpc::v1::LowLimit* RippleState::release_low_limit() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.RippleState.low_limit)
  
  ::org::xrpl::rpc::v1::LowLimit* temp = low_limit_;
  low_limit_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::LowLimit* RippleState::mutable_low_limit() {
  
  if (low_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::LowLimit>(GetArenaNoVirtual());
    low_limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.RippleState.low_limit)
  return low_limit_;
}
inline void RippleState::set_allocated_low_limit(::org::xrpl::rpc::v1::LowLimit* low_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(low_limit_);
  }
  if (low_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      low_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, low_limit, submessage_arena);
    }
    
  } else {
    
  }
  low_limit_ = low_limit;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.RippleState.low_limit)
}

// .org.xrpl.rpc.v1.HighLimit high_limit = 4;
inline bool RippleState::has_high_limit() const {
  return this != internal_default_instance() && high_limit_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::HighLimit& RippleState::high_limit() const {
  const ::org::xrpl::rpc::v1::HighLimit* p = high_limit_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.RippleState.high_limit)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::HighLimit*>(
      &::org::xrpl::rpc::v1::_HighLimit_default_instance_);
}
inline ::org::xrpl::rpc::v1::HighLimit* RippleState::release_high_limit() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.RippleState.high_limit)
  
  ::org::xrpl::rpc::v1::HighLimit* temp = high_limit_;
  high_limit_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::HighLimit* RippleState::mutable_high_limit() {
  
  if (high_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::HighLimit>(GetArenaNoVirtual());
    high_limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.RippleState.high_limit)
  return high_limit_;
}
inline void RippleState::set_allocated_high_limit(::org::xrpl::rpc::v1::HighLimit* high_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(high_limit_);
  }
  if (high_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      high_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, high_limit, submessage_arena);
    }
    
  } else {
    
  }
  high_limit_ = high_limit;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.RippleState.high_limit)
}

// .org.xrpl.rpc.v1.LowNode low_node = 5;
inline bool RippleState::has_low_node() const {
  return this != internal_default_instance() && low_node_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::LowNode& RippleState::low_node() const {
  const ::org::xrpl::rpc::v1::LowNode* p = low_node_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.RippleState.low_node)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::LowNode*>(
      &::org::xrpl::rpc::v1::_LowNode_default_instance_);
}
inline ::org::xrpl::rpc::v1::LowNode* RippleState::release_low_node() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.RippleState.low_node)
  
  ::org::xrpl::rpc::v1::LowNode* temp = low_node_;
  low_node_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::LowNode* RippleState::mutable_low_node() {
  
  if (low_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::LowNode>(GetArenaNoVirtual());
    low_node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.RippleState.low_node)
  return low_node_;
}
inline void RippleState::set_allocated_low_node(::org::xrpl::rpc::v1::LowNode* low_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(low_node_);
  }
  if (low_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      low_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, low_node, submessage_arena);
    }
    
  } else {
    
  }
  low_node_ = low_node;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.RippleState.low_node)
}

// .org.xrpl.rpc.v1.HighNode high_node = 6;
inline bool RippleState::has_high_node() const {
  return this != internal_default_instance() && high_node_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::HighNode& RippleState::high_node() const {
  const ::org::xrpl::rpc::v1::HighNode* p = high_node_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.RippleState.high_node)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::HighNode*>(
      &::org::xrpl::rpc::v1::_HighNode_default_instance_);
}
inline ::org::xrpl::rpc::v1::HighNode* RippleState::release_high_node() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.RippleState.high_node)
  
  ::org::xrpl::rpc::v1::HighNode* temp = high_node_;
  high_node_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::HighNode* RippleState::mutable_high_node() {
  
  if (high_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::HighNode>(GetArenaNoVirtual());
    high_node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.RippleState.high_node)
  return high_node_;
}
inline void RippleState::set_allocated_high_node(::org::xrpl::rpc::v1::HighNode* high_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(high_node_);
  }
  if (high_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      high_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, high_node, submessage_arena);
    }
    
  } else {
    
  }
  high_node_ = high_node;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.RippleState.high_node)
}

// .org.xrpl.rpc.v1.LowQualityIn low_quality_in = 7;
inline bool RippleState::has_low_quality_in() const {
  return this != internal_default_instance() && low_quality_in_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::LowQualityIn& RippleState::low_quality_in() const {
  const ::org::xrpl::rpc::v1::LowQualityIn* p = low_quality_in_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.RippleState.low_quality_in)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::LowQualityIn*>(
      &::org::xrpl::rpc::v1::_LowQualityIn_default_instance_);
}
inline ::org::xrpl::rpc::v1::LowQualityIn* RippleState::release_low_quality_in() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.RippleState.low_quality_in)
  
  ::org::xrpl::rpc::v1::LowQualityIn* temp = low_quality_in_;
  low_quality_in_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::LowQualityIn* RippleState::mutable_low_quality_in() {
  
  if (low_quality_in_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::LowQualityIn>(GetArenaNoVirtual());
    low_quality_in_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.RippleState.low_quality_in)
  return low_quality_in_;
}
inline void RippleState::set_allocated_low_quality_in(::org::xrpl::rpc::v1::LowQualityIn* low_quality_in) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(low_quality_in_);
  }
  if (low_quality_in) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      low_quality_in = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, low_quality_in, submessage_arena);
    }
    
  } else {
    
  }
  low_quality_in_ = low_quality_in;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.RippleState.low_quality_in)
}

// .org.xrpl.rpc.v1.LowQualityOut low_quality_out = 8;
inline bool RippleState::has_low_quality_out() const {
  return this != internal_default_instance() && low_quality_out_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::LowQualityOut& RippleState::low_quality_out() const {
  const ::org::xrpl::rpc::v1::LowQualityOut* p = low_quality_out_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.RippleState.low_quality_out)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::LowQualityOut*>(
      &::org::xrpl::rpc::v1::_LowQualityOut_default_instance_);
}
inline ::org::xrpl::rpc::v1::LowQualityOut* RippleState::release_low_quality_out() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.RippleState.low_quality_out)
  
  ::org::xrpl::rpc::v1::LowQualityOut* temp = low_quality_out_;
  low_quality_out_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::LowQualityOut* RippleState::mutable_low_quality_out() {
  
  if (low_quality_out_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::LowQualityOut>(GetArenaNoVirtual());
    low_quality_out_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.RippleState.low_quality_out)
  return low_quality_out_;
}
inline void RippleState::set_allocated_low_quality_out(::org::xrpl::rpc::v1::LowQualityOut* low_quality_out) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(low_quality_out_);
  }
  if (low_quality_out) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      low_quality_out = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, low_quality_out, submessage_arena);
    }
    
  } else {
    
  }
  low_quality_out_ = low_quality_out;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.RippleState.low_quality_out)
}

// .org.xrpl.rpc.v1.HighQualityIn high_quality_in = 9;
inline bool RippleState::has_high_quality_in() const {
  return this != internal_default_instance() && high_quality_in_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::HighQualityIn& RippleState::high_quality_in() const {
  const ::org::xrpl::rpc::v1::HighQualityIn* p = high_quality_in_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.RippleState.high_quality_in)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::HighQualityIn*>(
      &::org::xrpl::rpc::v1::_HighQualityIn_default_instance_);
}
inline ::org::xrpl::rpc::v1::HighQualityIn* RippleState::release_high_quality_in() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.RippleState.high_quality_in)
  
  ::org::xrpl::rpc::v1::HighQualityIn* temp = high_quality_in_;
  high_quality_in_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::HighQualityIn* RippleState::mutable_high_quality_in() {
  
  if (high_quality_in_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::HighQualityIn>(GetArenaNoVirtual());
    high_quality_in_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.RippleState.high_quality_in)
  return high_quality_in_;
}
inline void RippleState::set_allocated_high_quality_in(::org::xrpl::rpc::v1::HighQualityIn* high_quality_in) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(high_quality_in_);
  }
  if (high_quality_in) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      high_quality_in = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, high_quality_in, submessage_arena);
    }
    
  } else {
    
  }
  high_quality_in_ = high_quality_in;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.RippleState.high_quality_in)
}

// .org.xrpl.rpc.v1.HighQualityOut high_quality_out = 10;
inline bool RippleState::has_high_quality_out() const {
  return this != internal_default_instance() && high_quality_out_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::HighQualityOut& RippleState::high_quality_out() const {
  const ::org::xrpl::rpc::v1::HighQualityOut* p = high_quality_out_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.RippleState.high_quality_out)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::HighQualityOut*>(
      &::org::xrpl::rpc::v1::_HighQualityOut_default_instance_);
}
inline ::org::xrpl::rpc::v1::HighQualityOut* RippleState::release_high_quality_out() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.RippleState.high_quality_out)
  
  ::org::xrpl::rpc::v1::HighQualityOut* temp = high_quality_out_;
  high_quality_out_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::HighQualityOut* RippleState::mutable_high_quality_out() {
  
  if (high_quality_out_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::HighQualityOut>(GetArenaNoVirtual());
    high_quality_out_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.RippleState.high_quality_out)
  return high_quality_out_;
}
inline void RippleState::set_allocated_high_quality_out(::org::xrpl::rpc::v1::HighQualityOut* high_quality_out) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(high_quality_out_);
  }
  if (high_quality_out) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      high_quality_out = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, high_quality_out, submessage_arena);
    }
    
  } else {
    
  }
  high_quality_out_ = high_quality_out;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.RippleState.high_quality_out)
}

// .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 11;
inline bool RippleState::has_previous_transaction_id() const {
  return this != internal_default_instance() && previous_transaction_id_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionID& RippleState::previous_transaction_id() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionID* p = previous_transaction_id_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.RippleState.previous_transaction_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionID*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionID_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* RippleState::release_previous_transaction_id() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.RippleState.previous_transaction_id)
  
  ::org::xrpl::rpc::v1::PreviousTransactionID* temp = previous_transaction_id_;
  previous_transaction_id_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* RippleState::mutable_previous_transaction_id() {
  
  if (previous_transaction_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionID>(GetArenaNoVirtual());
    previous_transaction_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.RippleState.previous_transaction_id)
  return previous_transaction_id_;
}
inline void RippleState::set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_id_);
  }
  if (previous_transaction_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_id, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_id_ = previous_transaction_id;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.RippleState.previous_transaction_id)
}

// .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 12;
inline bool RippleState::has_previous_transaction_ledger_sequence() const {
  return this != internal_default_instance() && previous_transaction_ledger_sequence_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& RippleState::previous_transaction_ledger_sequence() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* p = previous_transaction_ledger_sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.RippleState.previous_transaction_ledger_sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionLedgerSequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* RippleState::release_previous_transaction_ledger_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.RippleState.previous_transaction_ledger_sequence)
  
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* temp = previous_transaction_ledger_sequence_;
  previous_transaction_ledger_sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* RippleState::mutable_previous_transaction_ledger_sequence() {
  
  if (previous_transaction_ledger_sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence>(GetArenaNoVirtual());
    previous_transaction_ledger_sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.RippleState.previous_transaction_ledger_sequence)
  return previous_transaction_ledger_sequence_;
}
inline void RippleState::set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_ledger_sequence_);
  }
  if (previous_transaction_ledger_sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_ledger_sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_ledger_sequence, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_ledger_sequence_ = previous_transaction_ledger_sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.RippleState.previous_transaction_ledger_sequence)
}

// -------------------------------------------------------------------

// SignerList

// .org.xrpl.rpc.v1.Flags flags = 1;
inline bool SignerList::has_flags() const {
  return this != internal_default_instance() && flags_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Flags& SignerList::flags() const {
  const ::org::xrpl::rpc::v1::Flags* p = flags_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SignerList.flags)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Flags*>(
      &::org::xrpl::rpc::v1::_Flags_default_instance_);
}
inline ::org::xrpl::rpc::v1::Flags* SignerList::release_flags() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.SignerList.flags)
  
  ::org::xrpl::rpc::v1::Flags* temp = flags_;
  flags_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Flags* SignerList::mutable_flags() {
  
  if (flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Flags>(GetArenaNoVirtual());
    flags_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.SignerList.flags)
  return flags_;
}
inline void SignerList::set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flags_);
  }
  if (flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flags, submessage_arena);
    }
    
  } else {
    
  }
  flags_ = flags;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.SignerList.flags)
}

// .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 2;
inline bool SignerList::has_previous_transaction_id() const {
  return this != internal_default_instance() && previous_transaction_id_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionID& SignerList::previous_transaction_id() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionID* p = previous_transaction_id_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SignerList.previous_transaction_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionID*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionID_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* SignerList::release_previous_transaction_id() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.SignerList.previous_transaction_id)
  
  ::org::xrpl::rpc::v1::PreviousTransactionID* temp = previous_transaction_id_;
  previous_transaction_id_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* SignerList::mutable_previous_transaction_id() {
  
  if (previous_transaction_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionID>(GetArenaNoVirtual());
    previous_transaction_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.SignerList.previous_transaction_id)
  return previous_transaction_id_;
}
inline void SignerList::set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_id_);
  }
  if (previous_transaction_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_id, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_id_ = previous_transaction_id;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.SignerList.previous_transaction_id)
}

// .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 3;
inline bool SignerList::has_previous_transaction_ledger_sequence() const {
  return this != internal_default_instance() && previous_transaction_ledger_sequence_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& SignerList::previous_transaction_ledger_sequence() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* p = previous_transaction_ledger_sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SignerList.previous_transaction_ledger_sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionLedgerSequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* SignerList::release_previous_transaction_ledger_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.SignerList.previous_transaction_ledger_sequence)
  
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* temp = previous_transaction_ledger_sequence_;
  previous_transaction_ledger_sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* SignerList::mutable_previous_transaction_ledger_sequence() {
  
  if (previous_transaction_ledger_sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence>(GetArenaNoVirtual());
    previous_transaction_ledger_sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.SignerList.previous_transaction_ledger_sequence)
  return previous_transaction_ledger_sequence_;
}
inline void SignerList::set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_ledger_sequence_);
  }
  if (previous_transaction_ledger_sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_ledger_sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_ledger_sequence, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_ledger_sequence_ = previous_transaction_ledger_sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.SignerList.previous_transaction_ledger_sequence)
}

// .org.xrpl.rpc.v1.OwnerNode owner_node = 4;
inline bool SignerList::has_owner_node() const {
  return this != internal_default_instance() && owner_node_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::OwnerNode& SignerList::owner_node() const {
  const ::org::xrpl::rpc::v1::OwnerNode* p = owner_node_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SignerList.owner_node)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::OwnerNode*>(
      &::org::xrpl::rpc::v1::_OwnerNode_default_instance_);
}
inline ::org::xrpl::rpc::v1::OwnerNode* SignerList::release_owner_node() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.SignerList.owner_node)
  
  ::org::xrpl::rpc::v1::OwnerNode* temp = owner_node_;
  owner_node_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::OwnerNode* SignerList::mutable_owner_node() {
  
  if (owner_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::OwnerNode>(GetArenaNoVirtual());
    owner_node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.SignerList.owner_node)
  return owner_node_;
}
inline void SignerList::set_allocated_owner_node(::org::xrpl::rpc::v1::OwnerNode* owner_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_node_);
  }
  if (owner_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      owner_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_node, submessage_arena);
    }
    
  } else {
    
  }
  owner_node_ = owner_node;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.SignerList.owner_node)
}

// repeated .org.xrpl.rpc.v1.SignerEntry signer_entries = 5;
inline int SignerList::signer_entries_size() const {
  return signer_entries_.size();
}
inline ::org::xrpl::rpc::v1::SignerEntry* SignerList::mutable_signer_entries(int index) {
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.SignerList.signer_entries)
  return signer_entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::SignerEntry >*
SignerList::mutable_signer_entries() {
  // @@protoc_insertion_point(field_mutable_list:org.xrpl.rpc.v1.SignerList.signer_entries)
  return &signer_entries_;
}
inline const ::org::xrpl::rpc::v1::SignerEntry& SignerList::signer_entries(int index) const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SignerList.signer_entries)
  return signer_entries_.Get(index);
}
inline ::org::xrpl::rpc::v1::SignerEntry* SignerList::add_signer_entries() {
  // @@protoc_insertion_point(field_add:org.xrpl.rpc.v1.SignerList.signer_entries)
  return signer_entries_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::SignerEntry >&
SignerList::signer_entries() const {
  // @@protoc_insertion_point(field_list:org.xrpl.rpc.v1.SignerList.signer_entries)
  return signer_entries_;
}

// .org.xrpl.rpc.v1.SignerListID signer_list_id = 6;
inline bool SignerList::has_signer_list_id() const {
  return this != internal_default_instance() && signer_list_id_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::SignerListID& SignerList::signer_list_id() const {
  const ::org::xrpl::rpc::v1::SignerListID* p = signer_list_id_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SignerList.signer_list_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::SignerListID*>(
      &::org::xrpl::rpc::v1::_SignerListID_default_instance_);
}
inline ::org::xrpl::rpc::v1::SignerListID* SignerList::release_signer_list_id() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.SignerList.signer_list_id)
  
  ::org::xrpl::rpc::v1::SignerListID* temp = signer_list_id_;
  signer_list_id_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::SignerListID* SignerList::mutable_signer_list_id() {
  
  if (signer_list_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::SignerListID>(GetArenaNoVirtual());
    signer_list_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.SignerList.signer_list_id)
  return signer_list_id_;
}
inline void SignerList::set_allocated_signer_list_id(::org::xrpl::rpc::v1::SignerListID* signer_list_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(signer_list_id_);
  }
  if (signer_list_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      signer_list_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signer_list_id, submessage_arena);
    }
    
  } else {
    
  }
  signer_list_id_ = signer_list_id;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.SignerList.signer_list_id)
}

// .org.xrpl.rpc.v1.SignerQuorum signer_quorum = 7;
inline bool SignerList::has_signer_quorum() const {
  return this != internal_default_instance() && signer_quorum_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::SignerQuorum& SignerList::signer_quorum() const {
  const ::org::xrpl::rpc::v1::SignerQuorum* p = signer_quorum_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.SignerList.signer_quorum)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::SignerQuorum*>(
      &::org::xrpl::rpc::v1::_SignerQuorum_default_instance_);
}
inline ::org::xrpl::rpc::v1::SignerQuorum* SignerList::release_signer_quorum() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.SignerList.signer_quorum)
  
  ::org::xrpl::rpc::v1::SignerQuorum* temp = signer_quorum_;
  signer_quorum_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::SignerQuorum* SignerList::mutable_signer_quorum() {
  
  if (signer_quorum_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::SignerQuorum>(GetArenaNoVirtual());
    signer_quorum_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.SignerList.signer_quorum)
  return signer_quorum_;
}
inline void SignerList::set_allocated_signer_quorum(::org::xrpl::rpc::v1::SignerQuorum* signer_quorum) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(signer_quorum_);
  }
  if (signer_quorum) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      signer_quorum = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signer_quorum, submessage_arena);
    }
    
  } else {
    
  }
  signer_quorum_ = signer_quorum;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.SignerList.signer_quorum)
}

// -------------------------------------------------------------------

// TicketObject

// .org.xrpl.rpc.v1.Flags flags = 1;
inline bool TicketObject::has_flags() const {
  return this != internal_default_instance() && flags_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Flags& TicketObject::flags() const {
  const ::org::xrpl::rpc::v1::Flags* p = flags_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TicketObject.flags)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Flags*>(
      &::org::xrpl::rpc::v1::_Flags_default_instance_);
}
inline ::org::xrpl::rpc::v1::Flags* TicketObject::release_flags() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.TicketObject.flags)
  
  ::org::xrpl::rpc::v1::Flags* temp = flags_;
  flags_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Flags* TicketObject::mutable_flags() {
  
  if (flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Flags>(GetArenaNoVirtual());
    flags_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.TicketObject.flags)
  return flags_;
}
inline void TicketObject::set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flags_);
  }
  if (flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flags, submessage_arena);
    }
    
  } else {
    
  }
  flags_ = flags;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.TicketObject.flags)
}

// .org.xrpl.rpc.v1.Account account = 2;
inline bool TicketObject::has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Account& TicketObject::account() const {
  const ::org::xrpl::rpc::v1::Account* p = account_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TicketObject.account)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Account*>(
      &::org::xrpl::rpc::v1::_Account_default_instance_);
}
inline ::org::xrpl::rpc::v1::Account* TicketObject::release_account() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.TicketObject.account)
  
  ::org::xrpl::rpc::v1::Account* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Account* TicketObject::mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Account>(GetArenaNoVirtual());
    account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.TicketObject.account)
  return account_;
}
inline void TicketObject::set_allocated_account(::org::xrpl::rpc::v1::Account* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.TicketObject.account)
}

// .org.xrpl.rpc.v1.OwnerNode owner_node = 3;
inline bool TicketObject::has_owner_node() const {
  return this != internal_default_instance() && owner_node_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::OwnerNode& TicketObject::owner_node() const {
  const ::org::xrpl::rpc::v1::OwnerNode* p = owner_node_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TicketObject.owner_node)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::OwnerNode*>(
      &::org::xrpl::rpc::v1::_OwnerNode_default_instance_);
}
inline ::org::xrpl::rpc::v1::OwnerNode* TicketObject::release_owner_node() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.TicketObject.owner_node)
  
  ::org::xrpl::rpc::v1::OwnerNode* temp = owner_node_;
  owner_node_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::OwnerNode* TicketObject::mutable_owner_node() {
  
  if (owner_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::OwnerNode>(GetArenaNoVirtual());
    owner_node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.TicketObject.owner_node)
  return owner_node_;
}
inline void TicketObject::set_allocated_owner_node(::org::xrpl::rpc::v1::OwnerNode* owner_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_node_);
  }
  if (owner_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      owner_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_node, submessage_arena);
    }
    
  } else {
    
  }
  owner_node_ = owner_node;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.TicketObject.owner_node)
}

// .org.xrpl.rpc.v1.PreviousTransactionID previous_transaction_id = 4;
inline bool TicketObject::has_previous_transaction_id() const {
  return this != internal_default_instance() && previous_transaction_id_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionID& TicketObject::previous_transaction_id() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionID* p = previous_transaction_id_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TicketObject.previous_transaction_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionID*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionID_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* TicketObject::release_previous_transaction_id() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.TicketObject.previous_transaction_id)
  
  ::org::xrpl::rpc::v1::PreviousTransactionID* temp = previous_transaction_id_;
  previous_transaction_id_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionID* TicketObject::mutable_previous_transaction_id() {
  
  if (previous_transaction_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionID>(GetArenaNoVirtual());
    previous_transaction_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.TicketObject.previous_transaction_id)
  return previous_transaction_id_;
}
inline void TicketObject::set_allocated_previous_transaction_id(::org::xrpl::rpc::v1::PreviousTransactionID* previous_transaction_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_id_);
  }
  if (previous_transaction_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_id, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_id_ = previous_transaction_id;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.TicketObject.previous_transaction_id)
}

// .org.xrpl.rpc.v1.PreviousTransactionLedgerSequence previous_transaction_ledger_sequence = 5;
inline bool TicketObject::has_previous_transaction_ledger_sequence() const {
  return this != internal_default_instance() && previous_transaction_ledger_sequence_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence& TicketObject::previous_transaction_ledger_sequence() const {
  const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* p = previous_transaction_ledger_sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TicketObject.previous_transaction_ledger_sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence*>(
      &::org::xrpl::rpc::v1::_PreviousTransactionLedgerSequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* TicketObject::release_previous_transaction_ledger_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.TicketObject.previous_transaction_ledger_sequence)
  
  ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* temp = previous_transaction_ledger_sequence_;
  previous_transaction_ledger_sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* TicketObject::mutable_previous_transaction_ledger_sequence() {
  
  if (previous_transaction_ledger_sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence>(GetArenaNoVirtual());
    previous_transaction_ledger_sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.TicketObject.previous_transaction_ledger_sequence)
  return previous_transaction_ledger_sequence_;
}
inline void TicketObject::set_allocated_previous_transaction_ledger_sequence(::org::xrpl::rpc::v1::PreviousTransactionLedgerSequence* previous_transaction_ledger_sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_transaction_ledger_sequence_);
  }
  if (previous_transaction_ledger_sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      previous_transaction_ledger_sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_transaction_ledger_sequence, submessage_arena);
    }
    
  } else {
    
  }
  previous_transaction_ledger_sequence_ = previous_transaction_ledger_sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.TicketObject.previous_transaction_ledger_sequence)
}

// .org.xrpl.rpc.v1.TicketSequence ticket_sequence = 6;
inline bool TicketObject::has_ticket_sequence() const {
  return this != internal_default_instance() && ticket_sequence_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::TicketSequence& TicketObject::ticket_sequence() const {
  const ::org::xrpl::rpc::v1::TicketSequence* p = ticket_sequence_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.TicketObject.ticket_sequence)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::TicketSequence*>(
      &::org::xrpl::rpc::v1::_TicketSequence_default_instance_);
}
inline ::org::xrpl::rpc::v1::TicketSequence* TicketObject::release_ticket_sequence() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.TicketObject.ticket_sequence)
  
  ::org::xrpl::rpc::v1::TicketSequence* temp = ticket_sequence_;
  ticket_sequence_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::TicketSequence* TicketObject::mutable_ticket_sequence() {
  
  if (ticket_sequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::TicketSequence>(GetArenaNoVirtual());
    ticket_sequence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.TicketObject.ticket_sequence)
  return ticket_sequence_;
}
inline void TicketObject::set_allocated_ticket_sequence(::org::xrpl::rpc::v1::TicketSequence* ticket_sequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ticket_sequence_);
  }
  if (ticket_sequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ticket_sequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ticket_sequence, submessage_arena);
    }
    
  } else {
    
  }
  ticket_sequence_ = ticket_sequence;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.TicketObject.ticket_sequence)
}

// -------------------------------------------------------------------

// NegativeUNL

// repeated .org.xrpl.rpc.v1.DisabledValidator disabled_validators = 1;
inline int NegativeUNL::disabled_validators_size() const {
  return disabled_validators_.size();
}
inline ::org::xrpl::rpc::v1::DisabledValidator* NegativeUNL::mutable_disabled_validators(int index) {
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.NegativeUNL.disabled_validators)
  return disabled_validators_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::DisabledValidator >*
NegativeUNL::mutable_disabled_validators() {
  // @@protoc_insertion_point(field_mutable_list:org.xrpl.rpc.v1.NegativeUNL.disabled_validators)
  return &disabled_validators_;
}
inline const ::org::xrpl::rpc::v1::DisabledValidator& NegativeUNL::disabled_validators(int index) const {
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.NegativeUNL.disabled_validators)
  return disabled_validators_.Get(index);
}
inline ::org::xrpl::rpc::v1::DisabledValidator* NegativeUNL::add_disabled_validators() {
  // @@protoc_insertion_point(field_add:org.xrpl.rpc.v1.NegativeUNL.disabled_validators)
  return disabled_validators_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::org::xrpl::rpc::v1::DisabledValidator >&
NegativeUNL::disabled_validators() const {
  // @@protoc_insertion_point(field_list:org.xrpl.rpc.v1.NegativeUNL.disabled_validators)
  return disabled_validators_;
}

// .org.xrpl.rpc.v1.ValidatorToDisable validator_to_disable = 2;
inline bool NegativeUNL::has_validator_to_disable() const {
  return this != internal_default_instance() && validator_to_disable_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::ValidatorToDisable& NegativeUNL::validator_to_disable() const {
  const ::org::xrpl::rpc::v1::ValidatorToDisable* p = validator_to_disable_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.NegativeUNL.validator_to_disable)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::ValidatorToDisable*>(
      &::org::xrpl::rpc::v1::_ValidatorToDisable_default_instance_);
}
inline ::org::xrpl::rpc::v1::ValidatorToDisable* NegativeUNL::release_validator_to_disable() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.NegativeUNL.validator_to_disable)
  
  ::org::xrpl::rpc::v1::ValidatorToDisable* temp = validator_to_disable_;
  validator_to_disable_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::ValidatorToDisable* NegativeUNL::mutable_validator_to_disable() {
  
  if (validator_to_disable_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::ValidatorToDisable>(GetArenaNoVirtual());
    validator_to_disable_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.NegativeUNL.validator_to_disable)
  return validator_to_disable_;
}
inline void NegativeUNL::set_allocated_validator_to_disable(::org::xrpl::rpc::v1::ValidatorToDisable* validator_to_disable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(validator_to_disable_);
  }
  if (validator_to_disable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      validator_to_disable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, validator_to_disable, submessage_arena);
    }
    
  } else {
    
  }
  validator_to_disable_ = validator_to_disable;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.NegativeUNL.validator_to_disable)
}

// .org.xrpl.rpc.v1.ValidatorToReEnable validator_to_re_enable = 3;
inline bool NegativeUNL::has_validator_to_re_enable() const {
  return this != internal_default_instance() && validator_to_re_enable_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::ValidatorToReEnable& NegativeUNL::validator_to_re_enable() const {
  const ::org::xrpl::rpc::v1::ValidatorToReEnable* p = validator_to_re_enable_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.NegativeUNL.validator_to_re_enable)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::ValidatorToReEnable*>(
      &::org::xrpl::rpc::v1::_ValidatorToReEnable_default_instance_);
}
inline ::org::xrpl::rpc::v1::ValidatorToReEnable* NegativeUNL::release_validator_to_re_enable() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.NegativeUNL.validator_to_re_enable)
  
  ::org::xrpl::rpc::v1::ValidatorToReEnable* temp = validator_to_re_enable_;
  validator_to_re_enable_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::ValidatorToReEnable* NegativeUNL::mutable_validator_to_re_enable() {
  
  if (validator_to_re_enable_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::ValidatorToReEnable>(GetArenaNoVirtual());
    validator_to_re_enable_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.NegativeUNL.validator_to_re_enable)
  return validator_to_re_enable_;
}
inline void NegativeUNL::set_allocated_validator_to_re_enable(::org::xrpl::rpc::v1::ValidatorToReEnable* validator_to_re_enable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(validator_to_re_enable_);
  }
  if (validator_to_re_enable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      validator_to_re_enable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, validator_to_re_enable, submessage_arena);
    }
    
  } else {
    
  }
  validator_to_re_enable_ = validator_to_re_enable;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.NegativeUNL.validator_to_re_enable)
}

// .org.xrpl.rpc.v1.Flags flags = 4;
inline bool NegativeUNL::has_flags() const {
  return this != internal_default_instance() && flags_ != nullptr;
}
inline const ::org::xrpl::rpc::v1::Flags& NegativeUNL::flags() const {
  const ::org::xrpl::rpc::v1::Flags* p = flags_;
  // @@protoc_insertion_point(field_get:org.xrpl.rpc.v1.NegativeUNL.flags)
  return p != nullptr ? *p : *reinterpret_cast<const ::org::xrpl::rpc::v1::Flags*>(
      &::org::xrpl::rpc::v1::_Flags_default_instance_);
}
inline ::org::xrpl::rpc::v1::Flags* NegativeUNL::release_flags() {
  // @@protoc_insertion_point(field_release:org.xrpl.rpc.v1.NegativeUNL.flags)
  
  ::org::xrpl::rpc::v1::Flags* temp = flags_;
  flags_ = nullptr;
  return temp;
}
inline ::org::xrpl::rpc::v1::Flags* NegativeUNL::mutable_flags() {
  
  if (flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::org::xrpl::rpc::v1::Flags>(GetArenaNoVirtual());
    flags_ = p;
  }
  // @@protoc_insertion_point(field_mutable:org.xrpl.rpc.v1.NegativeUNL.flags)
  return flags_;
}
inline void NegativeUNL::set_allocated_flags(::org::xrpl::rpc::v1::Flags* flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(flags_);
  }
  if (flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flags, submessage_arena);
    }
    
  } else {
    
  }
  flags_ = flags;
  // @@protoc_insertion_point(field_set_allocated:org.xrpl.rpc.v1.NegativeUNL.flags)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace rpc
}  // namespace xrpl
}  // namespace org

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::org::xrpl::rpc::v1::LedgerEntryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::org::xrpl::rpc::v1::LedgerEntryType>() {
  return ::org::xrpl::rpc::v1::LedgerEntryType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_org_2fxrpl_2frpc_2fv1_2fledger_5fobjects_2eproto
