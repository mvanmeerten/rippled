// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ripple.proto

#include "ripple.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMClusterNode_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMIndexedObject_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLedgerNode_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLink_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLoadSource_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMManifest_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ValidatorBlobInfo_ripple_2eproto;
namespace protocol {
class TMManifestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMManifest> _instance;
} _TMManifest_default_instance_;
class TMManifestsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMManifests> _instance;
} _TMManifests_default_instance_;
class TMClusterNodeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMClusterNode> _instance;
} _TMClusterNode_default_instance_;
class TMLoadSourceDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMLoadSource> _instance;
} _TMLoadSource_default_instance_;
class TMClusterDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMCluster> _instance;
} _TMCluster_default_instance_;
class TMGetShardInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMGetShardInfo> _instance;
} _TMGetShardInfo_default_instance_;
class TMShardInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMShardInfo> _instance;
} _TMShardInfo_default_instance_;
class TMLinkDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMLink> _instance;
} _TMLink_default_instance_;
class TMGetPeerShardInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMGetPeerShardInfo> _instance;
} _TMGetPeerShardInfo_default_instance_;
class TMPeerShardInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMPeerShardInfo> _instance;
} _TMPeerShardInfo_default_instance_;
class TMTransactionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMTransaction> _instance;
} _TMTransaction_default_instance_;
class TMStatusChangeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMStatusChange> _instance;
} _TMStatusChange_default_instance_;
class TMProposeSetDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMProposeSet> _instance;
} _TMProposeSet_default_instance_;
class TMHaveTransactionSetDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMHaveTransactionSet> _instance;
} _TMHaveTransactionSet_default_instance_;
class TMValidatorListDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMValidatorList> _instance;
} _TMValidatorList_default_instance_;
class ValidatorBlobInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ValidatorBlobInfo> _instance;
} _ValidatorBlobInfo_default_instance_;
class TMValidatorListCollectionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMValidatorListCollection> _instance;
} _TMValidatorListCollection_default_instance_;
class TMValidationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMValidation> _instance;
} _TMValidation_default_instance_;
class TMEndpoints_TMEndpointv2DefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMEndpoints_TMEndpointv2> _instance;
} _TMEndpoints_TMEndpointv2_default_instance_;
class TMEndpointsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMEndpoints> _instance;
} _TMEndpoints_default_instance_;
class TMIndexedObjectDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMIndexedObject> _instance;
} _TMIndexedObject_default_instance_;
class TMGetObjectByHashDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMGetObjectByHash> _instance;
} _TMGetObjectByHash_default_instance_;
class TMLedgerNodeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMLedgerNode> _instance;
} _TMLedgerNode_default_instance_;
class TMGetLedgerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMGetLedger> _instance;
} _TMGetLedger_default_instance_;
class TMLedgerDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMLedgerData> _instance;
} _TMLedgerData_default_instance_;
class TMPingDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMPing> _instance;
} _TMPing_default_instance_;
class TMSquelchDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMSquelch> _instance;
} _TMSquelch_default_instance_;
class TMProofPathRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMProofPathRequest> _instance;
} _TMProofPathRequest_default_instance_;
class TMProofPathResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMProofPathResponse> _instance;
} _TMProofPathResponse_default_instance_;
class TMReplayDeltaRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMReplayDeltaRequest> _instance;
} _TMReplayDeltaRequest_default_instance_;
class TMReplayDeltaResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMReplayDeltaResponse> _instance;
} _TMReplayDeltaResponse_default_instance_;
}  // namespace protocol
static void InitDefaultsscc_info_TMCluster_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMCluster_default_instance_;
    new (ptr) ::protocol::TMCluster();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMCluster::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_TMCluster_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_TMCluster_ripple_2eproto}, {
      &scc_info_TMClusterNode_ripple_2eproto.base,
      &scc_info_TMLoadSource_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMClusterNode_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMClusterNode_default_instance_;
    new (ptr) ::protocol::TMClusterNode();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMClusterNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMClusterNode_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMClusterNode_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMEndpoints_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMEndpoints_default_instance_;
    new (ptr) ::protocol::TMEndpoints();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMEndpoints::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMEndpoints_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_TMEndpoints_ripple_2eproto}, {
      &scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMEndpoints_TMEndpointv2_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMEndpoints_TMEndpointv2_default_instance_;
    new (ptr) ::protocol::TMEndpoints_TMEndpointv2();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMEndpoints_TMEndpointv2::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMEndpoints_TMEndpointv2_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMGetLedger_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMGetLedger_default_instance_;
    new (ptr) ::protocol::TMGetLedger();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMGetLedger::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMGetLedger_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMGetLedger_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMGetObjectByHash_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMGetObjectByHash_default_instance_;
    new (ptr) ::protocol::TMGetObjectByHash();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMGetObjectByHash::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMGetObjectByHash_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_TMGetObjectByHash_ripple_2eproto}, {
      &scc_info_TMIndexedObject_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMGetPeerShardInfo_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMGetPeerShardInfo_default_instance_;
    new (ptr) ::protocol::TMGetPeerShardInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMGetPeerShardInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMGetPeerShardInfo_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_TMGetPeerShardInfo_ripple_2eproto}, {
      &scc_info_TMLink_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMGetShardInfo_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMGetShardInfo_default_instance_;
    new (ptr) ::protocol::TMGetShardInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMGetShardInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMGetShardInfo_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMGetShardInfo_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMHaveTransactionSet_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMHaveTransactionSet_default_instance_;
    new (ptr) ::protocol::TMHaveTransactionSet();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMHaveTransactionSet::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMHaveTransactionSet_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMHaveTransactionSet_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMIndexedObject_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMIndexedObject_default_instance_;
    new (ptr) ::protocol::TMIndexedObject();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMIndexedObject::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMIndexedObject_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMIndexedObject_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMLedgerData_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMLedgerData_default_instance_;
    new (ptr) ::protocol::TMLedgerData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMLedgerData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMLedgerData_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_TMLedgerData_ripple_2eproto}, {
      &scc_info_TMLedgerNode_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMLedgerNode_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMLedgerNode_default_instance_;
    new (ptr) ::protocol::TMLedgerNode();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMLedgerNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLedgerNode_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMLedgerNode_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMLink_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMLink_default_instance_;
    new (ptr) ::protocol::TMLink();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMLink::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLink_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMLink_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMLoadSource_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMLoadSource_default_instance_;
    new (ptr) ::protocol::TMLoadSource();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMLoadSource::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLoadSource_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMLoadSource_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMManifest_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMManifest_default_instance_;
    new (ptr) ::protocol::TMManifest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMManifest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMManifest_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMManifest_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMManifests_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMManifests_default_instance_;
    new (ptr) ::protocol::TMManifests();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMManifests::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMManifests_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_TMManifests_ripple_2eproto}, {
      &scc_info_TMManifest_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMPeerShardInfo_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMPeerShardInfo_default_instance_;
    new (ptr) ::protocol::TMPeerShardInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMPeerShardInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMPeerShardInfo_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_TMPeerShardInfo_ripple_2eproto}, {
      &scc_info_TMLink_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMPing_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMPing_default_instance_;
    new (ptr) ::protocol::TMPing();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMPing::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMPing_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMPing_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMProofPathRequest_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMProofPathRequest_default_instance_;
    new (ptr) ::protocol::TMProofPathRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMProofPathRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMProofPathRequest_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMProofPathRequest_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMProofPathResponse_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMProofPathResponse_default_instance_;
    new (ptr) ::protocol::TMProofPathResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMProofPathResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMProofPathResponse_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMProofPathResponse_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMProposeSet_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMProposeSet_default_instance_;
    new (ptr) ::protocol::TMProposeSet();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMProposeSet::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMProposeSet_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMProposeSet_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMReplayDeltaRequest_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMReplayDeltaRequest_default_instance_;
    new (ptr) ::protocol::TMReplayDeltaRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMReplayDeltaRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMReplayDeltaRequest_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMReplayDeltaRequest_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMReplayDeltaResponse_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMReplayDeltaResponse_default_instance_;
    new (ptr) ::protocol::TMReplayDeltaResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMReplayDeltaResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMReplayDeltaResponse_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMReplayDeltaResponse_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMShardInfo_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMShardInfo_default_instance_;
    new (ptr) ::protocol::TMShardInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMShardInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMShardInfo_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMShardInfo_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMSquelch_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMSquelch_default_instance_;
    new (ptr) ::protocol::TMSquelch();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMSquelch::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMSquelch_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMSquelch_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMStatusChange_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMStatusChange_default_instance_;
    new (ptr) ::protocol::TMStatusChange();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMStatusChange::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMStatusChange_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMStatusChange_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMTransaction_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMTransaction_default_instance_;
    new (ptr) ::protocol::TMTransaction();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMTransaction::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMTransaction_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMTransaction_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMValidation_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMValidation_default_instance_;
    new (ptr) ::protocol::TMValidation();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMValidation::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMValidation_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMValidation_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMValidatorList_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMValidatorList_default_instance_;
    new (ptr) ::protocol::TMValidatorList();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMValidatorList::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMValidatorList_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TMValidatorList_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMValidatorListCollection_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMValidatorListCollection_default_instance_;
    new (ptr) ::protocol::TMValidatorListCollection();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMValidatorListCollection::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMValidatorListCollection_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_TMValidatorListCollection_ripple_2eproto}, {
      &scc_info_ValidatorBlobInfo_ripple_2eproto.base,}};

static void InitDefaultsscc_info_ValidatorBlobInfo_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_ValidatorBlobInfo_default_instance_;
    new (ptr) ::protocol::ValidatorBlobInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::ValidatorBlobInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ValidatorBlobInfo_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_ValidatorBlobInfo_ripple_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_ripple_2eproto[31];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_ripple_2eproto[12];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_ripple_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_ripple_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifest, stobject_),
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifests, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifests, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifests, list_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifests, history_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, publickey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, reporttime_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, nodeload_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, nodename_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, address_),
  0,
  3,
  4,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, name_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, cost_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, count_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMCluster, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMCluster, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMCluster, clusternodes_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMCluster, loadsources_),
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetShardInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetShardInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetShardInfo, hops_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetShardInfo, lastlink_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetShardInfo, peerchain_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMShardInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMShardInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMShardInfo, shardindexes_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMShardInfo, nodepubkey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMShardInfo, endpoint_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMShardInfo, lastlink_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMShardInfo, peerchain_),
  0,
  1,
  2,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMLink, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLink, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMLink, nodepubkey_),
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, hops_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, lastlink_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, peerchain_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, shardindexes_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, nodepubkey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, endpoint_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, lastlink_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, peerchain_),
  0,
  1,
  2,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, rawtransaction_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, status_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, receivetimestamp_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, deferred_),
  0,
  3,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, newstatus_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, newevent_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, ledgerseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, ledgerhashprevious_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, networktime_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, firstseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, lastseq_),
  6,
  7,
  2,
  0,
  1,
  4,
  3,
  5,
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, proposeseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, currenttxhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, nodepubkey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, closetime_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, signature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, previousledger_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, addedtransactions_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, removedtransactions_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, checkedsignature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, hops_),
  4,
  0,
  1,
  5,
  2,
  3,
  ~0u,
  ~0u,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactionSet, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactionSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactionSet, status_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactionSet, hash_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, manifest_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, blob_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, signature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, version_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::protocol::ValidatorBlobInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::ValidatorBlobInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::ValidatorBlobInfo, manifest_),
  PROTOBUF_FIELD_OFFSET(::protocol::ValidatorBlobInfo, blob_),
  PROTOBUF_FIELD_OFFSET(::protocol::ValidatorBlobInfo, signature_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorListCollection, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorListCollection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorListCollection, version_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorListCollection, manifest_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorListCollection, blobs_),
  1,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, validation_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, checkedsignature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, hops_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints_TMEndpointv2, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints_TMEndpointv2, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints_TMEndpointv2, endpoint_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints_TMEndpointv2, hops_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, version_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, endpoints_v2_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, hash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, nodeid_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, index_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, data_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, ledgerseq_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, type_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, query_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, seq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, fat_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, objects_),
  1,
  3,
  2,
  0,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerNode, nodedata_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerNode, nodeid_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, itype_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, ltype_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, ledgerseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, nodeids_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, requestcookie_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, querytype_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, querydepth_),
  1,
  2,
  0,
  3,
  ~0u,
  5,
  4,
  6,
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, ledgerseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, type_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, nodes_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, requestcookie_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, error_),
  0,
  1,
  2,
  ~0u,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, type_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, seq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, pingtime_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, nettime_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::protocol::TMSquelch, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMSquelch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMSquelch, squelch_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMSquelch, validatorpubkey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMSquelch, squelchduration_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathRequest, key_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathRequest, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathRequest, type_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, key_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, type_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, ledgerheader_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, path_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, error_),
  0,
  1,
  3,
  2,
  ~0u,
  4,
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaRequest, ledgerhash_),
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, ledgerheader_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, transaction_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, error_),
  0,
  1,
  ~0u,
  2,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 6, sizeof(::protocol::TMManifest)},
  { 7, 14, sizeof(::protocol::TMManifests)},
  { 16, 26, sizeof(::protocol::TMClusterNode)},
  { 31, 39, sizeof(::protocol::TMLoadSource)},
  { 42, 49, sizeof(::protocol::TMCluster)},
  { 51, 59, sizeof(::protocol::TMGetShardInfo)},
  { 62, 72, sizeof(::protocol::TMShardInfo)},
  { 77, 83, sizeof(::protocol::TMLink)},
  { 84, 92, sizeof(::protocol::TMGetPeerShardInfo)},
  { 95, 105, sizeof(::protocol::TMPeerShardInfo)},
  { 110, 119, sizeof(::protocol::TMTransaction)},
  { 123, 136, sizeof(::protocol::TMStatusChange)},
  { 144, 159, sizeof(::protocol::TMProposeSet)},
  { 169, 176, sizeof(::protocol::TMHaveTransactionSet)},
  { 178, 187, sizeof(::protocol::TMValidatorList)},
  { 191, 199, sizeof(::protocol::ValidatorBlobInfo)},
  { 202, 210, sizeof(::protocol::TMValidatorListCollection)},
  { 213, 221, sizeof(::protocol::TMValidation)},
  { 224, 231, sizeof(::protocol::TMEndpoints_TMEndpointv2)},
  { 233, 240, sizeof(::protocol::TMEndpoints)},
  { 242, 252, sizeof(::protocol::TMIndexedObject)},
  { 257, 268, sizeof(::protocol::TMGetObjectByHash)},
  { 274, 281, sizeof(::protocol::TMLedgerNode)},
  { 283, 296, sizeof(::protocol::TMGetLedger)},
  { 304, 315, sizeof(::protocol::TMLedgerData)},
  { 321, 330, sizeof(::protocol::TMPing)},
  { 334, 342, sizeof(::protocol::TMSquelch)},
  { 345, 353, sizeof(::protocol::TMProofPathRequest)},
  { 356, 367, sizeof(::protocol::TMProofPathResponse)},
  { 373, 379, sizeof(::protocol::TMReplayDeltaRequest)},
  { 380, 389, sizeof(::protocol::TMReplayDeltaResponse)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMManifest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMManifests_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMClusterNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMLoadSource_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMCluster_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMGetShardInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMShardInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMLink_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMGetPeerShardInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMPeerShardInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMTransaction_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMStatusChange_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMProposeSet_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMHaveTransactionSet_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMValidatorList_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_ValidatorBlobInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMValidatorListCollection_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMValidation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMEndpoints_TMEndpointv2_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMEndpoints_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMIndexedObject_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMGetObjectByHash_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMLedgerNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMGetLedger_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMLedgerData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMPing_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMSquelch_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMProofPathRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMProofPathResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMReplayDeltaRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMReplayDeltaResponse_default_instance_),
};

const char descriptor_table_protodef_ripple_2eproto[] =
  "\n\014ripple.proto\022\010protocol\"\036\n\nTMManifest\022\020"
  "\n\010stobject\030\001 \002(\014\"F\n\013TMManifests\022\"\n\004list\030"
  "\001 \003(\0132\024.protocol.TMManifest\022\023\n\007history\030\002"
  " \001(\010B\002\030\001\"k\n\rTMClusterNode\022\021\n\tpublicKey\030\001"
  " \002(\t\022\022\n\nreportTime\030\002 \002(\r\022\020\n\010nodeLoad\030\003 \002"
  "(\r\022\020\n\010nodeName\030\004 \001(\t\022\017\n\007address\030\005 \001(\t\"9\n"
  "\014TMLoadSource\022\014\n\004name\030\001 \002(\t\022\014\n\004cost\030\002 \002("
  "\r\022\r\n\005count\030\003 \001(\r\"g\n\tTMCluster\022-\n\014cluster"
  "Nodes\030\001 \003(\0132\027.protocol.TMClusterNode\022+\n\013"
  "loadSources\030\002 \003(\0132\026.protocol.TMLoadSourc"
  "e\"O\n\016TMGetShardInfo\022\020\n\004hops\030\001 \002(\rB\002\030\001\022\024\n"
  "\010lastLink\030\002 \001(\010B\002\030\001\022\025\n\tpeerchain\030\003 \003(\rB\002"
  "\030\001\"\202\001\n\013TMShardInfo\022\030\n\014shardIndexes\030\001 \002(\t"
  "B\002\030\001\022\026\n\nnodePubKey\030\002 \001(\014B\002\030\001\022\024\n\010endpoint"
  "\030\003 \001(\tB\002\030\001\022\024\n\010lastLink\030\004 \001(\010B\002\030\001\022\025\n\tpeer"
  "chain\030\005 \003(\rB\002\030\001\"\034\n\006TMLink\022\022\n\nnodePubKey\030"
  "\001 \002(\014\"Y\n\022TMGetPeerShardInfo\022\014\n\004hops\030\001 \002("
  "\r\022\020\n\010lastLink\030\002 \001(\010\022#\n\tpeerChain\030\003 \003(\0132\020"
  ".protocol.TMLink\"\204\001\n\017TMPeerShardInfo\022\024\n\014"
  "shardIndexes\030\001 \002(\t\022\022\n\nnodePubKey\030\002 \001(\014\022\020"
  "\n\010endpoint\030\003 \001(\t\022\020\n\010lastLink\030\004 \001(\010\022#\n\tpe"
  "erChain\030\005 \003(\0132\020.protocol.TMLink\"\200\001\n\rTMTr"
  "ansaction\022\026\n\016rawTransaction\030\001 \002(\014\022+\n\006sta"
  "tus\030\002 \002(\0162\033.protocol.TransactionStatus\022\030"
  "\n\020receiveTimestamp\030\003 \001(\004\022\020\n\010deferred\030\004 \001"
  "(\010\"\333\001\n\016TMStatusChange\022\'\n\tnewStatus\030\001 \001(\016"
  "2\024.protocol.NodeStatus\022%\n\010newEvent\030\002 \001(\016"
  "2\023.protocol.NodeEvent\022\021\n\tledgerSeq\030\003 \001(\r"
  "\022\022\n\nledgerHash\030\004 \001(\014\022\032\n\022ledgerHashPrevio"
  "us\030\005 \001(\014\022\023\n\013networkTime\030\006 \001(\004\022\020\n\010firstSe"
  "q\030\007 \001(\r\022\017\n\007lastSeq\030\010 \001(\r\"\363\001\n\014TMProposeSe"
  "t\022\022\n\nproposeSeq\030\001 \002(\r\022\025\n\rcurrentTxHash\030\002"
  " \002(\014\022\022\n\nnodePubKey\030\003 \002(\014\022\021\n\tcloseTime\030\004 "
  "\002(\r\022\021\n\tsignature\030\005 \002(\014\022\026\n\016previousledger"
  "\030\006 \002(\014\022\031\n\021addedTransactions\030\n \003(\014\022\033\n\023rem"
  "ovedTransactions\030\013 \003(\014\022\034\n\020checkedSignatu"
  "re\030\007 \001(\010B\002\030\001\022\020\n\004hops\030\014 \001(\rB\002\030\001\"K\n\024TMHave"
  "TransactionSet\022%\n\006status\030\001 \002(\0162\025.protoco"
  "l.TxSetStatus\022\014\n\004hash\030\002 \002(\014\"U\n\017TMValidat"
  "orList\022\020\n\010manifest\030\001 \002(\014\022\014\n\004blob\030\002 \002(\014\022\021"
  "\n\tsignature\030\003 \002(\014\022\017\n\007version\030\004 \002(\r\"F\n\021Va"
  "lidatorBlobInfo\022\020\n\010manifest\030\001 \001(\014\022\014\n\004blo"
  "b\030\002 \002(\014\022\021\n\tsignature\030\003 \002(\014\"j\n\031TMValidato"
  "rListCollection\022\017\n\007version\030\001 \002(\r\022\020\n\010mani"
  "fest\030\002 \002(\014\022*\n\005blobs\030\003 \003(\0132\033.protocol.Val"
  "idatorBlobInfo\"R\n\014TMValidation\022\022\n\nvalida"
  "tion\030\001 \002(\014\022\034\n\020checkedSignature\030\002 \001(\010B\002\030\001"
  "\022\020\n\004hops\030\003 \001(\rB\002\030\001\"\216\001\n\013TMEndpoints\022\017\n\007ve"
  "rsion\030\001 \002(\r\0228\n\014endpoints_v2\030\003 \003(\0132\".prot"
  "ocol.TMEndpoints.TMEndpointv2\032.\n\014TMEndpo"
  "intv2\022\020\n\010endpoint\030\001 \002(\t\022\014\n\004hops\030\002 \002(\rJ\004\010"
  "\002\020\003\"_\n\017TMIndexedObject\022\014\n\004hash\030\001 \001(\014\022\016\n\006"
  "nodeID\030\002 \001(\014\022\r\n\005index\030\003 \001(\014\022\014\n\004data\030\004 \001("
  "\014\022\021\n\tledgerSeq\030\005 \001(\r\"\277\002\n\021TMGetObjectByHa"
  "sh\0224\n\004type\030\001 \002(\0162&.protocol.TMGetObjectB"
  "yHash.ObjectType\022\r\n\005query\030\002 \002(\010\022\013\n\003seq\030\003"
  " \001(\r\022\022\n\nledgerHash\030\004 \001(\014\022\013\n\003fat\030\005 \001(\010\022*\n"
  "\007objects\030\006 \003(\0132\031.protocol.TMIndexedObjec"
  "t\"\212\001\n\nObjectType\022\r\n\totUNKNOWN\020\000\022\014\n\010otLED"
  "GER\020\001\022\021\n\rotTRANSACTION\020\002\022\026\n\022otTRANSACTIO"
  "N_NODE\020\003\022\020\n\014otSTATE_NODE\020\004\022\020\n\014otCAS_OBJE"
  "CT\020\005\022\020\n\014otFETCH_PACK\020\006\"0\n\014TMLedgerNode\022\020"
  "\n\010nodedata\030\001 \002(\014\022\016\n\006nodeid\030\002 \001(\014\"\354\001\n\013TMG"
  "etLedger\022)\n\005itype\030\001 \002(\0162\032.protocol.TMLed"
  "gerInfoType\022%\n\005ltype\030\002 \001(\0162\026.protocol.TM"
  "LedgerType\022\022\n\nledgerHash\030\003 \001(\014\022\021\n\tledger"
  "Seq\030\004 \001(\r\022\017\n\007nodeIDs\030\005 \003(\014\022\025\n\rrequestCoo"
  "kie\030\006 \001(\004\022(\n\tqueryType\030\007 \001(\0162\025.protocol."
  "TMQueryType\022\022\n\nqueryDepth\030\010 \001(\r\"\304\001\n\014TMLe"
  "dgerData\022\022\n\nledgerHash\030\001 \002(\014\022\021\n\tledgerSe"
  "q\030\002 \002(\r\022(\n\004type\030\003 \002(\0162\032.protocol.TMLedge"
  "rInfoType\022%\n\005nodes\030\004 \003(\0132\026.protocol.TMLe"
  "dgerNode\022\025\n\rrequestCookie\030\005 \001(\r\022%\n\005error"
  "\030\006 \001(\0162\026.protocol.TMReplyError\"\205\001\n\006TMPin"
  "g\022\'\n\004type\030\001 \002(\0162\031.protocol.TMPing.pingTy"
  "pe\022\013\n\003seq\030\002 \001(\r\022\020\n\010pingTime\030\003 \001(\004\022\017\n\007net"
  "Time\030\004 \001(\004\"\"\n\010pingType\022\n\n\006ptPING\020\000\022\n\n\006pt"
  "PONG\020\001\"N\n\tTMSquelch\022\017\n\007squelch\030\001 \002(\010\022\027\n\017"
  "validatorPubKey\030\002 \002(\014\022\027\n\017squelchDuration"
  "\030\003 \001(\r\"^\n\022TMProofPathRequest\022\013\n\003key\030\001 \002("
  "\014\022\022\n\nledgerHash\030\002 \002(\014\022\'\n\004type\030\003 \002(\0162\031.pr"
  "otocol.TMLedgerMapType\"\252\001\n\023TMProofPathRe"
  "sponse\022\013\n\003key\030\001 \002(\014\022\022\n\nledgerHash\030\002 \002(\014\022"
  "\'\n\004type\030\003 \002(\0162\031.protocol.TMLedgerMapType"
  "\022\024\n\014ledgerHeader\030\004 \001(\014\022\014\n\004path\030\005 \003(\014\022%\n\005"
  "error\030\006 \001(\0162\026.protocol.TMReplyError\"*\n\024T"
  "MReplayDeltaRequest\022\022\n\nledgerHash\030\001 \002(\014\""
  "}\n\025TMReplayDeltaResponse\022\022\n\nledgerHash\030\001"
  " \002(\014\022\024\n\014ledgerHeader\030\002 \001(\014\022\023\n\013transactio"
  "n\030\003 \003(\014\022%\n\005error\030\004 \001(\0162\026.protocol.TMRepl"
  "yError*\345\003\n\013MessageType\022\017\n\013mtMANIFESTS\020\002\022"
  "\n\n\006mtPING\020\003\022\r\n\tmtCLUSTER\020\005\022\017\n\013mtENDPOINT"
  "S\020\017\022\021\n\rmtTRANSACTION\020\036\022\020\n\014mtGET_LEDGER\020\037"
  "\022\021\n\rmtLEDGER_DATA\020 \022\024\n\020mtPROPOSE_LEDGER\020"
  "!\022\023\n\017mtSTATUS_CHANGE\020\"\022\016\n\nmtHAVE_SET\020#\022\020"
  "\n\014mtVALIDATION\020)\022\021\n\rmtGET_OBJECTS\020*\022\024\n\020m"
  "tGET_SHARD_INFO\0202\022\020\n\014mtSHARD_INFO\0203\022\031\n\025m"
  "tGET_PEER_SHARD_INFO\0204\022\025\n\021mtPEER_SHARD_I"
  "NFO\0205\022\023\n\017mtVALIDATORLIST\0206\022\r\n\tmtSQUELCH\020"
  "7\022\035\n\031mtVALIDATORLISTCOLLECTION\0208\022\024\n\020mtPR"
  "OOF_PATH_REQ\0209\022\031\n\025mtPROOF_PATH_RESPONSE\020"
  ":\022\026\n\022mtREPLAY_DELTA_REQ\020;\022\033\n\027mtREPLAY_DE"
  "LTA_RESPONSE\020<*\241\001\n\021TransactionStatus\022\t\n\005"
  "tsNEW\020\001\022\r\n\ttsCURRENT\020\002\022\016\n\ntsCOMMITED\020\003\022\025"
  "\n\021tsREJECT_CONFLICT\020\004\022\024\n\020tsREJECT_INVALI"
  "D\020\005\022\022\n\016tsREJECT_FUNDS\020\006\022\016\n\ntsHELD_SEQ\020\007\022"
  "\021\n\rtsHELD_LEDGER\020\010*c\n\nNodeStatus\022\020\n\014nsCO"
  "NNECTING\020\001\022\017\n\013nsCONNECTED\020\002\022\020\n\014nsMONITOR"
  "ING\020\003\022\020\n\014nsVALIDATING\020\004\022\016\n\nnsSHUTTING\020\005*"
  "`\n\tNodeEvent\022\024\n\020neCLOSING_LEDGER\020\001\022\025\n\021ne"
  "ACCEPTED_LEDGER\020\002\022\025\n\021neSWITCHED_LEDGER\020\003"
  "\022\017\n\013neLOST_SYNC\020\004*4\n\013TxSetStatus\022\n\n\006tsHA"
  "VE\020\001\022\r\n\ttsCAN_GET\020\002\022\n\n\006tsNEED\020\003*P\n\020TMLed"
  "gerInfoType\022\n\n\006liBASE\020\000\022\r\n\tliTX_NODE\020\001\022\r"
  "\n\tliAS_NODE\020\002\022\022\n\016liTS_CANDIDATE\020\003*;\n\014TML"
  "edgerType\022\016\n\nltACCEPTED\020\000\022\r\n\tltCURRENT\020\001"
  "\022\014\n\010ltCLOSED\020\002*\035\n\013TMQueryType\022\016\n\nqtINDIR"
  "ECT\020\000*A\n\014TMReplyError\022\017\n\013reNO_LEDGER\020\001\022\r"
  "\n\treNO_NODE\020\002\022\021\n\rreBAD_REQUEST\020\003*9\n\017TMLe"
  "dgerMapType\022\021\n\rlmTRANASCTION\020\001\022\023\n\017lmACCO"
  "UNT_STATE\020\002"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_ripple_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_ripple_2eproto_sccs[31] = {
  &scc_info_TMCluster_ripple_2eproto.base,
  &scc_info_TMClusterNode_ripple_2eproto.base,
  &scc_info_TMEndpoints_ripple_2eproto.base,
  &scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto.base,
  &scc_info_TMGetLedger_ripple_2eproto.base,
  &scc_info_TMGetObjectByHash_ripple_2eproto.base,
  &scc_info_TMGetPeerShardInfo_ripple_2eproto.base,
  &scc_info_TMGetShardInfo_ripple_2eproto.base,
  &scc_info_TMHaveTransactionSet_ripple_2eproto.base,
  &scc_info_TMIndexedObject_ripple_2eproto.base,
  &scc_info_TMLedgerData_ripple_2eproto.base,
  &scc_info_TMLedgerNode_ripple_2eproto.base,
  &scc_info_TMLink_ripple_2eproto.base,
  &scc_info_TMLoadSource_ripple_2eproto.base,
  &scc_info_TMManifest_ripple_2eproto.base,
  &scc_info_TMManifests_ripple_2eproto.base,
  &scc_info_TMPeerShardInfo_ripple_2eproto.base,
  &scc_info_TMPing_ripple_2eproto.base,
  &scc_info_TMProofPathRequest_ripple_2eproto.base,
  &scc_info_TMProofPathResponse_ripple_2eproto.base,
  &scc_info_TMProposeSet_ripple_2eproto.base,
  &scc_info_TMReplayDeltaRequest_ripple_2eproto.base,
  &scc_info_TMReplayDeltaResponse_ripple_2eproto.base,
  &scc_info_TMShardInfo_ripple_2eproto.base,
  &scc_info_TMSquelch_ripple_2eproto.base,
  &scc_info_TMStatusChange_ripple_2eproto.base,
  &scc_info_TMTransaction_ripple_2eproto.base,
  &scc_info_TMValidation_ripple_2eproto.base,
  &scc_info_TMValidatorList_ripple_2eproto.base,
  &scc_info_TMValidatorListCollection_ripple_2eproto.base,
  &scc_info_ValidatorBlobInfo_ripple_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_ripple_2eproto_once;
static bool descriptor_table_ripple_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ripple_2eproto = {
  &descriptor_table_ripple_2eproto_initialized, descriptor_table_protodef_ripple_2eproto, "ripple.proto", 4811,
  &descriptor_table_ripple_2eproto_once, descriptor_table_ripple_2eproto_sccs, descriptor_table_ripple_2eproto_deps, 31, 0,
  schemas, file_default_instances, TableStruct_ripple_2eproto::offsets,
  file_level_metadata_ripple_2eproto, 31, file_level_enum_descriptors_ripple_2eproto, file_level_service_descriptors_ripple_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_ripple_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_ripple_2eproto), true);
namespace protocol {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMGetObjectByHash_ObjectType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[0];
}
bool TMGetObjectByHash_ObjectType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otUNKNOWN;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otLEDGER;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otTRANSACTION;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otTRANSACTION_NODE;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otSTATE_NODE;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otCAS_OBJECT;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otFETCH_PACK;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::ObjectType_MIN;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::ObjectType_MAX;
constexpr int TMGetObjectByHash::ObjectType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMPing_pingType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[1];
}
bool TMPing_pingType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TMPing_pingType TMPing::ptPING;
constexpr TMPing_pingType TMPing::ptPONG;
constexpr TMPing_pingType TMPing::pingType_MIN;
constexpr TMPing_pingType TMPing::pingType_MAX;
constexpr int TMPing::pingType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[2];
}
bool MessageType_IsValid(int value) {
  switch (value) {
    case 2:
    case 3:
    case 5:
    case 15:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 41:
    case 42:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[3];
}
bool TransactionStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[4];
}
bool NodeStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeEvent_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[5];
}
bool NodeEvent_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TxSetStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[6];
}
bool TxSetStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMLedgerInfoType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[7];
}
bool TMLedgerInfoType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMLedgerType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[8];
}
bool TMLedgerType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMQueryType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[9];
}
bool TMQueryType_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMReplyError_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[10];
}
bool TMReplyError_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMLedgerMapType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[11];
}
bool TMLedgerMapType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void TMManifest::InitAsDefaultInstance() {
}
class TMManifest::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMManifest>()._has_bits_);
  static void set_has_stobject(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMManifest::kStobjectFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMManifest::TMManifest()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMManifest)
}
TMManifest::TMManifest(const TMManifest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  stobject_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_stobject()) {
    stobject_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.stobject_);
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMManifest)
}

void TMManifest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMManifest_ripple_2eproto.base);
  stobject_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

TMManifest::~TMManifest() {
  // @@protoc_insertion_point(destructor:protocol.TMManifest)
  SharedDtor();
}

void TMManifest::SharedDtor() {
  stobject_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMManifest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMManifest& TMManifest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMManifest_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMManifest::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMManifest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    stobject_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMManifest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes stobject = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_stobject(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMManifest::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMManifest)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes stobject = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_stobject()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMManifest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMManifest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMManifest::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMManifest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes stobject = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->stobject(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMManifest)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMManifest::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMManifest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes stobject = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->stobject(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMManifest)
  return target;
}

size_t TMManifest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMManifest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required bytes stobject = 1;
  if (has_stobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->stobject());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMManifest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMManifest)
  GOOGLE_DCHECK_NE(&from, this);
  const TMManifest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMManifest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMManifest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMManifest)
    MergeFrom(*source);
  }
}

void TMManifest::MergeFrom(const TMManifest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMManifest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_stobject()) {
    _has_bits_[0] |= 0x00000001u;
    stobject_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.stobject_);
  }
}

void TMManifest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMManifest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMManifest::CopyFrom(const TMManifest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMManifest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMManifest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void TMManifest::Swap(TMManifest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMManifest::InternalSwap(TMManifest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  stobject_.Swap(&other->stobject_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata TMManifest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMManifests::InitAsDefaultInstance() {
}
class TMManifests::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMManifests>()._has_bits_);
  static void set_has_history(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMManifests::kListFieldNumber;
const int TMManifests::kHistoryFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMManifests::TMManifests()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMManifests)
}
TMManifests::TMManifests(const TMManifests& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      list_(from.list_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  history_ = from.history_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMManifests)
}

void TMManifests::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMManifests_ripple_2eproto.base);
  history_ = false;
}

TMManifests::~TMManifests() {
  // @@protoc_insertion_point(destructor:protocol.TMManifests)
  SharedDtor();
}

void TMManifests::SharedDtor() {
}

void TMManifests::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMManifests& TMManifests::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMManifests_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMManifests::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMManifests)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  list_.Clear();
  history_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMManifests::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .protocol.TMManifest list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      // optional bool history = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_history(&has_bits);
          history_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMManifests::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMManifests)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .protocol.TMManifest list = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_list()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool history = 2 [deprecated = true];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_history(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &history_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMManifests)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMManifests)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMManifests::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMManifests)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMManifest list = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->list_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->list(static_cast<int>(i)),
      output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool history = 2 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->history(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMManifests)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMManifests::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMManifests)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMManifest list = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->list_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->list(static_cast<int>(i)), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool history = 2 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->history(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMManifests)
  return target;
}

size_t TMManifests::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMManifests)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMManifest list = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->list_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->list(static_cast<int>(i)));
    }
  }

  // optional bool history = 2 [deprecated = true];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMManifests::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMManifests)
  GOOGLE_DCHECK_NE(&from, this);
  const TMManifests* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMManifests>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMManifests)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMManifests)
    MergeFrom(*source);
  }
}

void TMManifests::MergeFrom(const TMManifests& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMManifests)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  list_.MergeFrom(from.list_);
  if (from.has_history()) {
    set_history(from.history());
  }
}

void TMManifests::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMManifests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMManifests::CopyFrom(const TMManifests& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMManifests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMManifests::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->list())) return false;
  return true;
}

void TMManifests::Swap(TMManifests* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMManifests::InternalSwap(TMManifests* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&list_)->InternalSwap(CastToBase(&other->list_));
  swap(history_, other->history_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMManifests::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMClusterNode::InitAsDefaultInstance() {
}
class TMClusterNode::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMClusterNode>()._has_bits_);
  static void set_has_publickey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reporttime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nodeload(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_nodename(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMClusterNode::kPublicKeyFieldNumber;
const int TMClusterNode::kReportTimeFieldNumber;
const int TMClusterNode::kNodeLoadFieldNumber;
const int TMClusterNode::kNodeNameFieldNumber;
const int TMClusterNode::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMClusterNode::TMClusterNode()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMClusterNode)
}
TMClusterNode::TMClusterNode(const TMClusterNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  publickey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_publickey()) {
    publickey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.publickey_);
  }
  nodename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_nodename()) {
    nodename_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nodename_);
  }
  address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  ::memcpy(&reporttime_, &from.reporttime_,
    static_cast<size_t>(reinterpret_cast<char*>(&nodeload_) -
    reinterpret_cast<char*>(&reporttime_)) + sizeof(nodeload_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMClusterNode)
}

void TMClusterNode::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMClusterNode_ripple_2eproto.base);
  publickey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&reporttime_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nodeload_) -
      reinterpret_cast<char*>(&reporttime_)) + sizeof(nodeload_));
}

TMClusterNode::~TMClusterNode() {
  // @@protoc_insertion_point(destructor:protocol.TMClusterNode)
  SharedDtor();
}

void TMClusterNode::SharedDtor() {
  publickey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMClusterNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMClusterNode& TMClusterNode::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMClusterNode_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMClusterNode::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMClusterNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      publickey_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      nodename_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      address_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&reporttime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nodeload_) -
        reinterpret_cast<char*>(&reporttime_)) + sizeof(nodeload_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMClusterNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string publicKey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_publickey(), ptr, ctx, "protocol.TMClusterNode.publicKey");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 reportTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_reporttime(&has_bits);
          reporttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 nodeLoad = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_nodeload(&has_bits);
          nodeload_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string nodeName = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_nodename(), ptr, ctx, "protocol.TMClusterNode.nodeName");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string address = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_address(), ptr, ctx, "protocol.TMClusterNode.address");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMClusterNode::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMClusterNode)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string publicKey = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_publickey()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->publickey().data(), static_cast<int>(this->publickey().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "protocol.TMClusterNode.publicKey");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 reportTime = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_reporttime(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reporttime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 nodeLoad = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_nodeload(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nodeload_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string nodeName = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_nodename()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->nodename().data(), static_cast<int>(this->nodename().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "protocol.TMClusterNode.nodeName");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string address = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), static_cast<int>(this->address().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "protocol.TMClusterNode.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMClusterNode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMClusterNode)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMClusterNode::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMClusterNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string publicKey = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->publickey().data(), static_cast<int>(this->publickey().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.publicKey");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->publickey(), output);
  }

  // required uint32 reportTime = 2;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->reporttime(), output);
  }

  // required uint32 nodeLoad = 3;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->nodeload(), output);
  }

  // optional string nodeName = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->nodename().data(), static_cast<int>(this->nodename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.nodeName");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->nodename(), output);
  }

  // optional string address = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.address");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMClusterNode)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMClusterNode::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMClusterNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string publicKey = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->publickey().data(), static_cast<int>(this->publickey().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.publicKey");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        1, this->publickey(), target);
  }

  // required uint32 reportTime = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->reporttime(), target);
  }

  // required uint32 nodeLoad = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->nodeload(), target);
  }

  // optional string nodeName = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->nodename().data(), static_cast<int>(this->nodename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.nodeName");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        4, this->nodename(), target);
  }

  // optional string address = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.address");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        5, this->address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMClusterNode)
  return target;
}

size_t TMClusterNode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMClusterNode)
  size_t total_size = 0;

  if (has_publickey()) {
    // required string publicKey = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->publickey());
  }

  if (has_reporttime()) {
    // required uint32 reportTime = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->reporttime());
  }

  if (has_nodeload()) {
    // required uint32 nodeLoad = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->nodeload());
  }

  return total_size;
}
size_t TMClusterNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMClusterNode)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000019) ^ 0x00000019) == 0) {  // All required fields are present.
    // required string publicKey = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->publickey());

    // required uint32 reportTime = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->reporttime());

    // required uint32 nodeLoad = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->nodeload());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional string nodeName = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->nodename());
    }

    // optional string address = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->address());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMClusterNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMClusterNode)
  GOOGLE_DCHECK_NE(&from, this);
  const TMClusterNode* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMClusterNode>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMClusterNode)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMClusterNode)
    MergeFrom(*source);
  }
}

void TMClusterNode::MergeFrom(const TMClusterNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMClusterNode)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      publickey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.publickey_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      nodename_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nodename_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      address_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.address_);
    }
    if (cached_has_bits & 0x00000008u) {
      reporttime_ = from.reporttime_;
    }
    if (cached_has_bits & 0x00000010u) {
      nodeload_ = from.nodeload_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMClusterNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMClusterNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMClusterNode::CopyFrom(const TMClusterNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMClusterNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMClusterNode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000019) != 0x00000019) return false;
  return true;
}

void TMClusterNode::Swap(TMClusterNode* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMClusterNode::InternalSwap(TMClusterNode* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  publickey_.Swap(&other->publickey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  nodename_.Swap(&other->nodename_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  address_.Swap(&other->address_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(reporttime_, other->reporttime_);
  swap(nodeload_, other->nodeload_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMClusterNode::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMLoadSource::InitAsDefaultInstance() {
}
class TMLoadSource::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMLoadSource>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMLoadSource::kNameFieldNumber;
const int TMLoadSource::kCostFieldNumber;
const int TMLoadSource::kCountFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMLoadSource::TMLoadSource()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMLoadSource)
}
TMLoadSource::TMLoadSource(const TMLoadSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ::memcpy(&cost_, &from.cost_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&cost_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMLoadSource)
}

void TMLoadSource::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMLoadSource_ripple_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&cost_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&count_) -
      reinterpret_cast<char*>(&cost_)) + sizeof(count_));
}

TMLoadSource::~TMLoadSource() {
  // @@protoc_insertion_point(destructor:protocol.TMLoadSource)
  SharedDtor();
}

void TMLoadSource::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMLoadSource::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMLoadSource& TMLoadSource::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMLoadSource_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMLoadSource::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLoadSource)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&cost_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&cost_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMLoadSource::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_name(), ptr, ctx, "protocol.TMLoadSource.name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_cost(&has_bits);
          cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMLoadSource::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMLoadSource)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), static_cast<int>(this->name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "protocol.TMLoadSource.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 cost = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_cost(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cost_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 count = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_count(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMLoadSource)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMLoadSource)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMLoadSource::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMLoadSource)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMLoadSource.name");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required uint32 cost = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->cost(), output);
  }

  // optional uint32 count = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->count(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMLoadSource)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMLoadSource::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLoadSource)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMLoadSource.name");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required uint32 cost = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->cost(), target);
  }

  // optional uint32 count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->count(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLoadSource)
  return target;
}

size_t TMLoadSource::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMLoadSource)
  size_t total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_cost()) {
    // required uint32 cost = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->cost());
  }

  return total_size;
}
size_t TMLoadSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLoadSource)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->name());

    // required uint32 cost = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->cost());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 count = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->count());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMLoadSource::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMLoadSource)
  GOOGLE_DCHECK_NE(&from, this);
  const TMLoadSource* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMLoadSource>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMLoadSource)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMLoadSource)
    MergeFrom(*source);
  }
}

void TMLoadSource::MergeFrom(const TMLoadSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLoadSource)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      cost_ = from.cost_;
    }
    if (cached_has_bits & 0x00000004u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMLoadSource::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMLoadSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLoadSource::CopyFrom(const TMLoadSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLoadSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLoadSource::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void TMLoadSource::Swap(TMLoadSource* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMLoadSource::InternalSwap(TMLoadSource* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(cost_, other->cost_);
  swap(count_, other->count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMLoadSource::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMCluster::InitAsDefaultInstance() {
}
class TMCluster::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMCluster>()._has_bits_);
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMCluster::kClusterNodesFieldNumber;
const int TMCluster::kLoadSourcesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMCluster::TMCluster()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMCluster)
}
TMCluster::TMCluster(const TMCluster& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      clusternodes_(from.clusternodes_),
      loadsources_(from.loadsources_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protocol.TMCluster)
}

void TMCluster::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMCluster_ripple_2eproto.base);
}

TMCluster::~TMCluster() {
  // @@protoc_insertion_point(destructor:protocol.TMCluster)
  SharedDtor();
}

void TMCluster::SharedDtor() {
}

void TMCluster::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMCluster& TMCluster::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMCluster_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMCluster::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMCluster)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clusternodes_.Clear();
  loadsources_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMCluster::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .protocol.TMClusterNode clusterNodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_clusternodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMLoadSource loadSources = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_loadsources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMCluster::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMCluster)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .protocol.TMClusterNode clusterNodes = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_clusternodes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .protocol.TMLoadSource loadSources = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_loadsources()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMCluster)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMCluster)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMCluster::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMCluster)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMClusterNode clusterNodes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->clusternodes_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->clusternodes(static_cast<int>(i)),
      output);
  }

  // repeated .protocol.TMLoadSource loadSources = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->loadsources_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->loadsources(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMCluster)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMCluster::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMCluster)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMClusterNode clusterNodes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->clusternodes_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->clusternodes(static_cast<int>(i)), target);
  }

  // repeated .protocol.TMLoadSource loadSources = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->loadsources_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->loadsources(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMCluster)
  return target;
}

size_t TMCluster::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMCluster)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMClusterNode clusterNodes = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->clusternodes_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->clusternodes(static_cast<int>(i)));
    }
  }

  // repeated .protocol.TMLoadSource loadSources = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->loadsources_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->loadsources(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMCluster::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMCluster)
  GOOGLE_DCHECK_NE(&from, this);
  const TMCluster* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMCluster>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMCluster)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMCluster)
    MergeFrom(*source);
  }
}

void TMCluster::MergeFrom(const TMCluster& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMCluster)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  clusternodes_.MergeFrom(from.clusternodes_);
  loadsources_.MergeFrom(from.loadsources_);
}

void TMCluster::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMCluster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMCluster::CopyFrom(const TMCluster& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMCluster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMCluster::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->clusternodes())) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->loadsources())) return false;
  return true;
}

void TMCluster::Swap(TMCluster* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMCluster::InternalSwap(TMCluster* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&clusternodes_)->InternalSwap(CastToBase(&other->clusternodes_));
  CastToBase(&loadsources_)->InternalSwap(CastToBase(&other->loadsources_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMCluster::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMGetShardInfo::InitAsDefaultInstance() {
}
class TMGetShardInfo::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMGetShardInfo>()._has_bits_);
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lastlink(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMGetShardInfo::kHopsFieldNumber;
const int TMGetShardInfo::kLastLinkFieldNumber;
const int TMGetShardInfo::kPeerchainFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMGetShardInfo::TMGetShardInfo()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMGetShardInfo)
}
TMGetShardInfo::TMGetShardInfo(const TMGetShardInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      peerchain_(from.peerchain_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&hops_, &from.hops_,
    static_cast<size_t>(reinterpret_cast<char*>(&lastlink_) -
    reinterpret_cast<char*>(&hops_)) + sizeof(lastlink_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetShardInfo)
}

void TMGetShardInfo::SharedCtor() {
  ::memset(&hops_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lastlink_) -
      reinterpret_cast<char*>(&hops_)) + sizeof(lastlink_));
}

TMGetShardInfo::~TMGetShardInfo() {
  // @@protoc_insertion_point(destructor:protocol.TMGetShardInfo)
  SharedDtor();
}

void TMGetShardInfo::SharedDtor() {
}

void TMGetShardInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMGetShardInfo& TMGetShardInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMGetShardInfo_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMGetShardInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  peerchain_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&hops_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lastlink_) -
        reinterpret_cast<char*>(&hops_)) + sizeof(lastlink_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMGetShardInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 hops = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_hops(&has_bits);
          hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool lastLink = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_lastlink(&has_bits);
          lastlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 peerchain = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_peerchain(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 24);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(mutable_peerchain(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMGetShardInfo::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMGetShardInfo)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 hops = 1 [deprecated = true];
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_hops(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hops_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool lastLink = 2 [deprecated = true];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_lastlink(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &lastlink_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint32 peerchain = 3 [deprecated = true];
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24u, input, this->mutable_peerchain())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_peerchain())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMGetShardInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMGetShardInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMGetShardInfo::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMGetShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 hops = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->hops(), output);
  }

  // optional bool lastLink = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->lastlink(), output);
  }

  // repeated uint32 peerchain = 3 [deprecated = true];
  for (int i = 0, n = this->peerchain_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(
      3, this->peerchain(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMGetShardInfo)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMGetShardInfo::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 hops = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->hops(), target);
  }

  // optional bool lastLink = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->lastlink(), target);
  }

  // repeated uint32 peerchain = 3 [deprecated = true];
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteUInt32ToArray(3, this->peerchain_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetShardInfo)
  return target;
}

size_t TMGetShardInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetShardInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required uint32 hops = 1 [deprecated = true];
  if (has_hops()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->hops());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 peerchain = 3 [deprecated = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->peerchain_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->peerchain_size());
    total_size += data_size;
  }

  // optional bool lastLink = 2 [deprecated = true];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMGetShardInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMGetShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const TMGetShardInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMGetShardInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMGetShardInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMGetShardInfo)
    MergeFrom(*source);
  }
}

void TMGetShardInfo::MergeFrom(const TMGetShardInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  peerchain_.MergeFrom(from.peerchain_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hops_ = from.hops_;
    }
    if (cached_has_bits & 0x00000002u) {
      lastlink_ = from.lastlink_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMGetShardInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMGetShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetShardInfo::CopyFrom(const TMGetShardInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetShardInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void TMGetShardInfo::Swap(TMGetShardInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMGetShardInfo::InternalSwap(TMGetShardInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  peerchain_.InternalSwap(&other->peerchain_);
  swap(hops_, other->hops_);
  swap(lastlink_, other->lastlink_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMGetShardInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMShardInfo::InitAsDefaultInstance() {
}
class TMShardInfo::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMShardInfo>()._has_bits_);
  static void set_has_shardindexes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodepubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_endpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lastlink(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMShardInfo::kShardIndexesFieldNumber;
const int TMShardInfo::kNodePubKeyFieldNumber;
const int TMShardInfo::kEndpointFieldNumber;
const int TMShardInfo::kLastLinkFieldNumber;
const int TMShardInfo::kPeerchainFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMShardInfo::TMShardInfo()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMShardInfo)
}
TMShardInfo::TMShardInfo(const TMShardInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      peerchain_(from.peerchain_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  shardindexes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_shardindexes()) {
    shardindexes_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.shardindexes_);
  }
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_nodepubkey()) {
    nodepubkey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nodepubkey_);
  }
  endpoint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_endpoint()) {
    endpoint_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.endpoint_);
  }
  lastlink_ = from.lastlink_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMShardInfo)
}

void TMShardInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMShardInfo_ripple_2eproto.base);
  shardindexes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  endpoint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  lastlink_ = false;
}

TMShardInfo::~TMShardInfo() {
  // @@protoc_insertion_point(destructor:protocol.TMShardInfo)
  SharedDtor();
}

void TMShardInfo::SharedDtor() {
  shardindexes_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  endpoint_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMShardInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMShardInfo& TMShardInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMShardInfo_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMShardInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  peerchain_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      shardindexes_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      nodepubkey_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      endpoint_.ClearNonDefaultToEmptyNoArena();
    }
  }
  lastlink_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMShardInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string shardIndexes = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_shardindexes(), ptr, ctx, "protocol.TMShardInfo.shardIndexes");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes nodePubKey = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_nodepubkey(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string endpoint = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_endpoint(), ptr, ctx, "protocol.TMShardInfo.endpoint");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool lastLink = 4 [deprecated = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_lastlink(&has_bits);
          lastlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 peerchain = 5 [deprecated = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_peerchain(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 40);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(mutable_peerchain(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMShardInfo::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMShardInfo)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string shardIndexes = 1 [deprecated = true];
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_shardindexes()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->shardindexes().data(), static_cast<int>(this->shardindexes().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "protocol.TMShardInfo.shardIndexes");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes nodePubKey = 2 [deprecated = true];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodepubkey()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string endpoint = 3 [deprecated = true];
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_endpoint()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->endpoint().data(), static_cast<int>(this->endpoint().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "protocol.TMShardInfo.endpoint");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool lastLink = 4 [deprecated = true];
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_lastlink(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &lastlink_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint32 peerchain = 5 [deprecated = true];
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 1, 40u, input, this->mutable_peerchain())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_peerchain())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMShardInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMShardInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMShardInfo::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string shardIndexes = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->shardindexes().data(), static_cast<int>(this->shardindexes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMShardInfo.shardIndexes");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->shardindexes(), output);
  }

  // optional bytes nodePubKey = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->nodepubkey(), output);
  }

  // optional string endpoint = 3 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->endpoint().data(), static_cast<int>(this->endpoint().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMShardInfo.endpoint");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->endpoint(), output);
  }

  // optional bool lastLink = 4 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(4, this->lastlink(), output);
  }

  // repeated uint32 peerchain = 5 [deprecated = true];
  for (int i = 0, n = this->peerchain_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(
      5, this->peerchain(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMShardInfo)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMShardInfo::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string shardIndexes = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->shardindexes().data(), static_cast<int>(this->shardindexes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMShardInfo.shardIndexes");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        1, this->shardindexes(), target);
  }

  // optional bytes nodePubKey = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->nodepubkey(), target);
  }

  // optional string endpoint = 3 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->endpoint().data(), static_cast<int>(this->endpoint().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMShardInfo.endpoint");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        3, this->endpoint(), target);
  }

  // optional bool lastLink = 4 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->lastlink(), target);
  }

  // repeated uint32 peerchain = 5 [deprecated = true];
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteUInt32ToArray(5, this->peerchain_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMShardInfo)
  return target;
}

size_t TMShardInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMShardInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required string shardIndexes = 1 [deprecated = true];
  if (has_shardindexes()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->shardindexes());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 peerchain = 5 [deprecated = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->peerchain_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->peerchain_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional bytes nodePubKey = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->nodepubkey());
    }

    // optional string endpoint = 3 [deprecated = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->endpoint());
    }

    // optional bool lastLink = 4 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMShardInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const TMShardInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMShardInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMShardInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMShardInfo)
    MergeFrom(*source);
  }
}

void TMShardInfo::MergeFrom(const TMShardInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  peerchain_.MergeFrom(from.peerchain_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      shardindexes_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.shardindexes_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      nodepubkey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nodepubkey_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      endpoint_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.endpoint_);
    }
    if (cached_has_bits & 0x00000008u) {
      lastlink_ = from.lastlink_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMShardInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMShardInfo::CopyFrom(const TMShardInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMShardInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void TMShardInfo::Swap(TMShardInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMShardInfo::InternalSwap(TMShardInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  peerchain_.InternalSwap(&other->peerchain_);
  shardindexes_.Swap(&other->shardindexes_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  nodepubkey_.Swap(&other->nodepubkey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  endpoint_.Swap(&other->endpoint_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(lastlink_, other->lastlink_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMShardInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMLink::InitAsDefaultInstance() {
}
class TMLink::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMLink>()._has_bits_);
  static void set_has_nodepubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMLink::kNodePubKeyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMLink::TMLink()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMLink)
}
TMLink::TMLink(const TMLink& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_nodepubkey()) {
    nodepubkey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nodepubkey_);
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMLink)
}

void TMLink::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMLink_ripple_2eproto.base);
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

TMLink::~TMLink() {
  // @@protoc_insertion_point(destructor:protocol.TMLink)
  SharedDtor();
}

void TMLink::SharedDtor() {
  nodepubkey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMLink::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMLink& TMLink::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMLink_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMLink::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLink)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    nodepubkey_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMLink::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes nodePubKey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_nodepubkey(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMLink::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMLink)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes nodePubKey = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodepubkey()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMLink)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMLink)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMLink::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMLink)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes nodePubKey = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->nodepubkey(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMLink)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMLink::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLink)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes nodePubKey = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->nodepubkey(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLink)
  return target;
}

size_t TMLink::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLink)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required bytes nodePubKey = 1;
  if (has_nodepubkey()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->nodepubkey());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMLink::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMLink)
  GOOGLE_DCHECK_NE(&from, this);
  const TMLink* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMLink>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMLink)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMLink)
    MergeFrom(*source);
  }
}

void TMLink::MergeFrom(const TMLink& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLink)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_nodepubkey()) {
    _has_bits_[0] |= 0x00000001u;
    nodepubkey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nodepubkey_);
  }
}

void TMLink::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMLink)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLink::CopyFrom(const TMLink& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLink)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLink::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void TMLink::Swap(TMLink* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMLink::InternalSwap(TMLink* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  nodepubkey_.Swap(&other->nodepubkey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata TMLink::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMGetPeerShardInfo::InitAsDefaultInstance() {
}
class TMGetPeerShardInfo::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMGetPeerShardInfo>()._has_bits_);
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lastlink(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMGetPeerShardInfo::kHopsFieldNumber;
const int TMGetPeerShardInfo::kLastLinkFieldNumber;
const int TMGetPeerShardInfo::kPeerChainFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMGetPeerShardInfo::TMGetPeerShardInfo()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMGetPeerShardInfo)
}
TMGetPeerShardInfo::TMGetPeerShardInfo(const TMGetPeerShardInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      peerchain_(from.peerchain_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&hops_, &from.hops_,
    static_cast<size_t>(reinterpret_cast<char*>(&lastlink_) -
    reinterpret_cast<char*>(&hops_)) + sizeof(lastlink_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetPeerShardInfo)
}

void TMGetPeerShardInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMGetPeerShardInfo_ripple_2eproto.base);
  ::memset(&hops_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lastlink_) -
      reinterpret_cast<char*>(&hops_)) + sizeof(lastlink_));
}

TMGetPeerShardInfo::~TMGetPeerShardInfo() {
  // @@protoc_insertion_point(destructor:protocol.TMGetPeerShardInfo)
  SharedDtor();
}

void TMGetPeerShardInfo::SharedDtor() {
}

void TMGetPeerShardInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMGetPeerShardInfo& TMGetPeerShardInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMGetPeerShardInfo_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMGetPeerShardInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetPeerShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  peerchain_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&hops_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lastlink_) -
        reinterpret_cast<char*>(&hops_)) + sizeof(lastlink_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMGetPeerShardInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 hops = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_hops(&has_bits);
          hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool lastLink = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_lastlink(&has_bits);
          lastlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMLink peerChain = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_peerchain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 26);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMGetPeerShardInfo::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMGetPeerShardInfo)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 hops = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_hops(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hops_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool lastLink = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_lastlink(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &lastlink_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .protocol.TMLink peerChain = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_peerchain()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMGetPeerShardInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMGetPeerShardInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMGetPeerShardInfo::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMGetPeerShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 hops = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->hops(), output);
  }

  // optional bool lastLink = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->lastlink(), output);
  }

  // repeated .protocol.TMLink peerChain = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->peerchain_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3,
      this->peerchain(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMGetPeerShardInfo)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMGetPeerShardInfo::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetPeerShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 hops = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->hops(), target);
  }

  // optional bool lastLink = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->lastlink(), target);
  }

  // repeated .protocol.TMLink peerChain = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->peerchain_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->peerchain(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetPeerShardInfo)
  return target;
}

size_t TMGetPeerShardInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetPeerShardInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required uint32 hops = 1;
  if (has_hops()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->hops());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMLink peerChain = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->peerchain_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->peerchain(static_cast<int>(i)));
    }
  }

  // optional bool lastLink = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMGetPeerShardInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMGetPeerShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const TMGetPeerShardInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMGetPeerShardInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMGetPeerShardInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMGetPeerShardInfo)
    MergeFrom(*source);
  }
}

void TMGetPeerShardInfo::MergeFrom(const TMGetPeerShardInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetPeerShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  peerchain_.MergeFrom(from.peerchain_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hops_ = from.hops_;
    }
    if (cached_has_bits & 0x00000002u) {
      lastlink_ = from.lastlink_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMGetPeerShardInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMGetPeerShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetPeerShardInfo::CopyFrom(const TMGetPeerShardInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetPeerShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetPeerShardInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->peerchain())) return false;
  return true;
}

void TMGetPeerShardInfo::Swap(TMGetPeerShardInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMGetPeerShardInfo::InternalSwap(TMGetPeerShardInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&peerchain_)->InternalSwap(CastToBase(&other->peerchain_));
  swap(hops_, other->hops_);
  swap(lastlink_, other->lastlink_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMGetPeerShardInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMPeerShardInfo::InitAsDefaultInstance() {
}
class TMPeerShardInfo::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMPeerShardInfo>()._has_bits_);
  static void set_has_shardindexes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodepubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_endpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lastlink(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMPeerShardInfo::kShardIndexesFieldNumber;
const int TMPeerShardInfo::kNodePubKeyFieldNumber;
const int TMPeerShardInfo::kEndpointFieldNumber;
const int TMPeerShardInfo::kLastLinkFieldNumber;
const int TMPeerShardInfo::kPeerChainFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMPeerShardInfo::TMPeerShardInfo()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMPeerShardInfo)
}
TMPeerShardInfo::TMPeerShardInfo(const TMPeerShardInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      peerchain_(from.peerchain_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  shardindexes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_shardindexes()) {
    shardindexes_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.shardindexes_);
  }
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_nodepubkey()) {
    nodepubkey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nodepubkey_);
  }
  endpoint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_endpoint()) {
    endpoint_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.endpoint_);
  }
  lastlink_ = from.lastlink_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMPeerShardInfo)
}

void TMPeerShardInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMPeerShardInfo_ripple_2eproto.base);
  shardindexes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  endpoint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  lastlink_ = false;
}

TMPeerShardInfo::~TMPeerShardInfo() {
  // @@protoc_insertion_point(destructor:protocol.TMPeerShardInfo)
  SharedDtor();
}

void TMPeerShardInfo::SharedDtor() {
  shardindexes_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  endpoint_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMPeerShardInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMPeerShardInfo& TMPeerShardInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMPeerShardInfo_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMPeerShardInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMPeerShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  peerchain_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      shardindexes_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      nodepubkey_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      endpoint_.ClearNonDefaultToEmptyNoArena();
    }
  }
  lastlink_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMPeerShardInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string shardIndexes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_shardindexes(), ptr, ctx, "protocol.TMPeerShardInfo.shardIndexes");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes nodePubKey = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_nodepubkey(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string endpoint = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_endpoint(), ptr, ctx, "protocol.TMPeerShardInfo.endpoint");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool lastLink = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_lastlink(&has_bits);
          lastlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMLink peerChain = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_peerchain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMPeerShardInfo::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMPeerShardInfo)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string shardIndexes = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_shardindexes()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->shardindexes().data(), static_cast<int>(this->shardindexes().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "protocol.TMPeerShardInfo.shardIndexes");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes nodePubKey = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodepubkey()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string endpoint = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_endpoint()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->endpoint().data(), static_cast<int>(this->endpoint().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "protocol.TMPeerShardInfo.endpoint");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool lastLink = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_lastlink(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &lastlink_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .protocol.TMLink peerChain = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_peerchain()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMPeerShardInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMPeerShardInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMPeerShardInfo::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMPeerShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string shardIndexes = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->shardindexes().data(), static_cast<int>(this->shardindexes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMPeerShardInfo.shardIndexes");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->shardindexes(), output);
  }

  // optional bytes nodePubKey = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->nodepubkey(), output);
  }

  // optional string endpoint = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->endpoint().data(), static_cast<int>(this->endpoint().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMPeerShardInfo.endpoint");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->endpoint(), output);
  }

  // optional bool lastLink = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(4, this->lastlink(), output);
  }

  // repeated .protocol.TMLink peerChain = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->peerchain_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      5,
      this->peerchain(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMPeerShardInfo)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMPeerShardInfo::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMPeerShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string shardIndexes = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->shardindexes().data(), static_cast<int>(this->shardindexes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMPeerShardInfo.shardIndexes");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        1, this->shardindexes(), target);
  }

  // optional bytes nodePubKey = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->nodepubkey(), target);
  }

  // optional string endpoint = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->endpoint().data(), static_cast<int>(this->endpoint().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMPeerShardInfo.endpoint");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        3, this->endpoint(), target);
  }

  // optional bool lastLink = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->lastlink(), target);
  }

  // repeated .protocol.TMLink peerChain = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->peerchain_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->peerchain(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMPeerShardInfo)
  return target;
}

size_t TMPeerShardInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMPeerShardInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required string shardIndexes = 1;
  if (has_shardindexes()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->shardindexes());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMLink peerChain = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->peerchain_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->peerchain(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional bytes nodePubKey = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->nodepubkey());
    }

    // optional string endpoint = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->endpoint());
    }

    // optional bool lastLink = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMPeerShardInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMPeerShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const TMPeerShardInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMPeerShardInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMPeerShardInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMPeerShardInfo)
    MergeFrom(*source);
  }
}

void TMPeerShardInfo::MergeFrom(const TMPeerShardInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMPeerShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  peerchain_.MergeFrom(from.peerchain_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      shardindexes_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.shardindexes_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      nodepubkey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nodepubkey_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      endpoint_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.endpoint_);
    }
    if (cached_has_bits & 0x00000008u) {
      lastlink_ = from.lastlink_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMPeerShardInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMPeerShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMPeerShardInfo::CopyFrom(const TMPeerShardInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMPeerShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPeerShardInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->peerchain())) return false;
  return true;
}

void TMPeerShardInfo::Swap(TMPeerShardInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMPeerShardInfo::InternalSwap(TMPeerShardInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&peerchain_)->InternalSwap(CastToBase(&other->peerchain_));
  shardindexes_.Swap(&other->shardindexes_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  nodepubkey_.Swap(&other->nodepubkey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  endpoint_.Swap(&other->endpoint_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(lastlink_, other->lastlink_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMPeerShardInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMTransaction::InitAsDefaultInstance() {
}
class TMTransaction::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMTransaction>()._has_bits_);
  static void set_has_rawtransaction(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_receivetimestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_deferred(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMTransaction::kRawTransactionFieldNumber;
const int TMTransaction::kStatusFieldNumber;
const int TMTransaction::kReceiveTimestampFieldNumber;
const int TMTransaction::kDeferredFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMTransaction::TMTransaction()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMTransaction)
}
TMTransaction::TMTransaction(const TMTransaction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  rawtransaction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_rawtransaction()) {
    rawtransaction_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.rawtransaction_);
  }
  ::memcpy(&receivetimestamp_, &from.receivetimestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&receivetimestamp_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMTransaction)
}

void TMTransaction::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMTransaction_ripple_2eproto.base);
  rawtransaction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&receivetimestamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&deferred_) -
      reinterpret_cast<char*>(&receivetimestamp_)) + sizeof(deferred_));
  status_ = 1;
}

TMTransaction::~TMTransaction() {
  // @@protoc_insertion_point(destructor:protocol.TMTransaction)
  SharedDtor();
}

void TMTransaction::SharedDtor() {
  rawtransaction_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMTransaction::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMTransaction& TMTransaction::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMTransaction_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMTransaction::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMTransaction)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    rawtransaction_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&receivetimestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&deferred_) -
        reinterpret_cast<char*>(&receivetimestamp_)) + sizeof(deferred_));
    status_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMTransaction::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes rawTransaction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_rawtransaction(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .protocol.TransactionStatus status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TransactionStatus_IsValid(val))) {
            set_status(static_cast<::protocol::TransactionStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint64 receiveTimestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_receivetimestamp(&has_bits);
          receivetimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool deferred = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_deferred(&has_bits);
          deferred_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMTransaction::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMTransaction)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes rawTransaction = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_rawtransaction()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .protocol.TransactionStatus status = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TransactionStatus_IsValid(value)) {
            set_status(static_cast< ::protocol::TransactionStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 receiveTimestamp = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_receivetimestamp(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &receivetimestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool deferred = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_deferred(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &deferred_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMTransaction)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMTransaction)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMTransaction::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMTransaction)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes rawTransaction = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->rawtransaction(), output);
  }

  // required .protocol.TransactionStatus status = 2;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // optional uint64 receiveTimestamp = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->receivetimestamp(), output);
  }

  // optional bool deferred = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(4, this->deferred(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMTransaction)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMTransaction::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMTransaction)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes rawTransaction = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->rawtransaction(), target);
  }

  // required .protocol.TransactionStatus status = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->status(), target);
  }

  // optional uint64 receiveTimestamp = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->receivetimestamp(), target);
  }

  // optional bool deferred = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->deferred(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMTransaction)
  return target;
}

size_t TMTransaction::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMTransaction)
  size_t total_size = 0;

  if (has_rawtransaction()) {
    // required bytes rawTransaction = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->rawtransaction());
  }

  if (has_status()) {
    // required .protocol.TransactionStatus status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->status());
  }

  return total_size;
}
size_t TMTransaction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMTransaction)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000009) ^ 0x00000009) == 0) {  // All required fields are present.
    // required bytes rawTransaction = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->rawtransaction());

    // required .protocol.TransactionStatus status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint64 receiveTimestamp = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->receivetimestamp());
    }

    // optional bool deferred = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMTransaction::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMTransaction)
  GOOGLE_DCHECK_NE(&from, this);
  const TMTransaction* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMTransaction>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMTransaction)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMTransaction)
    MergeFrom(*source);
  }
}

void TMTransaction::MergeFrom(const TMTransaction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMTransaction)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      rawtransaction_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.rawtransaction_);
    }
    if (cached_has_bits & 0x00000002u) {
      receivetimestamp_ = from.receivetimestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      deferred_ = from.deferred_;
    }
    if (cached_has_bits & 0x00000008u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMTransaction::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMTransaction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMTransaction::CopyFrom(const TMTransaction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMTransaction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMTransaction::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;
  return true;
}

void TMTransaction::Swap(TMTransaction* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMTransaction::InternalSwap(TMTransaction* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  rawtransaction_.Swap(&other->rawtransaction_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(receivetimestamp_, other->receivetimestamp_);
  swap(deferred_, other->deferred_);
  swap(status_, other->status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMTransaction::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMStatusChange::InitAsDefaultInstance() {
}
class TMStatusChange::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMStatusChange>()._has_bits_);
  static void set_has_newstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_newevent(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerhashprevious(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_networktime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_firstseq(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lastseq(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMStatusChange::kNewStatusFieldNumber;
const int TMStatusChange::kNewEventFieldNumber;
const int TMStatusChange::kLedgerSeqFieldNumber;
const int TMStatusChange::kLedgerHashFieldNumber;
const int TMStatusChange::kLedgerHashPreviousFieldNumber;
const int TMStatusChange::kNetworkTimeFieldNumber;
const int TMStatusChange::kFirstSeqFieldNumber;
const int TMStatusChange::kLastSeqFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMStatusChange::TMStatusChange()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMStatusChange)
}
TMStatusChange::TMStatusChange(const TMStatusChange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerhash()) {
    ledgerhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
  }
  ledgerhashprevious_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerhashprevious()) {
    ledgerhashprevious_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhashprevious_);
  }
  ::memcpy(&ledgerseq_, &from.ledgerseq_,
    static_cast<size_t>(reinterpret_cast<char*>(&newevent_) -
    reinterpret_cast<char*>(&ledgerseq_)) + sizeof(newevent_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMStatusChange)
}

void TMStatusChange::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMStatusChange_ripple_2eproto.base);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerhashprevious_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&ledgerseq_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lastseq_) -
      reinterpret_cast<char*>(&ledgerseq_)) + sizeof(lastseq_));
  newstatus_ = 1;
  newevent_ = 1;
}

TMStatusChange::~TMStatusChange() {
  // @@protoc_insertion_point(destructor:protocol.TMStatusChange)
  SharedDtor();
}

void TMStatusChange::SharedDtor() {
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerhashprevious_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMStatusChange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMStatusChange& TMStatusChange::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMStatusChange_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMStatusChange::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMStatusChange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ledgerhash_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      ledgerhashprevious_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&ledgerseq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lastseq_) -
        reinterpret_cast<char*>(&ledgerseq_)) + sizeof(lastseq_));
    newstatus_ = 1;
    newevent_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMStatusChange::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .protocol.NodeStatus newStatus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::NodeStatus_IsValid(val))) {
            set_newstatus(static_cast<::protocol::NodeStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .protocol.NodeEvent newEvent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::NodeEvent_IsValid(val))) {
            set_newevent(static_cast<::protocol::NodeEvent>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 ledgerSeq = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_ledgerseq(&has_bits);
          ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes ledgerHash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_ledgerhash(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes ledgerHashPrevious = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_ledgerhashprevious(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 networkTime = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          HasBitSetters::set_has_networktime(&has_bits);
          networktime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 firstSeq = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          HasBitSetters::set_has_firstseq(&has_bits);
          firstseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lastSeq = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          HasBitSetters::set_has_lastseq(&has_bits);
          lastseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMStatusChange::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMStatusChange)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .protocol.NodeStatus newStatus = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::NodeStatus_IsValid(value)) {
            set_newstatus(static_cast< ::protocol::NodeStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .protocol.NodeEvent newEvent = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::NodeEvent_IsValid(value)) {
            set_newevent(static_cast< ::protocol::NodeEvent >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 ledgerSeq = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_ledgerseq(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ledgerseq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes ledgerHash = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes ledgerHashPrevious = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhashprevious()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 networkTime = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_networktime(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &networktime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 firstSeq = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_firstseq(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &firstseq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lastSeq = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_lastseq(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lastseq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMStatusChange)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMStatusChange)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMStatusChange::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMStatusChange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .protocol.NodeStatus newStatus = 1;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->newstatus(), output);
  }

  // optional .protocol.NodeEvent newEvent = 2;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->newevent(), output);
  }

  // optional uint32 ledgerSeq = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->ledgerseq(), output);
  }

  // optional bytes ledgerHash = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->ledgerhash(), output);
  }

  // optional bytes ledgerHashPrevious = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->ledgerhashprevious(), output);
  }

  // optional uint64 networkTime = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(6, this->networktime(), output);
  }

  // optional uint32 firstSeq = 7;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->firstseq(), output);
  }

  // optional uint32 lastSeq = 8;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(8, this->lastseq(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMStatusChange)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMStatusChange::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMStatusChange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .protocol.NodeStatus newStatus = 1;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->newstatus(), target);
  }

  // optional .protocol.NodeEvent newEvent = 2;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->newevent(), target);
  }

  // optional uint32 ledgerSeq = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->ledgerseq(), target);
  }

  // optional bytes ledgerHash = 4;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        4, this->ledgerhash(), target);
  }

  // optional bytes ledgerHashPrevious = 5;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        5, this->ledgerhashprevious(), target);
  }

  // optional uint64 networkTime = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->networktime(), target);
  }

  // optional uint32 firstSeq = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->firstseq(), target);
  }

  // optional uint32 lastSeq = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->lastseq(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMStatusChange)
  return target;
}

size_t TMStatusChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMStatusChange)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes ledgerHash = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->ledgerhash());
    }

    // optional bytes ledgerHashPrevious = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->ledgerhashprevious());
    }

    // optional uint32 ledgerSeq = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->ledgerseq());
    }

    // optional uint32 firstSeq = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->firstseq());
    }

    // optional uint64 networkTime = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->networktime());
    }

    // optional uint32 lastSeq = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lastseq());
    }

    // optional .protocol.NodeStatus newStatus = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->newstatus());
    }

    // optional .protocol.NodeEvent newEvent = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->newevent());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMStatusChange::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMStatusChange)
  GOOGLE_DCHECK_NE(&from, this);
  const TMStatusChange* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMStatusChange>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMStatusChange)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMStatusChange)
    MergeFrom(*source);
  }
}

void TMStatusChange::MergeFrom(const TMStatusChange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMStatusChange)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      ledgerhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      ledgerhashprevious_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhashprevious_);
    }
    if (cached_has_bits & 0x00000004u) {
      ledgerseq_ = from.ledgerseq_;
    }
    if (cached_has_bits & 0x00000008u) {
      firstseq_ = from.firstseq_;
    }
    if (cached_has_bits & 0x00000010u) {
      networktime_ = from.networktime_;
    }
    if (cached_has_bits & 0x00000020u) {
      lastseq_ = from.lastseq_;
    }
    if (cached_has_bits & 0x00000040u) {
      newstatus_ = from.newstatus_;
    }
    if (cached_has_bits & 0x00000080u) {
      newevent_ = from.newevent_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMStatusChange::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMStatusChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMStatusChange::CopyFrom(const TMStatusChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMStatusChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMStatusChange::IsInitialized() const {
  return true;
}

void TMStatusChange::Swap(TMStatusChange* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMStatusChange::InternalSwap(TMStatusChange* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  ledgerhashprevious_.Swap(&other->ledgerhashprevious_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(ledgerseq_, other->ledgerseq_);
  swap(firstseq_, other->firstseq_);
  swap(networktime_, other->networktime_);
  swap(lastseq_, other->lastseq_);
  swap(newstatus_, other->newstatus_);
  swap(newevent_, other->newevent_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMStatusChange::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMProposeSet::InitAsDefaultInstance() {
}
class TMProposeSet::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMProposeSet>()._has_bits_);
  static void set_has_proposeseq(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_currenttxhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodepubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_closetime(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_previousledger(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_checkedsignature(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMProposeSet::kProposeSeqFieldNumber;
const int TMProposeSet::kCurrentTxHashFieldNumber;
const int TMProposeSet::kNodePubKeyFieldNumber;
const int TMProposeSet::kCloseTimeFieldNumber;
const int TMProposeSet::kSignatureFieldNumber;
const int TMProposeSet::kPreviousledgerFieldNumber;
const int TMProposeSet::kAddedTransactionsFieldNumber;
const int TMProposeSet::kRemovedTransactionsFieldNumber;
const int TMProposeSet::kCheckedSignatureFieldNumber;
const int TMProposeSet::kHopsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMProposeSet::TMProposeSet()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMProposeSet)
}
TMProposeSet::TMProposeSet(const TMProposeSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      addedtransactions_(from.addedtransactions_),
      removedtransactions_(from.removedtransactions_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  currenttxhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_currenttxhash()) {
    currenttxhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.currenttxhash_);
  }
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_nodepubkey()) {
    nodepubkey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nodepubkey_);
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature()) {
    signature_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  previousledger_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_previousledger()) {
    previousledger_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.previousledger_);
  }
  ::memcpy(&proposeseq_, &from.proposeseq_,
    static_cast<size_t>(reinterpret_cast<char*>(&hops_) -
    reinterpret_cast<char*>(&proposeseq_)) + sizeof(hops_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMProposeSet)
}

void TMProposeSet::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMProposeSet_ripple_2eproto.base);
  currenttxhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  previousledger_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&proposeseq_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hops_) -
      reinterpret_cast<char*>(&proposeseq_)) + sizeof(hops_));
}

TMProposeSet::~TMProposeSet() {
  // @@protoc_insertion_point(destructor:protocol.TMProposeSet)
  SharedDtor();
}

void TMProposeSet::SharedDtor() {
  currenttxhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  previousledger_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMProposeSet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMProposeSet& TMProposeSet::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMProposeSet_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMProposeSet::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMProposeSet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  addedtransactions_.Clear();
  removedtransactions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      currenttxhash_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      nodepubkey_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      signature_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      previousledger_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&proposeseq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&hops_) -
        reinterpret_cast<char*>(&proposeseq_)) + sizeof(hops_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMProposeSet::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 proposeSeq = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_proposeseq(&has_bits);
          proposeseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes currentTxHash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_currenttxhash(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes nodePubKey = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_nodepubkey(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 closeTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_closetime(&has_bits);
          closetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_signature(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes previousledger = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_previousledger(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool checkedSignature = 7 [deprecated = true];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          HasBitSetters::set_has_checkedsignature(&has_bits);
          checkedsignature_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bytes addedTransactions = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(add_addedtransactions(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 82);
        } else goto handle_unusual;
        continue;
      // repeated bytes removedTransactions = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(add_removedtransactions(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 90);
        } else goto handle_unusual;
        continue;
      // optional uint32 hops = 12 [deprecated = true];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          HasBitSetters::set_has_hops(&has_bits);
          hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMProposeSet::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMProposeSet)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 proposeSeq = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_proposeseq(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &proposeseq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes currentTxHash = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_currenttxhash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes nodePubKey = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodepubkey()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 closeTime = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_closetime(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &closetime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes signature = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes previousledger = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_previousledger()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool checkedSignature = 7 [deprecated = true];
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_checkedsignature(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &checkedsignature_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated bytes addedTransactions = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (82 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->add_addedtransactions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated bytes removedTransactions = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (90 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->add_removedtransactions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 hops = 12 [deprecated = true];
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_hops(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hops_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMProposeSet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMProposeSet)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMProposeSet::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMProposeSet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 proposeSeq = 1;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->proposeseq(), output);
  }

  // required bytes currentTxHash = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->currenttxhash(), output);
  }

  // required bytes nodePubKey = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->nodepubkey(), output);
  }

  // required uint32 closeTime = 4;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->closetime(), output);
  }

  // required bytes signature = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->signature(), output);
  }

  // required bytes previousledger = 6;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->previousledger(), output);
  }

  // optional bool checkedSignature = 7 [deprecated = true];
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(7, this->checkedsignature(), output);
  }

  // repeated bytes addedTransactions = 10;
  for (int i = 0, n = this->addedtransactions_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytes(
      10, this->addedtransactions(i), output);
  }

  // repeated bytes removedTransactions = 11;
  for (int i = 0, n = this->removedtransactions_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytes(
      11, this->removedtransactions(i), output);
  }

  // optional uint32 hops = 12 [deprecated = true];
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(12, this->hops(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMProposeSet)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMProposeSet::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMProposeSet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 proposeSeq = 1;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->proposeseq(), target);
  }

  // required bytes currentTxHash = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->currenttxhash(), target);
  }

  // required bytes nodePubKey = 3;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        3, this->nodepubkey(), target);
  }

  // required uint32 closeTime = 4;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->closetime(), target);
  }

  // required bytes signature = 5;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        5, this->signature(), target);
  }

  // required bytes previousledger = 6;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        6, this->previousledger(), target);
  }

  // optional bool checkedSignature = 7 [deprecated = true];
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->checkedsignature(), target);
  }

  // repeated bytes addedTransactions = 10;
  for (int i = 0, n = this->addedtransactions_size(); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      WriteBytesToArray(10, this->addedtransactions(i), target);
  }

  // repeated bytes removedTransactions = 11;
  for (int i = 0, n = this->removedtransactions_size(); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      WriteBytesToArray(11, this->removedtransactions(i), target);
  }

  // optional uint32 hops = 12 [deprecated = true];
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->hops(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMProposeSet)
  return target;
}

size_t TMProposeSet::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMProposeSet)
  size_t total_size = 0;

  if (has_currenttxhash()) {
    // required bytes currentTxHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->currenttxhash());
  }

  if (has_nodepubkey()) {
    // required bytes nodePubKey = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->nodepubkey());
  }

  if (has_signature()) {
    // required bytes signature = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->signature());
  }

  if (has_previousledger()) {
    // required bytes previousledger = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->previousledger());
  }

  if (has_proposeseq()) {
    // required uint32 proposeSeq = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->proposeseq());
  }

  if (has_closetime()) {
    // required uint32 closeTime = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->closetime());
  }

  return total_size;
}
size_t TMProposeSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMProposeSet)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required bytes currentTxHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->currenttxhash());

    // required bytes nodePubKey = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->nodepubkey());

    // required bytes signature = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->signature());

    // required bytes previousledger = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->previousledger());

    // required uint32 proposeSeq = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->proposeseq());

    // required uint32 closeTime = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->closetime());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes addedTransactions = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->addedtransactions_size());
  for (int i = 0, n = this->addedtransactions_size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      this->addedtransactions(i));
  }

  // repeated bytes removedTransactions = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->removedtransactions_size());
  for (int i = 0, n = this->removedtransactions_size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      this->removedtransactions(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000c0u) {
    // optional bool checkedSignature = 7 [deprecated = true];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional uint32 hops = 12 [deprecated = true];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->hops());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMProposeSet::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMProposeSet)
  GOOGLE_DCHECK_NE(&from, this);
  const TMProposeSet* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMProposeSet>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMProposeSet)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMProposeSet)
    MergeFrom(*source);
  }
}

void TMProposeSet::MergeFrom(const TMProposeSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMProposeSet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  addedtransactions_.MergeFrom(from.addedtransactions_);
  removedtransactions_.MergeFrom(from.removedtransactions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      currenttxhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.currenttxhash_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      nodepubkey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nodepubkey_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      signature_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      previousledger_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.previousledger_);
    }
    if (cached_has_bits & 0x00000010u) {
      proposeseq_ = from.proposeseq_;
    }
    if (cached_has_bits & 0x00000020u) {
      closetime_ = from.closetime_;
    }
    if (cached_has_bits & 0x00000040u) {
      checkedsignature_ = from.checkedsignature_;
    }
    if (cached_has_bits & 0x00000080u) {
      hops_ = from.hops_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMProposeSet::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMProposeSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMProposeSet::CopyFrom(const TMProposeSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMProposeSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMProposeSet::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  return true;
}

void TMProposeSet::Swap(TMProposeSet* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMProposeSet::InternalSwap(TMProposeSet* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  addedtransactions_.InternalSwap(CastToBase(&other->addedtransactions_));
  removedtransactions_.InternalSwap(CastToBase(&other->removedtransactions_));
  currenttxhash_.Swap(&other->currenttxhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  nodepubkey_.Swap(&other->nodepubkey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  signature_.Swap(&other->signature_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  previousledger_.Swap(&other->previousledger_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(proposeseq_, other->proposeseq_);
  swap(closetime_, other->closetime_);
  swap(checkedsignature_, other->checkedsignature_);
  swap(hops_, other->hops_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMProposeSet::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMHaveTransactionSet::InitAsDefaultInstance() {
}
class TMHaveTransactionSet::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMHaveTransactionSet>()._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMHaveTransactionSet::kStatusFieldNumber;
const int TMHaveTransactionSet::kHashFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMHaveTransactionSet::TMHaveTransactionSet()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMHaveTransactionSet)
}
TMHaveTransactionSet::TMHaveTransactionSet(const TMHaveTransactionSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_hash()) {
    hash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hash_);
  }
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMHaveTransactionSet)
}

void TMHaveTransactionSet::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMHaveTransactionSet_ripple_2eproto.base);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  status_ = 1;
}

TMHaveTransactionSet::~TMHaveTransactionSet() {
  // @@protoc_insertion_point(destructor:protocol.TMHaveTransactionSet)
  SharedDtor();
}

void TMHaveTransactionSet::SharedDtor() {
  hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMHaveTransactionSet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMHaveTransactionSet& TMHaveTransactionSet::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMHaveTransactionSet_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMHaveTransactionSet::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMHaveTransactionSet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hash_.ClearNonDefaultToEmptyNoArena();
    }
    status_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMHaveTransactionSet::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .protocol.TxSetStatus status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TxSetStatus_IsValid(val))) {
            set_status(static_cast<::protocol::TxSetStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required bytes hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_hash(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMHaveTransactionSet::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMHaveTransactionSet)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .protocol.TxSetStatus status = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TxSetStatus_IsValid(value)) {
            set_status(static_cast< ::protocol::TxSetStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes hash = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMHaveTransactionSet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMHaveTransactionSet)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMHaveTransactionSet::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMHaveTransactionSet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TxSetStatus status = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->status(), output);
  }

  // required bytes hash = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->hash(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMHaveTransactionSet)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMHaveTransactionSet::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMHaveTransactionSet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TxSetStatus status = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->status(), target);
  }

  // required bytes hash = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->hash(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMHaveTransactionSet)
  return target;
}

size_t TMHaveTransactionSet::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMHaveTransactionSet)
  size_t total_size = 0;

  if (has_hash()) {
    // required bytes hash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->hash());
  }

  if (has_status()) {
    // required .protocol.TxSetStatus status = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->status());
  }

  return total_size;
}
size_t TMHaveTransactionSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMHaveTransactionSet)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes hash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->hash());

    // required .protocol.TxSetStatus status = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMHaveTransactionSet::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMHaveTransactionSet)
  GOOGLE_DCHECK_NE(&from, this);
  const TMHaveTransactionSet* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMHaveTransactionSet>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMHaveTransactionSet)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMHaveTransactionSet)
    MergeFrom(*source);
  }
}

void TMHaveTransactionSet::MergeFrom(const TMHaveTransactionSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMHaveTransactionSet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      hash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hash_);
    }
    if (cached_has_bits & 0x00000002u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMHaveTransactionSet::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMHaveTransactionSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMHaveTransactionSet::CopyFrom(const TMHaveTransactionSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMHaveTransactionSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMHaveTransactionSet::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void TMHaveTransactionSet::Swap(TMHaveTransactionSet* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMHaveTransactionSet::InternalSwap(TMHaveTransactionSet* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  hash_.Swap(&other->hash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(status_, other->status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMHaveTransactionSet::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMValidatorList::InitAsDefaultInstance() {
}
class TMValidatorList::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMValidatorList>()._has_bits_);
  static void set_has_manifest(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_blob(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMValidatorList::kManifestFieldNumber;
const int TMValidatorList::kBlobFieldNumber;
const int TMValidatorList::kSignatureFieldNumber;
const int TMValidatorList::kVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMValidatorList::TMValidatorList()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMValidatorList)
}
TMValidatorList::TMValidatorList(const TMValidatorList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  manifest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_manifest()) {
    manifest_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manifest_);
  }
  blob_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_blob()) {
    blob_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.blob_);
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature()) {
    signature_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  version_ = from.version_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMValidatorList)
}

void TMValidatorList::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMValidatorList_ripple_2eproto.base);
  manifest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  blob_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_ = 0u;
}

TMValidatorList::~TMValidatorList() {
  // @@protoc_insertion_point(destructor:protocol.TMValidatorList)
  SharedDtor();
}

void TMValidatorList::SharedDtor() {
  manifest_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  blob_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMValidatorList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMValidatorList& TMValidatorList::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMValidatorList_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMValidatorList::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMValidatorList)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      manifest_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      blob_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      signature_.ClearNonDefaultToEmptyNoArena();
    }
  }
  version_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMValidatorList::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes manifest = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_manifest(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes blob = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_blob(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes signature = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_signature(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMValidatorList::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMValidatorList)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes manifest = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_manifest()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes blob = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_blob()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes signature = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 version = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_version(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMValidatorList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMValidatorList)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMValidatorList::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMValidatorList)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes manifest = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->manifest(), output);
  }

  // required bytes blob = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->blob(), output);
  }

  // required bytes signature = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->signature(), output);
  }

  // required uint32 version = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->version(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMValidatorList)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMValidatorList::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMValidatorList)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes manifest = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->manifest(), target);
  }

  // required bytes blob = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->blob(), target);
  }

  // required bytes signature = 3;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        3, this->signature(), target);
  }

  // required uint32 version = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->version(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMValidatorList)
  return target;
}

size_t TMValidatorList::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMValidatorList)
  size_t total_size = 0;

  if (has_manifest()) {
    // required bytes manifest = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->manifest());
  }

  if (has_blob()) {
    // required bytes blob = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->blob());
  }

  if (has_signature()) {
    // required bytes signature = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->signature());
  }

  if (has_version()) {
    // required uint32 version = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->version());
  }

  return total_size;
}
size_t TMValidatorList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMValidatorList)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required bytes manifest = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->manifest());

    // required bytes blob = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->blob());

    // required bytes signature = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->signature());

    // required uint32 version = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->version());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMValidatorList::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMValidatorList)
  GOOGLE_DCHECK_NE(&from, this);
  const TMValidatorList* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMValidatorList>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMValidatorList)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMValidatorList)
    MergeFrom(*source);
  }
}

void TMValidatorList::MergeFrom(const TMValidatorList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMValidatorList)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      manifest_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manifest_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      blob_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.blob_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      signature_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
    if (cached_has_bits & 0x00000008u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMValidatorList::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMValidatorList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMValidatorList::CopyFrom(const TMValidatorList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMValidatorList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMValidatorList::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  return true;
}

void TMValidatorList::Swap(TMValidatorList* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMValidatorList::InternalSwap(TMValidatorList* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  manifest_.Swap(&other->manifest_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  blob_.Swap(&other->blob_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  signature_.Swap(&other->signature_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(version_, other->version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMValidatorList::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ValidatorBlobInfo::InitAsDefaultInstance() {
}
class ValidatorBlobInfo::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<ValidatorBlobInfo>()._has_bits_);
  static void set_has_manifest(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_blob(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ValidatorBlobInfo::kManifestFieldNumber;
const int ValidatorBlobInfo::kBlobFieldNumber;
const int ValidatorBlobInfo::kSignatureFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ValidatorBlobInfo::ValidatorBlobInfo()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.ValidatorBlobInfo)
}
ValidatorBlobInfo::ValidatorBlobInfo(const ValidatorBlobInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  manifest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_manifest()) {
    manifest_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manifest_);
  }
  blob_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_blob()) {
    blob_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.blob_);
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature()) {
    signature_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  // @@protoc_insertion_point(copy_constructor:protocol.ValidatorBlobInfo)
}

void ValidatorBlobInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ValidatorBlobInfo_ripple_2eproto.base);
  manifest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  blob_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

ValidatorBlobInfo::~ValidatorBlobInfo() {
  // @@protoc_insertion_point(destructor:protocol.ValidatorBlobInfo)
  SharedDtor();
}

void ValidatorBlobInfo::SharedDtor() {
  manifest_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  blob_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ValidatorBlobInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ValidatorBlobInfo& ValidatorBlobInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ValidatorBlobInfo_ripple_2eproto.base);
  return *internal_default_instance();
}


void ValidatorBlobInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.ValidatorBlobInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      manifest_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      blob_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      signature_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ValidatorBlobInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes manifest = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_manifest(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes blob = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_blob(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes signature = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_signature(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ValidatorBlobInfo::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.ValidatorBlobInfo)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes manifest = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_manifest()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes blob = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_blob()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes signature = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.ValidatorBlobInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.ValidatorBlobInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ValidatorBlobInfo::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.ValidatorBlobInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes manifest = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->manifest(), output);
  }

  // required bytes blob = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->blob(), output);
  }

  // required bytes signature = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->signature(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.ValidatorBlobInfo)
}

::PROTOBUF_NAMESPACE_ID::uint8* ValidatorBlobInfo::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.ValidatorBlobInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes manifest = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->manifest(), target);
  }

  // required bytes blob = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->blob(), target);
  }

  // required bytes signature = 3;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        3, this->signature(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.ValidatorBlobInfo)
  return target;
}

size_t ValidatorBlobInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.ValidatorBlobInfo)
  size_t total_size = 0;

  if (has_blob()) {
    // required bytes blob = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->blob());
  }

  if (has_signature()) {
    // required bytes signature = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->signature());
  }

  return total_size;
}
size_t ValidatorBlobInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.ValidatorBlobInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required bytes blob = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->blob());

    // required bytes signature = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->signature());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes manifest = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->manifest());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ValidatorBlobInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.ValidatorBlobInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const ValidatorBlobInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ValidatorBlobInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.ValidatorBlobInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.ValidatorBlobInfo)
    MergeFrom(*source);
  }
}

void ValidatorBlobInfo::MergeFrom(const ValidatorBlobInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.ValidatorBlobInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      manifest_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manifest_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      blob_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.blob_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      signature_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
  }
}

void ValidatorBlobInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.ValidatorBlobInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ValidatorBlobInfo::CopyFrom(const ValidatorBlobInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.ValidatorBlobInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValidatorBlobInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;
  return true;
}

void ValidatorBlobInfo::Swap(ValidatorBlobInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ValidatorBlobInfo::InternalSwap(ValidatorBlobInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  manifest_.Swap(&other->manifest_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  blob_.Swap(&other->blob_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  signature_.Swap(&other->signature_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata ValidatorBlobInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMValidatorListCollection::InitAsDefaultInstance() {
}
class TMValidatorListCollection::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMValidatorListCollection>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_manifest(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMValidatorListCollection::kVersionFieldNumber;
const int TMValidatorListCollection::kManifestFieldNumber;
const int TMValidatorListCollection::kBlobsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMValidatorListCollection::TMValidatorListCollection()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMValidatorListCollection)
}
TMValidatorListCollection::TMValidatorListCollection(const TMValidatorListCollection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      blobs_(from.blobs_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  manifest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_manifest()) {
    manifest_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manifest_);
  }
  version_ = from.version_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMValidatorListCollection)
}

void TMValidatorListCollection::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMValidatorListCollection_ripple_2eproto.base);
  manifest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_ = 0u;
}

TMValidatorListCollection::~TMValidatorListCollection() {
  // @@protoc_insertion_point(destructor:protocol.TMValidatorListCollection)
  SharedDtor();
}

void TMValidatorListCollection::SharedDtor() {
  manifest_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMValidatorListCollection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMValidatorListCollection& TMValidatorListCollection::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMValidatorListCollection_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMValidatorListCollection::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMValidatorListCollection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  blobs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    manifest_.ClearNonDefaultToEmptyNoArena();
  }
  version_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMValidatorListCollection::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes manifest = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_manifest(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.ValidatorBlobInfo blobs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_blobs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 26);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMValidatorListCollection::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMValidatorListCollection)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_version(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes manifest = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_manifest()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .protocol.ValidatorBlobInfo blobs = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_blobs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMValidatorListCollection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMValidatorListCollection)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMValidatorListCollection::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMValidatorListCollection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 version = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // required bytes manifest = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->manifest(), output);
  }

  // repeated .protocol.ValidatorBlobInfo blobs = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->blobs_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3,
      this->blobs(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMValidatorListCollection)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMValidatorListCollection::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMValidatorListCollection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 version = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }

  // required bytes manifest = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->manifest(), target);
  }

  // repeated .protocol.ValidatorBlobInfo blobs = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->blobs_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->blobs(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMValidatorListCollection)
  return target;
}

size_t TMValidatorListCollection::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMValidatorListCollection)
  size_t total_size = 0;

  if (has_manifest()) {
    // required bytes manifest = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->manifest());
  }

  if (has_version()) {
    // required uint32 version = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->version());
  }

  return total_size;
}
size_t TMValidatorListCollection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMValidatorListCollection)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes manifest = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->manifest());

    // required uint32 version = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->version());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.ValidatorBlobInfo blobs = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->blobs_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->blobs(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMValidatorListCollection::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMValidatorListCollection)
  GOOGLE_DCHECK_NE(&from, this);
  const TMValidatorListCollection* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMValidatorListCollection>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMValidatorListCollection)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMValidatorListCollection)
    MergeFrom(*source);
  }
}

void TMValidatorListCollection::MergeFrom(const TMValidatorListCollection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMValidatorListCollection)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  blobs_.MergeFrom(from.blobs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      manifest_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.manifest_);
    }
    if (cached_has_bits & 0x00000002u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMValidatorListCollection::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMValidatorListCollection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMValidatorListCollection::CopyFrom(const TMValidatorListCollection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMValidatorListCollection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMValidatorListCollection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->blobs())) return false;
  return true;
}

void TMValidatorListCollection::Swap(TMValidatorListCollection* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMValidatorListCollection::InternalSwap(TMValidatorListCollection* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&blobs_)->InternalSwap(CastToBase(&other->blobs_));
  manifest_.Swap(&other->manifest_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(version_, other->version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMValidatorListCollection::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMValidation::InitAsDefaultInstance() {
}
class TMValidation::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMValidation>()._has_bits_);
  static void set_has_validation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_checkedsignature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMValidation::kValidationFieldNumber;
const int TMValidation::kCheckedSignatureFieldNumber;
const int TMValidation::kHopsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMValidation::TMValidation()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMValidation)
}
TMValidation::TMValidation(const TMValidation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  validation_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_validation()) {
    validation_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.validation_);
  }
  ::memcpy(&checkedsignature_, &from.checkedsignature_,
    static_cast<size_t>(reinterpret_cast<char*>(&hops_) -
    reinterpret_cast<char*>(&checkedsignature_)) + sizeof(hops_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMValidation)
}

void TMValidation::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMValidation_ripple_2eproto.base);
  validation_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&checkedsignature_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hops_) -
      reinterpret_cast<char*>(&checkedsignature_)) + sizeof(hops_));
}

TMValidation::~TMValidation() {
  // @@protoc_insertion_point(destructor:protocol.TMValidation)
  SharedDtor();
}

void TMValidation::SharedDtor() {
  validation_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMValidation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMValidation& TMValidation::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMValidation_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMValidation::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMValidation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    validation_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&checkedsignature_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&hops_) -
        reinterpret_cast<char*>(&checkedsignature_)) + sizeof(hops_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMValidation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes validation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_validation(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool checkedSignature = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_checkedsignature(&has_bits);
          checkedsignature_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 hops = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_hops(&has_bits);
          hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMValidation::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMValidation)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes validation = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_validation()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool checkedSignature = 2 [deprecated = true];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_checkedsignature(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &checkedsignature_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 hops = 3 [deprecated = true];
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_hops(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hops_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMValidation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMValidation)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMValidation::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMValidation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes validation = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->validation(), output);
  }

  // optional bool checkedSignature = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->checkedsignature(), output);
  }

  // optional uint32 hops = 3 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->hops(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMValidation)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMValidation::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMValidation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes validation = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->validation(), target);
  }

  // optional bool checkedSignature = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->checkedsignature(), target);
  }

  // optional uint32 hops = 3 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->hops(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMValidation)
  return target;
}

size_t TMValidation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMValidation)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required bytes validation = 1;
  if (has_validation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->validation());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional bool checkedSignature = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional uint32 hops = 3 [deprecated = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->hops());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMValidation::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMValidation)
  GOOGLE_DCHECK_NE(&from, this);
  const TMValidation* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMValidation>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMValidation)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMValidation)
    MergeFrom(*source);
  }
}

void TMValidation::MergeFrom(const TMValidation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMValidation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      validation_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.validation_);
    }
    if (cached_has_bits & 0x00000002u) {
      checkedsignature_ = from.checkedsignature_;
    }
    if (cached_has_bits & 0x00000004u) {
      hops_ = from.hops_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMValidation::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMValidation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMValidation::CopyFrom(const TMValidation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMValidation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMValidation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void TMValidation::Swap(TMValidation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMValidation::InternalSwap(TMValidation* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  validation_.Swap(&other->validation_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(checkedsignature_, other->checkedsignature_);
  swap(hops_, other->hops_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMValidation::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMEndpoints_TMEndpointv2::InitAsDefaultInstance() {
}
class TMEndpoints_TMEndpointv2::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMEndpoints_TMEndpointv2>()._has_bits_);
  static void set_has_endpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMEndpoints_TMEndpointv2::kEndpointFieldNumber;
const int TMEndpoints_TMEndpointv2::kHopsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMEndpoints_TMEndpointv2::TMEndpoints_TMEndpointv2()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMEndpoints.TMEndpointv2)
}
TMEndpoints_TMEndpointv2::TMEndpoints_TMEndpointv2(const TMEndpoints_TMEndpointv2& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  endpoint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_endpoint()) {
    endpoint_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.endpoint_);
  }
  hops_ = from.hops_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMEndpoints.TMEndpointv2)
}

void TMEndpoints_TMEndpointv2::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto.base);
  endpoint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hops_ = 0u;
}

TMEndpoints_TMEndpointv2::~TMEndpoints_TMEndpointv2() {
  // @@protoc_insertion_point(destructor:protocol.TMEndpoints.TMEndpointv2)
  SharedDtor();
}

void TMEndpoints_TMEndpointv2::SharedDtor() {
  endpoint_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMEndpoints_TMEndpointv2::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMEndpoints_TMEndpointv2& TMEndpoints_TMEndpointv2::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMEndpoints_TMEndpointv2::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMEndpoints.TMEndpointv2)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    endpoint_.ClearNonDefaultToEmptyNoArena();
  }
  hops_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMEndpoints_TMEndpointv2::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string endpoint = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_endpoint(), ptr, ctx, "protocol.TMEndpoints.TMEndpointv2.endpoint");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 hops = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_hops(&has_bits);
          hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMEndpoints_TMEndpointv2::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMEndpoints.TMEndpointv2)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string endpoint = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_endpoint()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->endpoint().data(), static_cast<int>(this->endpoint().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "protocol.TMEndpoints.TMEndpointv2.endpoint");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 hops = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_hops(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hops_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMEndpoints.TMEndpointv2)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMEndpoints.TMEndpointv2)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMEndpoints_TMEndpointv2::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMEndpoints.TMEndpointv2)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string endpoint = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->endpoint().data(), static_cast<int>(this->endpoint().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMEndpoints.TMEndpointv2.endpoint");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->endpoint(), output);
  }

  // required uint32 hops = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->hops(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMEndpoints.TMEndpointv2)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMEndpoints_TMEndpointv2::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMEndpoints.TMEndpointv2)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string endpoint = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->endpoint().data(), static_cast<int>(this->endpoint().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMEndpoints.TMEndpointv2.endpoint");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        1, this->endpoint(), target);
  }

  // required uint32 hops = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->hops(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMEndpoints.TMEndpointv2)
  return target;
}

size_t TMEndpoints_TMEndpointv2::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMEndpoints.TMEndpointv2)
  size_t total_size = 0;

  if (has_endpoint()) {
    // required string endpoint = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->endpoint());
  }

  if (has_hops()) {
    // required uint32 hops = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->hops());
  }

  return total_size;
}
size_t TMEndpoints_TMEndpointv2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMEndpoints.TMEndpointv2)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string endpoint = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->endpoint());

    // required uint32 hops = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->hops());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMEndpoints_TMEndpointv2::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMEndpoints.TMEndpointv2)
  GOOGLE_DCHECK_NE(&from, this);
  const TMEndpoints_TMEndpointv2* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMEndpoints_TMEndpointv2>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMEndpoints.TMEndpointv2)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMEndpoints.TMEndpointv2)
    MergeFrom(*source);
  }
}

void TMEndpoints_TMEndpointv2::MergeFrom(const TMEndpoints_TMEndpointv2& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMEndpoints.TMEndpointv2)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      endpoint_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.endpoint_);
    }
    if (cached_has_bits & 0x00000002u) {
      hops_ = from.hops_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMEndpoints_TMEndpointv2::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMEndpoints.TMEndpointv2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMEndpoints_TMEndpointv2::CopyFrom(const TMEndpoints_TMEndpointv2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMEndpoints.TMEndpointv2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMEndpoints_TMEndpointv2::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void TMEndpoints_TMEndpointv2::Swap(TMEndpoints_TMEndpointv2* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMEndpoints_TMEndpointv2::InternalSwap(TMEndpoints_TMEndpointv2* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  endpoint_.Swap(&other->endpoint_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(hops_, other->hops_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMEndpoints_TMEndpointv2::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMEndpoints::InitAsDefaultInstance() {
}
class TMEndpoints::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMEndpoints>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMEndpoints::kVersionFieldNumber;
const int TMEndpoints::kEndpointsV2FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMEndpoints::TMEndpoints()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMEndpoints)
}
TMEndpoints::TMEndpoints(const TMEndpoints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      endpoints_v2_(from.endpoints_v2_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  version_ = from.version_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMEndpoints)
}

void TMEndpoints::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMEndpoints_ripple_2eproto.base);
  version_ = 0u;
}

TMEndpoints::~TMEndpoints() {
  // @@protoc_insertion_point(destructor:protocol.TMEndpoints)
  SharedDtor();
}

void TMEndpoints::SharedDtor() {
}

void TMEndpoints::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMEndpoints& TMEndpoints::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMEndpoints_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMEndpoints::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMEndpoints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  endpoints_v2_.Clear();
  version_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMEndpoints::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_endpoints_v2(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 26);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMEndpoints::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMEndpoints)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_version(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_endpoints_v2()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMEndpoints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMEndpoints)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMEndpoints::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMEndpoints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 version = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->endpoints_v2_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3,
      this->endpoints_v2(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMEndpoints)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMEndpoints::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMEndpoints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }

  // repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->endpoints_v2_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->endpoints_v2(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMEndpoints)
  return target;
}

size_t TMEndpoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMEndpoints)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required uint32 version = 1;
  if (has_version()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->version());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->endpoints_v2_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->endpoints_v2(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMEndpoints::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMEndpoints)
  GOOGLE_DCHECK_NE(&from, this);
  const TMEndpoints* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMEndpoints>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMEndpoints)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMEndpoints)
    MergeFrom(*source);
  }
}

void TMEndpoints::MergeFrom(const TMEndpoints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMEndpoints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  endpoints_v2_.MergeFrom(from.endpoints_v2_);
  if (from.has_version()) {
    set_version(from.version());
  }
}

void TMEndpoints::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMEndpoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMEndpoints::CopyFrom(const TMEndpoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMEndpoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMEndpoints::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->endpoints_v2())) return false;
  return true;
}

void TMEndpoints::Swap(TMEndpoints* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMEndpoints::InternalSwap(TMEndpoints* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&endpoints_v2_)->InternalSwap(CastToBase(&other->endpoints_v2_));
  swap(version_, other->version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMEndpoints::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMIndexedObject::InitAsDefaultInstance() {
}
class TMIndexedObject::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMIndexedObject>()._has_bits_);
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodeid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMIndexedObject::kHashFieldNumber;
const int TMIndexedObject::kNodeIDFieldNumber;
const int TMIndexedObject::kIndexFieldNumber;
const int TMIndexedObject::kDataFieldNumber;
const int TMIndexedObject::kLedgerSeqFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMIndexedObject::TMIndexedObject()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMIndexedObject)
}
TMIndexedObject::TMIndexedObject(const TMIndexedObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_hash()) {
    hash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hash_);
  }
  nodeid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_nodeid()) {
    nodeid_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nodeid_);
  }
  index_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_index()) {
    index_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.index_);
  }
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_data()) {
    data_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.data_);
  }
  ledgerseq_ = from.ledgerseq_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMIndexedObject)
}

void TMIndexedObject::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMIndexedObject_ripple_2eproto.base);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodeid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  index_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerseq_ = 0u;
}

TMIndexedObject::~TMIndexedObject() {
  // @@protoc_insertion_point(destructor:protocol.TMIndexedObject)
  SharedDtor();
}

void TMIndexedObject::SharedDtor() {
  hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodeid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  index_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMIndexedObject::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMIndexedObject& TMIndexedObject::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMIndexedObject_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMIndexedObject::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMIndexedObject)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      hash_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      nodeid_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      index_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      data_.ClearNonDefaultToEmptyNoArena();
    }
  }
  ledgerseq_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMIndexedObject::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_hash(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes nodeID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_nodeid(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_index(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ledgerSeq = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          HasBitSetters::set_has_ledgerseq(&has_bits);
          ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMIndexedObject::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMIndexedObject)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes hash = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes nodeID = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodeid()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes index = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_index()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes data = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 ledgerSeq = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_ledgerseq(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ledgerseq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMIndexedObject)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMIndexedObject)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMIndexedObject::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMIndexedObject)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes hash = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->hash(), output);
  }

  // optional bytes nodeID = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->nodeid(), output);
  }

  // optional bytes index = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->index(), output);
  }

  // optional bytes data = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->data(), output);
  }

  // optional uint32 ledgerSeq = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->ledgerseq(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMIndexedObject)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMIndexedObject::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMIndexedObject)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes hash = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->hash(), target);
  }

  // optional bytes nodeID = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->nodeid(), target);
  }

  // optional bytes index = 3;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        3, this->index(), target);
  }

  // optional bytes data = 4;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        4, this->data(), target);
  }

  // optional uint32 ledgerSeq = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->ledgerseq(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMIndexedObject)
  return target;
}

size_t TMIndexedObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMIndexedObject)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes hash = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->hash());
    }

    // optional bytes nodeID = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->nodeid());
    }

    // optional bytes index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->index());
    }

    // optional bytes data = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional uint32 ledgerSeq = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->ledgerseq());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMIndexedObject::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMIndexedObject)
  GOOGLE_DCHECK_NE(&from, this);
  const TMIndexedObject* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMIndexedObject>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMIndexedObject)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMIndexedObject)
    MergeFrom(*source);
  }
}

void TMIndexedObject::MergeFrom(const TMIndexedObject& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMIndexedObject)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      hash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hash_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      nodeid_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nodeid_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      index_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.index_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      data_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (cached_has_bits & 0x00000010u) {
      ledgerseq_ = from.ledgerseq_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMIndexedObject::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMIndexedObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMIndexedObject::CopyFrom(const TMIndexedObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMIndexedObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMIndexedObject::IsInitialized() const {
  return true;
}

void TMIndexedObject::Swap(TMIndexedObject* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMIndexedObject::InternalSwap(TMIndexedObject* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  hash_.Swap(&other->hash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  nodeid_.Swap(&other->nodeid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  index_.Swap(&other->index_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  data_.Swap(&other->data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(ledgerseq_, other->ledgerseq_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMIndexedObject::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMGetObjectByHash::InitAsDefaultInstance() {
}
class TMGetObjectByHash::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMGetObjectByHash>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_query(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_seq(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fat(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMGetObjectByHash::kTypeFieldNumber;
const int TMGetObjectByHash::kQueryFieldNumber;
const int TMGetObjectByHash::kSeqFieldNumber;
const int TMGetObjectByHash::kLedgerHashFieldNumber;
const int TMGetObjectByHash::kFatFieldNumber;
const int TMGetObjectByHash::kObjectsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMGetObjectByHash::TMGetObjectByHash()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMGetObjectByHash)
}
TMGetObjectByHash::TMGetObjectByHash(const TMGetObjectByHash& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      objects_(from.objects_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerhash()) {
    ledgerhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&fat_) -
    reinterpret_cast<char*>(&type_)) + sizeof(fat_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetObjectByHash)
}

void TMGetObjectByHash::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMGetObjectByHash_ripple_2eproto.base);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&fat_) -
      reinterpret_cast<char*>(&type_)) + sizeof(fat_));
}

TMGetObjectByHash::~TMGetObjectByHash() {
  // @@protoc_insertion_point(destructor:protocol.TMGetObjectByHash)
  SharedDtor();
}

void TMGetObjectByHash::SharedDtor() {
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMGetObjectByHash::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMGetObjectByHash& TMGetObjectByHash::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMGetObjectByHash_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMGetObjectByHash::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetObjectByHash)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  objects_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ledgerhash_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fat_) -
        reinterpret_cast<char*>(&type_)) + sizeof(fat_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMGetObjectByHash::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .protocol.TMGetObjectByHash.ObjectType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMGetObjectByHash_ObjectType_IsValid(val))) {
            set_type(static_cast<::protocol::TMGetObjectByHash_ObjectType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required bool query = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_query(&has_bits);
          query_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 seq = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_seq(&has_bits);
          seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes ledgerHash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_ledgerhash(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool fat = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          HasBitSetters::set_has_fat(&has_bits);
          fat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMIndexedObject objects = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 50);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMGetObjectByHash::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMGetObjectByHash)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .protocol.TMGetObjectByHash.ObjectType type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMGetObjectByHash_ObjectType_IsValid(value)) {
            set_type(static_cast< ::protocol::TMGetObjectByHash_ObjectType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bool query = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_query(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &query_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 seq = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_seq(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &seq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes ledgerHash = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool fat = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_fat(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &fat_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .protocol.TMIndexedObject objects = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_objects()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMGetObjectByHash)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMGetObjectByHash)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMGetObjectByHash::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMGetObjectByHash)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMGetObjectByHash.ObjectType type = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required bool query = 2;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->query(), output);
  }

  // optional uint32 seq = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->seq(), output);
  }

  // optional bytes ledgerHash = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->ledgerhash(), output);
  }

  // optional bool fat = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(5, this->fat(), output);
  }

  // repeated .protocol.TMIndexedObject objects = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->objects_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      6,
      this->objects(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMGetObjectByHash)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMGetObjectByHash::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetObjectByHash)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMGetObjectByHash.ObjectType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required bool query = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->query(), target);
  }

  // optional uint32 seq = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->seq(), target);
  }

  // optional bytes ledgerHash = 4;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        4, this->ledgerhash(), target);
  }

  // optional bool fat = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->fat(), target);
  }

  // repeated .protocol.TMIndexedObject objects = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->objects_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, this->objects(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetObjectByHash)
  return target;
}

size_t TMGetObjectByHash::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMGetObjectByHash)
  size_t total_size = 0;

  if (has_type()) {
    // required .protocol.TMGetObjectByHash.ObjectType type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
  }

  if (has_query()) {
    // required bool query = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t TMGetObjectByHash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetObjectByHash)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000000a) ^ 0x0000000a) == 0) {  // All required fields are present.
    // required .protocol.TMGetObjectByHash.ObjectType type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());

    // required bool query = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMIndexedObject objects = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->objects_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->objects(static_cast<int>(i)));
    }
  }

  // optional bytes ledgerHash = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->ledgerhash());
  }

  // optional uint32 seq = 3;
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->seq());
  }

  // optional bool fat = 5;
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 + 1;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMGetObjectByHash::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMGetObjectByHash)
  GOOGLE_DCHECK_NE(&from, this);
  const TMGetObjectByHash* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMGetObjectByHash>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMGetObjectByHash)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMGetObjectByHash)
    MergeFrom(*source);
  }
}

void TMGetObjectByHash::MergeFrom(const TMGetObjectByHash& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetObjectByHash)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  objects_.MergeFrom(from.objects_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      ledgerhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      seq_ = from.seq_;
    }
    if (cached_has_bits & 0x00000008u) {
      query_ = from.query_;
    }
    if (cached_has_bits & 0x00000010u) {
      fat_ = from.fat_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMGetObjectByHash::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMGetObjectByHash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetObjectByHash::CopyFrom(const TMGetObjectByHash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetObjectByHash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetObjectByHash::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000a) != 0x0000000a) return false;
  return true;
}

void TMGetObjectByHash::Swap(TMGetObjectByHash* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMGetObjectByHash::InternalSwap(TMGetObjectByHash* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&objects_)->InternalSwap(CastToBase(&other->objects_));
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(type_, other->type_);
  swap(seq_, other->seq_);
  swap(query_, other->query_);
  swap(fat_, other->fat_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMGetObjectByHash::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMLedgerNode::InitAsDefaultInstance() {
}
class TMLedgerNode::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMLedgerNode>()._has_bits_);
  static void set_has_nodedata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodeid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMLedgerNode::kNodedataFieldNumber;
const int TMLedgerNode::kNodeidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMLedgerNode::TMLedgerNode()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMLedgerNode)
}
TMLedgerNode::TMLedgerNode(const TMLedgerNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  nodedata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_nodedata()) {
    nodedata_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nodedata_);
  }
  nodeid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_nodeid()) {
    nodeid_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nodeid_);
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMLedgerNode)
}

void TMLedgerNode::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMLedgerNode_ripple_2eproto.base);
  nodedata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodeid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

TMLedgerNode::~TMLedgerNode() {
  // @@protoc_insertion_point(destructor:protocol.TMLedgerNode)
  SharedDtor();
}

void TMLedgerNode::SharedDtor() {
  nodedata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodeid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMLedgerNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMLedgerNode& TMLedgerNode::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMLedgerNode_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMLedgerNode::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLedgerNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      nodedata_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      nodeid_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMLedgerNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes nodedata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_nodedata(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes nodeid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_nodeid(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMLedgerNode::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMLedgerNode)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes nodedata = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodedata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes nodeid = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodeid()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMLedgerNode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMLedgerNode)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMLedgerNode::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMLedgerNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes nodedata = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->nodedata(), output);
  }

  // optional bytes nodeid = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->nodeid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMLedgerNode)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMLedgerNode::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLedgerNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes nodedata = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->nodedata(), target);
  }

  // optional bytes nodeid = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->nodeid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLedgerNode)
  return target;
}

size_t TMLedgerNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLedgerNode)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required bytes nodedata = 1;
  if (has_nodedata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->nodedata());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes nodeid = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->nodeid());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMLedgerNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMLedgerNode)
  GOOGLE_DCHECK_NE(&from, this);
  const TMLedgerNode* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMLedgerNode>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMLedgerNode)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMLedgerNode)
    MergeFrom(*source);
  }
}

void TMLedgerNode::MergeFrom(const TMLedgerNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLedgerNode)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      nodedata_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nodedata_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      nodeid_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nodeid_);
    }
  }
}

void TMLedgerNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMLedgerNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLedgerNode::CopyFrom(const TMLedgerNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLedgerNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLedgerNode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void TMLedgerNode::Swap(TMLedgerNode* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMLedgerNode::InternalSwap(TMLedgerNode* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  nodedata_.Swap(&other->nodedata_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  nodeid_.Swap(&other->nodeid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata TMLedgerNode::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMGetLedger::InitAsDefaultInstance() {
}
class TMGetLedger::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMGetLedger>()._has_bits_);
  static void set_has_itype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ltype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_requestcookie(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_querytype(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_querydepth(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMGetLedger::kItypeFieldNumber;
const int TMGetLedger::kLtypeFieldNumber;
const int TMGetLedger::kLedgerHashFieldNumber;
const int TMGetLedger::kLedgerSeqFieldNumber;
const int TMGetLedger::kNodeIDsFieldNumber;
const int TMGetLedger::kRequestCookieFieldNumber;
const int TMGetLedger::kQueryTypeFieldNumber;
const int TMGetLedger::kQueryDepthFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMGetLedger::TMGetLedger()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMGetLedger)
}
TMGetLedger::TMGetLedger(const TMGetLedger& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      nodeids_(from.nodeids_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerhash()) {
    ledgerhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
  }
  ::memcpy(&itype_, &from.itype_,
    static_cast<size_t>(reinterpret_cast<char*>(&querydepth_) -
    reinterpret_cast<char*>(&itype_)) + sizeof(querydepth_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetLedger)
}

void TMGetLedger::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMGetLedger_ripple_2eproto.base);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&itype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&querydepth_) -
      reinterpret_cast<char*>(&itype_)) + sizeof(querydepth_));
}

TMGetLedger::~TMGetLedger() {
  // @@protoc_insertion_point(destructor:protocol.TMGetLedger)
  SharedDtor();
}

void TMGetLedger::SharedDtor() {
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMGetLedger::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMGetLedger& TMGetLedger::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMGetLedger_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMGetLedger::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetLedger)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nodeids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ledgerhash_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&itype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&querydepth_) -
        reinterpret_cast<char*>(&itype_)) + sizeof(querydepth_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMGetLedger::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .protocol.TMLedgerInfoType itype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerInfoType_IsValid(val))) {
            set_itype(static_cast<::protocol::TMLedgerInfoType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .protocol.TMLedgerType ltype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerType_IsValid(val))) {
            set_ltype(static_cast<::protocol::TMLedgerType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bytes ledgerHash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_ledgerhash(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ledgerSeq = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_ledgerseq(&has_bits);
          ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bytes nodeIDs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(add_nodeids(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      // optional uint64 requestCookie = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          HasBitSetters::set_has_requestcookie(&has_bits);
          requestcookie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .protocol.TMQueryType queryType = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMQueryType_IsValid(val))) {
            set_querytype(static_cast<::protocol::TMQueryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 queryDepth = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          HasBitSetters::set_has_querydepth(&has_bits);
          querydepth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMGetLedger::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMGetLedger)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .protocol.TMLedgerInfoType itype = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMLedgerInfoType_IsValid(value)) {
            set_itype(static_cast< ::protocol::TMLedgerInfoType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .protocol.TMLedgerType ltype = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMLedgerType_IsValid(value)) {
            set_ltype(static_cast< ::protocol::TMLedgerType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes ledgerHash = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 ledgerSeq = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_ledgerseq(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ledgerseq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated bytes nodeIDs = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->add_nodeids()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 requestCookie = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_requestcookie(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &requestcookie_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .protocol.TMQueryType queryType = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMQueryType_IsValid(value)) {
            set_querytype(static_cast< ::protocol::TMQueryType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                7, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 queryDepth = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_querydepth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &querydepth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMGetLedger)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMGetLedger)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMGetLedger::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMGetLedger)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMLedgerInfoType itype = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->itype(), output);
  }

  // optional .protocol.TMLedgerType ltype = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->ltype(), output);
  }

  // optional bytes ledgerHash = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->ledgerhash(), output);
  }

  // optional uint32 ledgerSeq = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->ledgerseq(), output);
  }

  // repeated bytes nodeIDs = 5;
  for (int i = 0, n = this->nodeids_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytes(
      5, this->nodeids(i), output);
  }

  // optional uint64 requestCookie = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(6, this->requestcookie(), output);
  }

  // optional .protocol.TMQueryType queryType = 7;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      7, this->querytype(), output);
  }

  // optional uint32 queryDepth = 8;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(8, this->querydepth(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMGetLedger)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMGetLedger::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetLedger)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMLedgerInfoType itype = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->itype(), target);
  }

  // optional .protocol.TMLedgerType ltype = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->ltype(), target);
  }

  // optional bytes ledgerHash = 3;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        3, this->ledgerhash(), target);
  }

  // optional uint32 ledgerSeq = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->ledgerseq(), target);
  }

  // repeated bytes nodeIDs = 5;
  for (int i = 0, n = this->nodeids_size(); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      WriteBytesToArray(5, this->nodeids(i), target);
  }

  // optional uint64 requestCookie = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->requestcookie(), target);
  }

  // optional .protocol.TMQueryType queryType = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->querytype(), target);
  }

  // optional uint32 queryDepth = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->querydepth(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetLedger)
  return target;
}

size_t TMGetLedger::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetLedger)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .protocol.TMLedgerInfoType itype = 1;
  if (has_itype()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->itype());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes nodeIDs = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->nodeids_size());
  for (int i = 0, n = this->nodeids_size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      this->nodeids(i));
  }

  // optional bytes ledgerHash = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->ledgerhash());
  }

  if (cached_has_bits & 0x0000007cu) {
    // optional .protocol.TMLedgerType ltype = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->ltype());
    }

    // optional uint32 ledgerSeq = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->ledgerseq());
    }

    // optional .protocol.TMQueryType queryType = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->querytype());
    }

    // optional uint64 requestCookie = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->requestcookie());
    }

    // optional uint32 queryDepth = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->querydepth());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMGetLedger::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMGetLedger)
  GOOGLE_DCHECK_NE(&from, this);
  const TMGetLedger* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMGetLedger>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMGetLedger)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMGetLedger)
    MergeFrom(*source);
  }
}

void TMGetLedger::MergeFrom(const TMGetLedger& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetLedger)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  nodeids_.MergeFrom(from.nodeids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      ledgerhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
    }
    if (cached_has_bits & 0x00000002u) {
      itype_ = from.itype_;
    }
    if (cached_has_bits & 0x00000004u) {
      ltype_ = from.ltype_;
    }
    if (cached_has_bits & 0x00000008u) {
      ledgerseq_ = from.ledgerseq_;
    }
    if (cached_has_bits & 0x00000010u) {
      querytype_ = from.querytype_;
    }
    if (cached_has_bits & 0x00000020u) {
      requestcookie_ = from.requestcookie_;
    }
    if (cached_has_bits & 0x00000040u) {
      querydepth_ = from.querydepth_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMGetLedger::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMGetLedger)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetLedger::CopyFrom(const TMGetLedger& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetLedger)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetLedger::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  return true;
}

void TMGetLedger::Swap(TMGetLedger* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMGetLedger::InternalSwap(TMGetLedger* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  nodeids_.InternalSwap(CastToBase(&other->nodeids_));
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(itype_, other->itype_);
  swap(ltype_, other->ltype_);
  swap(ledgerseq_, other->ledgerseq_);
  swap(querytype_, other->querytype_);
  swap(requestcookie_, other->requestcookie_);
  swap(querydepth_, other->querydepth_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMGetLedger::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMLedgerData::InitAsDefaultInstance() {
}
class TMLedgerData::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMLedgerData>()._has_bits_);
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_requestcookie(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMLedgerData::kLedgerHashFieldNumber;
const int TMLedgerData::kLedgerSeqFieldNumber;
const int TMLedgerData::kTypeFieldNumber;
const int TMLedgerData::kNodesFieldNumber;
const int TMLedgerData::kRequestCookieFieldNumber;
const int TMLedgerData::kErrorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMLedgerData::TMLedgerData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMLedgerData)
}
TMLedgerData::TMLedgerData(const TMLedgerData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      nodes_(from.nodes_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerhash()) {
    ledgerhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
  }
  ::memcpy(&ledgerseq_, &from.ledgerseq_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&ledgerseq_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMLedgerData)
}

void TMLedgerData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMLedgerData_ripple_2eproto.base);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&ledgerseq_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&requestcookie_) -
      reinterpret_cast<char*>(&ledgerseq_)) + sizeof(requestcookie_));
  error_ = 1;
}

TMLedgerData::~TMLedgerData() {
  // @@protoc_insertion_point(destructor:protocol.TMLedgerData)
  SharedDtor();
}

void TMLedgerData::SharedDtor() {
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMLedgerData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMLedgerData& TMLedgerData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMLedgerData_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMLedgerData::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLedgerData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nodes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ledgerhash_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&ledgerseq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&requestcookie_) -
        reinterpret_cast<char*>(&ledgerseq_)) + sizeof(requestcookie_));
    error_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMLedgerData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes ledgerHash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_ledgerhash(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 ledgerSeq = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_ledgerseq(&has_bits);
          ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .protocol.TMLedgerInfoType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerInfoType_IsValid(val))) {
            set_type(static_cast<::protocol::TMLedgerInfoType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMLedgerNode nodes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 34);
        } else goto handle_unusual;
        continue;
      // optional uint32 requestCookie = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          HasBitSetters::set_has_requestcookie(&has_bits);
          requestcookie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .protocol.TMReplyError error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMReplyError_IsValid(val))) {
            set_error(static_cast<::protocol::TMReplyError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMLedgerData::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMLedgerData)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes ledgerHash = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 ledgerSeq = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_ledgerseq(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ledgerseq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .protocol.TMLedgerInfoType type = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMLedgerInfoType_IsValid(value)) {
            set_type(static_cast< ::protocol::TMLedgerInfoType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .protocol.TMLedgerNode nodes = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_nodes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 requestCookie = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_requestcookie(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &requestcookie_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .protocol.TMReplyError error = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMReplyError_IsValid(value)) {
            set_error(static_cast< ::protocol::TMReplyError >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                6, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMLedgerData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMLedgerData)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMLedgerData::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMLedgerData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes ledgerHash = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->ledgerhash(), output);
  }

  // required uint32 ledgerSeq = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->ledgerseq(), output);
  }

  // required .protocol.TMLedgerInfoType type = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // repeated .protocol.TMLedgerNode nodes = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->nodes_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      4,
      this->nodes(static_cast<int>(i)),
      output);
  }

  // optional uint32 requestCookie = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->requestcookie(), output);
  }

  // optional .protocol.TMReplyError error = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      6, this->error(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMLedgerData)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMLedgerData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLedgerData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes ledgerHash = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->ledgerhash(), target);
  }

  // required uint32 ledgerSeq = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->ledgerseq(), target);
  }

  // required .protocol.TMLedgerInfoType type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->type(), target);
  }

  // repeated .protocol.TMLedgerNode nodes = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->nodes_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->nodes(static_cast<int>(i)), target);
  }

  // optional uint32 requestCookie = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->requestcookie(), target);
  }

  // optional .protocol.TMReplyError error = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->error(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLedgerData)
  return target;
}

size_t TMLedgerData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMLedgerData)
  size_t total_size = 0;

  if (has_ledgerhash()) {
    // required bytes ledgerHash = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->ledgerhash());
  }

  if (has_ledgerseq()) {
    // required uint32 ledgerSeq = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->ledgerseq());
  }

  if (has_type()) {
    // required .protocol.TMLedgerInfoType type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
  }

  return total_size;
}
size_t TMLedgerData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLedgerData)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required bytes ledgerHash = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->ledgerhash());

    // required uint32 ledgerSeq = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->ledgerseq());

    // required .protocol.TMLedgerInfoType type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMLedgerNode nodes = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->nodes_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->nodes(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000018u) {
    // optional uint32 requestCookie = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->requestcookie());
    }

    // optional .protocol.TMReplyError error = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->error());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMLedgerData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMLedgerData)
  GOOGLE_DCHECK_NE(&from, this);
  const TMLedgerData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMLedgerData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMLedgerData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMLedgerData)
    MergeFrom(*source);
  }
}

void TMLedgerData::MergeFrom(const TMLedgerData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLedgerData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  nodes_.MergeFrom(from.nodes_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      ledgerhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
    }
    if (cached_has_bits & 0x00000002u) {
      ledgerseq_ = from.ledgerseq_;
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      requestcookie_ = from.requestcookie_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMLedgerData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMLedgerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLedgerData::CopyFrom(const TMLedgerData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLedgerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLedgerData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->nodes())) return false;
  return true;
}

void TMLedgerData::Swap(TMLedgerData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMLedgerData::InternalSwap(TMLedgerData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&nodes_)->InternalSwap(CastToBase(&other->nodes_));
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(ledgerseq_, other->ledgerseq_);
  swap(type_, other->type_);
  swap(requestcookie_, other->requestcookie_);
  swap(error_, other->error_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMLedgerData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMPing::InitAsDefaultInstance() {
}
class TMPing::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMPing>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seq(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pingtime(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nettime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMPing::kTypeFieldNumber;
const int TMPing::kSeqFieldNumber;
const int TMPing::kPingTimeFieldNumber;
const int TMPing::kNetTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMPing::TMPing()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMPing)
}
TMPing::TMPing(const TMPing& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&nettime_) -
    reinterpret_cast<char*>(&type_)) + sizeof(nettime_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMPing)
}

void TMPing::SharedCtor() {
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nettime_) -
      reinterpret_cast<char*>(&type_)) + sizeof(nettime_));
}

TMPing::~TMPing() {
  // @@protoc_insertion_point(destructor:protocol.TMPing)
  SharedDtor();
}

void TMPing::SharedDtor() {
}

void TMPing::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMPing& TMPing::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMPing_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMPing::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMPing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nettime_) -
        reinterpret_cast<char*>(&type_)) + sizeof(nettime_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMPing::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .protocol.TMPing.pingType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMPing_pingType_IsValid(val))) {
            set_type(static_cast<::protocol::TMPing_pingType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 seq = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_seq(&has_bits);
          seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pingTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_pingtime(&has_bits);
          pingtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 netTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_nettime(&has_bits);
          nettime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMPing::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMPing)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .protocol.TMPing.pingType type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMPing_pingType_IsValid(value)) {
            set_type(static_cast< ::protocol::TMPing_pingType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 seq = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_seq(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &seq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pingTime = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_pingtime(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pingtime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 netTime = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_nettime(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &nettime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMPing)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMPing)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMPing::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMPing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMPing.pingType type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional uint32 seq = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->seq(), output);
  }

  // optional uint64 pingTime = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->pingtime(), output);
  }

  // optional uint64 netTime = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(4, this->nettime(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMPing)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMPing::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMPing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMPing.pingType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional uint32 seq = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->seq(), target);
  }

  // optional uint64 pingTime = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->pingtime(), target);
  }

  // optional uint64 netTime = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->nettime(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMPing)
  return target;
}

size_t TMPing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMPing)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .protocol.TMPing.pingType type = 1;
  if (has_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional uint32 seq = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->seq());
    }

    // optional uint64 pingTime = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->pingtime());
    }

    // optional uint64 netTime = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->nettime());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMPing::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMPing)
  GOOGLE_DCHECK_NE(&from, this);
  const TMPing* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMPing>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMPing)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMPing)
    MergeFrom(*source);
  }
}

void TMPing::MergeFrom(const TMPing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMPing)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      seq_ = from.seq_;
    }
    if (cached_has_bits & 0x00000004u) {
      pingtime_ = from.pingtime_;
    }
    if (cached_has_bits & 0x00000008u) {
      nettime_ = from.nettime_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMPing::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMPing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMPing::CopyFrom(const TMPing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMPing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPing::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void TMPing::Swap(TMPing* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMPing::InternalSwap(TMPing* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(type_, other->type_);
  swap(seq_, other->seq_);
  swap(pingtime_, other->pingtime_);
  swap(nettime_, other->nettime_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMPing::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMSquelch::InitAsDefaultInstance() {
}
class TMSquelch::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMSquelch>()._has_bits_);
  static void set_has_squelch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_validatorpubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_squelchduration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMSquelch::kSquelchFieldNumber;
const int TMSquelch::kValidatorPubKeyFieldNumber;
const int TMSquelch::kSquelchDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMSquelch::TMSquelch()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMSquelch)
}
TMSquelch::TMSquelch(const TMSquelch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  validatorpubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_validatorpubkey()) {
    validatorpubkey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.validatorpubkey_);
  }
  ::memcpy(&squelch_, &from.squelch_,
    static_cast<size_t>(reinterpret_cast<char*>(&squelchduration_) -
    reinterpret_cast<char*>(&squelch_)) + sizeof(squelchduration_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMSquelch)
}

void TMSquelch::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMSquelch_ripple_2eproto.base);
  validatorpubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&squelch_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&squelchduration_) -
      reinterpret_cast<char*>(&squelch_)) + sizeof(squelchduration_));
}

TMSquelch::~TMSquelch() {
  // @@protoc_insertion_point(destructor:protocol.TMSquelch)
  SharedDtor();
}

void TMSquelch::SharedDtor() {
  validatorpubkey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMSquelch::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMSquelch& TMSquelch::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMSquelch_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMSquelch::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMSquelch)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    validatorpubkey_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&squelch_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&squelchduration_) -
        reinterpret_cast<char*>(&squelch_)) + sizeof(squelchduration_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMSquelch::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool squelch = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_squelch(&has_bits);
          squelch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes validatorPubKey = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_validatorpubkey(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 squelchDuration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_squelchduration(&has_bits);
          squelchduration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMSquelch::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMSquelch)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool squelch = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_squelch(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &squelch_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes validatorPubKey = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_validatorpubkey()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 squelchDuration = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_squelchduration(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &squelchduration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMSquelch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMSquelch)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMSquelch::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMSquelch)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool squelch = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(1, this->squelch(), output);
  }

  // required bytes validatorPubKey = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->validatorpubkey(), output);
  }

  // optional uint32 squelchDuration = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->squelchduration(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMSquelch)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMSquelch::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMSquelch)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool squelch = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->squelch(), target);
  }

  // required bytes validatorPubKey = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->validatorpubkey(), target);
  }

  // optional uint32 squelchDuration = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->squelchduration(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMSquelch)
  return target;
}

size_t TMSquelch::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMSquelch)
  size_t total_size = 0;

  if (has_validatorpubkey()) {
    // required bytes validatorPubKey = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->validatorpubkey());
  }

  if (has_squelch()) {
    // required bool squelch = 1;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t TMSquelch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMSquelch)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes validatorPubKey = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->validatorpubkey());

    // required bool squelch = 1;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 squelchDuration = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->squelchduration());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMSquelch::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMSquelch)
  GOOGLE_DCHECK_NE(&from, this);
  const TMSquelch* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMSquelch>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMSquelch)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMSquelch)
    MergeFrom(*source);
  }
}

void TMSquelch::MergeFrom(const TMSquelch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMSquelch)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      validatorpubkey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.validatorpubkey_);
    }
    if (cached_has_bits & 0x00000002u) {
      squelch_ = from.squelch_;
    }
    if (cached_has_bits & 0x00000004u) {
      squelchduration_ = from.squelchduration_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMSquelch::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMSquelch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMSquelch::CopyFrom(const TMSquelch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMSquelch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMSquelch::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void TMSquelch::Swap(TMSquelch* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMSquelch::InternalSwap(TMSquelch* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  validatorpubkey_.Swap(&other->validatorpubkey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(squelch_, other->squelch_);
  swap(squelchduration_, other->squelchduration_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMSquelch::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMProofPathRequest::InitAsDefaultInstance() {
}
class TMProofPathRequest::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMProofPathRequest>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMProofPathRequest::kKeyFieldNumber;
const int TMProofPathRequest::kLedgerHashFieldNumber;
const int TMProofPathRequest::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMProofPathRequest::TMProofPathRequest()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMProofPathRequest)
}
TMProofPathRequest::TMProofPathRequest(const TMProofPathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_key()) {
    key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerhash()) {
    ledgerhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMProofPathRequest)
}

void TMProofPathRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMProofPathRequest_ripple_2eproto.base);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_ = 1;
}

TMProofPathRequest::~TMProofPathRequest() {
  // @@protoc_insertion_point(destructor:protocol.TMProofPathRequest)
  SharedDtor();
}

void TMProofPathRequest::SharedDtor() {
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMProofPathRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMProofPathRequest& TMProofPathRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMProofPathRequest_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMProofPathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMProofPathRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      ledgerhash_.ClearNonDefaultToEmptyNoArena();
    }
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMProofPathRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_key(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes ledgerHash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_ledgerhash(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .protocol.TMLedgerMapType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerMapType_IsValid(val))) {
            set_type(static_cast<::protocol::TMLedgerMapType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMProofPathRequest::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMProofPathRequest)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes key = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes ledgerHash = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .protocol.TMLedgerMapType type = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMLedgerMapType_IsValid(value)) {
            set_type(static_cast< ::protocol::TMLedgerMapType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMProofPathRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMProofPathRequest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMProofPathRequest::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMProofPathRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->key(), output);
  }

  // required bytes ledgerHash = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->ledgerhash(), output);
  }

  // required .protocol.TMLedgerMapType type = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMProofPathRequest)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMProofPathRequest::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMProofPathRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->key(), target);
  }

  // required bytes ledgerHash = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->ledgerhash(), target);
  }

  // required .protocol.TMLedgerMapType type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMProofPathRequest)
  return target;
}

size_t TMProofPathRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMProofPathRequest)
  size_t total_size = 0;

  if (has_key()) {
    // required bytes key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->key());
  }

  if (has_ledgerhash()) {
    // required bytes ledgerHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->ledgerhash());
  }

  if (has_type()) {
    // required .protocol.TMLedgerMapType type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
  }

  return total_size;
}
size_t TMProofPathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMProofPathRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required bytes key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->key());

    // required bytes ledgerHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->ledgerhash());

    // required .protocol.TMLedgerMapType type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMProofPathRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMProofPathRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const TMProofPathRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMProofPathRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMProofPathRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMProofPathRequest)
    MergeFrom(*source);
  }
}

void TMProofPathRequest::MergeFrom(const TMProofPathRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMProofPathRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      ledgerhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMProofPathRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMProofPathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMProofPathRequest::CopyFrom(const TMProofPathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMProofPathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMProofPathRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void TMProofPathRequest::Swap(TMProofPathRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMProofPathRequest::InternalSwap(TMProofPathRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  key_.Swap(&other->key_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMProofPathRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMProofPathResponse::InitAsDefaultInstance() {
}
class TMProofPathResponse::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMProofPathResponse>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ledgerheader(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMProofPathResponse::kKeyFieldNumber;
const int TMProofPathResponse::kLedgerHashFieldNumber;
const int TMProofPathResponse::kTypeFieldNumber;
const int TMProofPathResponse::kLedgerHeaderFieldNumber;
const int TMProofPathResponse::kPathFieldNumber;
const int TMProofPathResponse::kErrorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMProofPathResponse::TMProofPathResponse()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMProofPathResponse)
}
TMProofPathResponse::TMProofPathResponse(const TMProofPathResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      path_(from.path_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_key()) {
    key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerhash()) {
    ledgerhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
  }
  ledgerheader_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerheader()) {
    ledgerheader_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerheader_);
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&type_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMProofPathResponse)
}

void TMProofPathResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMProofPathResponse_ripple_2eproto.base);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerheader_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_ = 1;
  error_ = 1;
}

TMProofPathResponse::~TMProofPathResponse() {
  // @@protoc_insertion_point(destructor:protocol.TMProofPathResponse)
  SharedDtor();
}

void TMProofPathResponse::SharedDtor() {
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerheader_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMProofPathResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMProofPathResponse& TMProofPathResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMProofPathResponse_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMProofPathResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMProofPathResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  path_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      ledgerhash_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      ledgerheader_.ClearNonDefaultToEmptyNoArena();
    }
    type_ = 1;
    error_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMProofPathResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_key(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes ledgerHash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_ledgerhash(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .protocol.TMLedgerMapType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerMapType_IsValid(val))) {
            set_type(static_cast<::protocol::TMLedgerMapType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bytes ledgerHeader = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_ledgerheader(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bytes path = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(add_path(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      // optional .protocol.TMReplyError error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMReplyError_IsValid(val))) {
            set_error(static_cast<::protocol::TMReplyError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMProofPathResponse::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMProofPathResponse)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes key = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes ledgerHash = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .protocol.TMLedgerMapType type = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMLedgerMapType_IsValid(value)) {
            set_type(static_cast< ::protocol::TMLedgerMapType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes ledgerHeader = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerheader()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated bytes path = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->add_path()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .protocol.TMReplyError error = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMReplyError_IsValid(value)) {
            set_error(static_cast< ::protocol::TMReplyError >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                6, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMProofPathResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMProofPathResponse)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMProofPathResponse::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMProofPathResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->key(), output);
  }

  // required bytes ledgerHash = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->ledgerhash(), output);
  }

  // required .protocol.TMLedgerMapType type = 3;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // optional bytes ledgerHeader = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->ledgerheader(), output);
  }

  // repeated bytes path = 5;
  for (int i = 0, n = this->path_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytes(
      5, this->path(i), output);
  }

  // optional .protocol.TMReplyError error = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      6, this->error(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMProofPathResponse)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMProofPathResponse::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMProofPathResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->key(), target);
  }

  // required bytes ledgerHash = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->ledgerhash(), target);
  }

  // required .protocol.TMLedgerMapType type = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->type(), target);
  }

  // optional bytes ledgerHeader = 4;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        4, this->ledgerheader(), target);
  }

  // repeated bytes path = 5;
  for (int i = 0, n = this->path_size(); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      WriteBytesToArray(5, this->path(i), target);
  }

  // optional .protocol.TMReplyError error = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->error(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMProofPathResponse)
  return target;
}

size_t TMProofPathResponse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMProofPathResponse)
  size_t total_size = 0;

  if (has_key()) {
    // required bytes key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->key());
  }

  if (has_ledgerhash()) {
    // required bytes ledgerHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->ledgerhash());
  }

  if (has_type()) {
    // required .protocol.TMLedgerMapType type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
  }

  return total_size;
}
size_t TMProofPathResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMProofPathResponse)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000000b) ^ 0x0000000b) == 0) {  // All required fields are present.
    // required bytes key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->key());

    // required bytes ledgerHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->ledgerhash());

    // required .protocol.TMLedgerMapType type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes path = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->path_size());
  for (int i = 0, n = this->path_size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      this->path(i));
  }

  // optional bytes ledgerHeader = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->ledgerheader());
  }

  // optional .protocol.TMReplyError error = 6;
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->error());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMProofPathResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMProofPathResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const TMProofPathResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMProofPathResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMProofPathResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMProofPathResponse)
    MergeFrom(*source);
  }
}

void TMProofPathResponse::MergeFrom(const TMProofPathResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMProofPathResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  path_.MergeFrom(from.path_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      ledgerhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      ledgerheader_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerheader_);
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMProofPathResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMProofPathResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMProofPathResponse::CopyFrom(const TMProofPathResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMProofPathResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMProofPathResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000b) != 0x0000000b) return false;
  return true;
}

void TMProofPathResponse::Swap(TMProofPathResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMProofPathResponse::InternalSwap(TMProofPathResponse* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  path_.InternalSwap(CastToBase(&other->path_));
  key_.Swap(&other->key_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  ledgerheader_.Swap(&other->ledgerheader_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(type_, other->type_);
  swap(error_, other->error_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMProofPathResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMReplayDeltaRequest::InitAsDefaultInstance() {
}
class TMReplayDeltaRequest::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMReplayDeltaRequest>()._has_bits_);
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMReplayDeltaRequest::kLedgerHashFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMReplayDeltaRequest::TMReplayDeltaRequest()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMReplayDeltaRequest)
}
TMReplayDeltaRequest::TMReplayDeltaRequest(const TMReplayDeltaRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerhash()) {
    ledgerhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMReplayDeltaRequest)
}

void TMReplayDeltaRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMReplayDeltaRequest_ripple_2eproto.base);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

TMReplayDeltaRequest::~TMReplayDeltaRequest() {
  // @@protoc_insertion_point(destructor:protocol.TMReplayDeltaRequest)
  SharedDtor();
}

void TMReplayDeltaRequest::SharedDtor() {
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMReplayDeltaRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMReplayDeltaRequest& TMReplayDeltaRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMReplayDeltaRequest_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMReplayDeltaRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMReplayDeltaRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ledgerhash_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMReplayDeltaRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes ledgerHash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_ledgerhash(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMReplayDeltaRequest::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMReplayDeltaRequest)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes ledgerHash = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMReplayDeltaRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMReplayDeltaRequest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMReplayDeltaRequest::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMReplayDeltaRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes ledgerHash = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->ledgerhash(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMReplayDeltaRequest)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMReplayDeltaRequest::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMReplayDeltaRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes ledgerHash = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->ledgerhash(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMReplayDeltaRequest)
  return target;
}

size_t TMReplayDeltaRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMReplayDeltaRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required bytes ledgerHash = 1;
  if (has_ledgerhash()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->ledgerhash());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMReplayDeltaRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMReplayDeltaRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const TMReplayDeltaRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMReplayDeltaRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMReplayDeltaRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMReplayDeltaRequest)
    MergeFrom(*source);
  }
}

void TMReplayDeltaRequest::MergeFrom(const TMReplayDeltaRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMReplayDeltaRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_ledgerhash()) {
    _has_bits_[0] |= 0x00000001u;
    ledgerhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
  }
}

void TMReplayDeltaRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMReplayDeltaRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMReplayDeltaRequest::CopyFrom(const TMReplayDeltaRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMReplayDeltaRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMReplayDeltaRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void TMReplayDeltaRequest::Swap(TMReplayDeltaRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMReplayDeltaRequest::InternalSwap(TMReplayDeltaRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata TMReplayDeltaRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMReplayDeltaResponse::InitAsDefaultInstance() {
}
class TMReplayDeltaResponse::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<TMReplayDeltaResponse>()._has_bits_);
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerheader(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMReplayDeltaResponse::kLedgerHashFieldNumber;
const int TMReplayDeltaResponse::kLedgerHeaderFieldNumber;
const int TMReplayDeltaResponse::kTransactionFieldNumber;
const int TMReplayDeltaResponse::kErrorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMReplayDeltaResponse::TMReplayDeltaResponse()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMReplayDeltaResponse)
}
TMReplayDeltaResponse::TMReplayDeltaResponse(const TMReplayDeltaResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      transaction_(from.transaction_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerhash()) {
    ledgerhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
  }
  ledgerheader_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerheader()) {
    ledgerheader_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerheader_);
  }
  error_ = from.error_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMReplayDeltaResponse)
}

void TMReplayDeltaResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMReplayDeltaResponse_ripple_2eproto.base);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerheader_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  error_ = 1;
}

TMReplayDeltaResponse::~TMReplayDeltaResponse() {
  // @@protoc_insertion_point(destructor:protocol.TMReplayDeltaResponse)
  SharedDtor();
}

void TMReplayDeltaResponse::SharedDtor() {
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerheader_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMReplayDeltaResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMReplayDeltaResponse& TMReplayDeltaResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMReplayDeltaResponse_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMReplayDeltaResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMReplayDeltaResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  transaction_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ledgerhash_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      ledgerheader_.ClearNonDefaultToEmptyNoArena();
    }
    error_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TMReplayDeltaResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes ledgerHash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_ledgerhash(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes ledgerHeader = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_ledgerheader(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bytes transaction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(add_transaction(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 26);
        } else goto handle_unusual;
        continue;
      // optional .protocol.TMReplyError error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMReplyError_IsValid(val))) {
            set_error(static_cast<::protocol::TMReplyError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TMReplayDeltaResponse::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMReplayDeltaResponse)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes ledgerHash = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes ledgerHeader = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerheader()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated bytes transaction = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->add_transaction()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .protocol.TMReplyError error = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMReplyError_IsValid(value)) {
            set_error(static_cast< ::protocol::TMReplyError >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMReplayDeltaResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMReplayDeltaResponse)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TMReplayDeltaResponse::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMReplayDeltaResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes ledgerHash = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->ledgerhash(), output);
  }

  // optional bytes ledgerHeader = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->ledgerheader(), output);
  }

  // repeated bytes transaction = 3;
  for (int i = 0, n = this->transaction_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytes(
      3, this->transaction(i), output);
  }

  // optional .protocol.TMReplyError error = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      4, this->error(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMReplayDeltaResponse)
}

::PROTOBUF_NAMESPACE_ID::uint8* TMReplayDeltaResponse::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMReplayDeltaResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes ledgerHash = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->ledgerhash(), target);
  }

  // optional bytes ledgerHeader = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->ledgerheader(), target);
  }

  // repeated bytes transaction = 3;
  for (int i = 0, n = this->transaction_size(); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      WriteBytesToArray(3, this->transaction(i), target);
  }

  // optional .protocol.TMReplyError error = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->error(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMReplayDeltaResponse)
  return target;
}

size_t TMReplayDeltaResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMReplayDeltaResponse)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required bytes ledgerHash = 1;
  if (has_ledgerhash()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->ledgerhash());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes transaction = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->transaction_size());
  for (int i = 0, n = this->transaction_size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      this->transaction(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional bytes ledgerHeader = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->ledgerheader());
    }

    // optional .protocol.TMReplyError error = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->error());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMReplayDeltaResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMReplayDeltaResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const TMReplayDeltaResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMReplayDeltaResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMReplayDeltaResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMReplayDeltaResponse)
    MergeFrom(*source);
  }
}

void TMReplayDeltaResponse::MergeFrom(const TMReplayDeltaResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMReplayDeltaResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  transaction_.MergeFrom(from.transaction_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      ledgerhash_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      ledgerheader_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.ledgerheader_);
    }
    if (cached_has_bits & 0x00000004u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMReplayDeltaResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMReplayDeltaResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMReplayDeltaResponse::CopyFrom(const TMReplayDeltaResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMReplayDeltaResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMReplayDeltaResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void TMReplayDeltaResponse::Swap(TMReplayDeltaResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMReplayDeltaResponse::InternalSwap(TMReplayDeltaResponse* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  transaction_.InternalSwap(CastToBase(&other->transaction_));
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  ledgerheader_.Swap(&other->ledgerheader_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(error_, other->error_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMReplayDeltaResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protocol
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::protocol::TMManifest* Arena::CreateMaybeMessage< ::protocol::TMManifest >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMManifest >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMManifests* Arena::CreateMaybeMessage< ::protocol::TMManifests >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMManifests >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMClusterNode* Arena::CreateMaybeMessage< ::protocol::TMClusterNode >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMClusterNode >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMLoadSource* Arena::CreateMaybeMessage< ::protocol::TMLoadSource >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMLoadSource >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMCluster* Arena::CreateMaybeMessage< ::protocol::TMCluster >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMCluster >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMGetShardInfo* Arena::CreateMaybeMessage< ::protocol::TMGetShardInfo >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMGetShardInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMShardInfo* Arena::CreateMaybeMessage< ::protocol::TMShardInfo >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMShardInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMLink* Arena::CreateMaybeMessage< ::protocol::TMLink >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMLink >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMGetPeerShardInfo* Arena::CreateMaybeMessage< ::protocol::TMGetPeerShardInfo >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMGetPeerShardInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMPeerShardInfo* Arena::CreateMaybeMessage< ::protocol::TMPeerShardInfo >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMPeerShardInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMTransaction* Arena::CreateMaybeMessage< ::protocol::TMTransaction >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMTransaction >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMStatusChange* Arena::CreateMaybeMessage< ::protocol::TMStatusChange >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMStatusChange >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMProposeSet* Arena::CreateMaybeMessage< ::protocol::TMProposeSet >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMProposeSet >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMHaveTransactionSet* Arena::CreateMaybeMessage< ::protocol::TMHaveTransactionSet >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMHaveTransactionSet >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMValidatorList* Arena::CreateMaybeMessage< ::protocol::TMValidatorList >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMValidatorList >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::ValidatorBlobInfo* Arena::CreateMaybeMessage< ::protocol::ValidatorBlobInfo >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::ValidatorBlobInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMValidatorListCollection* Arena::CreateMaybeMessage< ::protocol::TMValidatorListCollection >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMValidatorListCollection >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMValidation* Arena::CreateMaybeMessage< ::protocol::TMValidation >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMValidation >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMEndpoints_TMEndpointv2* Arena::CreateMaybeMessage< ::protocol::TMEndpoints_TMEndpointv2 >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMEndpoints_TMEndpointv2 >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMEndpoints* Arena::CreateMaybeMessage< ::protocol::TMEndpoints >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMEndpoints >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMIndexedObject* Arena::CreateMaybeMessage< ::protocol::TMIndexedObject >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMIndexedObject >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMGetObjectByHash* Arena::CreateMaybeMessage< ::protocol::TMGetObjectByHash >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMGetObjectByHash >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMLedgerNode* Arena::CreateMaybeMessage< ::protocol::TMLedgerNode >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMLedgerNode >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMGetLedger* Arena::CreateMaybeMessage< ::protocol::TMGetLedger >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMGetLedger >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMLedgerData* Arena::CreateMaybeMessage< ::protocol::TMLedgerData >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMLedgerData >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMPing* Arena::CreateMaybeMessage< ::protocol::TMPing >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMPing >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMSquelch* Arena::CreateMaybeMessage< ::protocol::TMSquelch >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMSquelch >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMProofPathRequest* Arena::CreateMaybeMessage< ::protocol::TMProofPathRequest >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMProofPathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMProofPathResponse* Arena::CreateMaybeMessage< ::protocol::TMProofPathResponse >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMProofPathResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMReplayDeltaRequest* Arena::CreateMaybeMessage< ::protocol::TMReplayDeltaRequest >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMReplayDeltaRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMReplayDeltaResponse* Arena::CreateMaybeMessage< ::protocol::TMReplayDeltaResponse >(Arena* arena) {
  return Arena::CreateInternal< ::protocol::TMReplayDeltaResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
